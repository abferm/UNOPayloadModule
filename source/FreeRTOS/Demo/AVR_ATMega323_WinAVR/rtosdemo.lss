
rtosdemo.elf:     file format elf32-avr

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .text         0000266c  00000000  00000000  00000094  2**1
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  1 .data         00000052  00800060  0000266c  00002700  2**0
                  CONTENTS, ALLOC, LOAD, DATA
  2 .bss          00000683  008000b2  008000b2  00002752  2**0
                  ALLOC
  3 .debug_aranges 000001c0  00000000  00000000  00002752  2**0
                  CONTENTS, READONLY, DEBUGGING
  4 .debug_pubnames 000007e2  00000000  00000000  00002912  2**0
                  CONTENTS, READONLY, DEBUGGING
  5 .debug_info   00002dec  00000000  00000000  000030f4  2**0
                  CONTENTS, READONLY, DEBUGGING
  6 .debug_abbrev 00000faf  00000000  00000000  00005ee0  2**0
                  CONTENTS, READONLY, DEBUGGING
  7 .debug_line   00002d72  00000000  00000000  00006e8f  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_frame  00000650  00000000  00000000  00009c04  2**2
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_str    0000148c  00000000  00000000  0000a254  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_loc    000016dd  00000000  00000000  0000b6e0  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_ranges 00000030  00000000  00000000  0000cdbd  2**0
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

00000000 <__vectors>:
       0:	0c 94 28 00 	jmp	0x50	; 0x50 <__ctors_end>
       4:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       8:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
       c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      10:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      14:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      18:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      1c:	0c 94 65 0f 	jmp	0x1eca	; 0x1eca <__vector_7>
      20:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      24:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      28:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      2c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      30:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      34:	0c 94 6e 01 	jmp	0x2dc	; 0x2dc <__vector_13>
      38:	0c 94 31 01 	jmp	0x262	; 0x262 <__vector_14>
      3c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      40:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      44:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      48:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>
      4c:	0c 94 45 00 	jmp	0x8a	; 0x8a <__bad_interrupt>

00000050 <__ctors_end>:
      50:	11 24       	eor	r1, r1
      52:	1f be       	out	0x3f, r1	; 63
      54:	cf e5       	ldi	r28, 0x5F	; 95
      56:	d8 e0       	ldi	r29, 0x08	; 8
      58:	de bf       	out	0x3e, r29	; 62
      5a:	cd bf       	out	0x3d, r28	; 61

0000005c <__do_copy_data>:
      5c:	10 e0       	ldi	r17, 0x00	; 0
      5e:	a0 e6       	ldi	r26, 0x60	; 96
      60:	b0 e0       	ldi	r27, 0x00	; 0
      62:	ec e6       	ldi	r30, 0x6C	; 108
      64:	f6 e2       	ldi	r31, 0x26	; 38
      66:	02 c0       	rjmp	.+4      	; 0x6c <.do_copy_data_start>

00000068 <.do_copy_data_loop>:
      68:	05 90       	lpm	r0, Z+
      6a:	0d 92       	st	X+, r0

0000006c <.do_copy_data_start>:
      6c:	a2 3b       	cpi	r26, 0xB2	; 178
      6e:	b1 07       	cpc	r27, r17
      70:	d9 f7       	brne	.-10     	; 0x68 <.do_copy_data_loop>

00000072 <__do_clear_bss>:
      72:	17 e0       	ldi	r17, 0x07	; 7
      74:	a2 eb       	ldi	r26, 0xB2	; 178
      76:	b0 e0       	ldi	r27, 0x00	; 0
      78:	01 c0       	rjmp	.+2      	; 0x7c <.do_clear_bss_start>

0000007a <.do_clear_bss_loop>:
      7a:	1d 92       	st	X+, r1

0000007c <.do_clear_bss_start>:
      7c:	a5 33       	cpi	r26, 0x35	; 53
      7e:	b1 07       	cpc	r27, r17
      80:	e1 f7       	brne	.-8      	; 0x7a <.do_clear_bss_loop>
      82:	0e 94 4a 00 	call	0x94	; 0x94 <main>
      86:	0c 94 34 13 	jmp	0x2668	; 0x2668 <_exit>

0000008a <__bad_interrupt>:
      8a:	0c 94 00 00 	jmp	0	; 0x0 <__vectors>

0000008e <vApplicationIdleHook>:
}
/*-----------------------------------------------------------*/

void vApplicationIdleHook( void )
{
	vCoRoutineSchedule();
      8e:	0e 94 b3 0c 	call	0x1966	; 0x1966 <vCoRoutineSchedule>
}
      92:	08 95       	ret

00000094 <main>:
void vApplicationIdleHook( void );

/*-----------------------------------------------------------*/

short main( void )
{
      94:	af 92       	push	r10
      96:	bf 92       	push	r11
      98:	cf 92       	push	r12
      9a:	df 92       	push	r13
      9c:	ef 92       	push	r14
      9e:	ff 92       	push	r15
      a0:	0f 93       	push	r16
      a2:	df 93       	push	r29
      a4:	cf 93       	push	r28
      a6:	0f 92       	push	r0
      a8:	cd b7       	in	r28, 0x3d	; 61
      aa:	de b7       	in	r29, 0x3e	; 62

static void prvIncrementResetCount( void )
{
unsigned char ucCount;

	eeprom_read_block( &ucCount, mainRESET_COUNT_ADDRESS, sizeof( ucCount ) );
      ac:	ce 01       	movw	r24, r28
      ae:	01 96       	adiw	r24, 0x01	; 1
      b0:	60 e5       	ldi	r22, 0x50	; 80
      b2:	70 e0       	ldi	r23, 0x00	; 0
      b4:	41 e0       	ldi	r20, 0x01	; 1
      b6:	50 e0       	ldi	r21, 0x00	; 0
      b8:	0e 94 17 13 	call	0x262e	; 0x262e <__eerd_block_m323>
	ucCount++;
      bc:	69 81       	ldd	r22, Y+1	; 0x01
      be:	6f 5f       	subi	r22, 0xFF	; 255
      c0:	69 83       	std	Y+1, r22	; 0x01
	eeprom_write_byte( mainRESET_COUNT_ADDRESS, ucCount );
      c2:	80 e5       	ldi	r24, 0x50	; 80
      c4:	90 e0       	ldi	r25, 0x00	; 0
      c6:	0e 94 27 13 	call	0x264e	; 0x264e <__eewr_byte_m323>
short main( void )
{
	prvIncrementResetCount();

	/* Setup the LED's for output. */
	vParTestInitialise();
      ca:	0e 94 da 00 	call	0x1b4	; 0x1b4 <vParTestInitialise>

	/* Create the standard demo tasks. */
	vStartIntegerMathTasks( tskIDLE_PRIORITY );
      ce:	80 e0       	ldi	r24, 0x00	; 0
      d0:	0e 94 f2 10 	call	0x21e4	; 0x21e4 <vStartIntegerMathTasks>
	vAltStartComTestTasks( mainCOM_TEST_PRIORITY, mainCOM_TEST_BAUD_RATE, mainCOM_TEST_LED );
      d4:	82 e0       	ldi	r24, 0x02	; 2
      d6:	40 e0       	ldi	r20, 0x00	; 0
      d8:	56 e9       	ldi	r21, 0x96	; 150
      da:	60 e0       	ldi	r22, 0x00	; 0
      dc:	70 e0       	ldi	r23, 0x00	; 0
      de:	24 e0       	ldi	r18, 0x04	; 4
      e0:	0e 94 e7 11 	call	0x23ce	; 0x23ce <vAltStartComTestTasks>
	vStartPolledQueueTasks( mainQUEUE_POLL_PRIORITY );
      e4:	82 e0       	ldi	r24, 0x02	; 2
      e6:	0e 94 1f 11 	call	0x223e	; 0x223e <vStartPolledQueueTasks>
	vStartRegTestTasks();
      ea:	0e 94 62 03 	call	0x6c4	; 0x6c4 <vStartRegTestTasks>
	
	/* Create the tasks defined within this file. */
	xTaskCreate( vErrorChecks, ( signed char * ) "Check", configMINIMAL_STACK_SIZE, NULL, mainCHECK_TASK_PRIORITY, NULL );
      ee:	8a e9       	ldi	r24, 0x9A	; 154
      f0:	90 e0       	ldi	r25, 0x00	; 0
      f2:	60 e6       	ldi	r22, 0x60	; 96
      f4:	70 e0       	ldi	r23, 0x00	; 0
      f6:	45 e5       	ldi	r20, 0x55	; 85
      f8:	50 e0       	ldi	r21, 0x00	; 0
      fa:	20 e0       	ldi	r18, 0x00	; 0
      fc:	30 e0       	ldi	r19, 0x00	; 0
      fe:	03 e0       	ldi	r16, 0x03	; 3
     100:	ee 24       	eor	r14, r14
     102:	ff 24       	eor	r15, r15
     104:	cc 24       	eor	r12, r12
     106:	dd 24       	eor	r13, r13
     108:	aa 24       	eor	r10, r10
     10a:	bb 24       	eor	r11, r11
     10c:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>

	/* Create the co-routines that flash the LED's. */
	vStartFlashCoRoutines( mainNUM_FLASH_COROUTINES );
     110:	83 e0       	ldi	r24, 0x03	; 3
     112:	0e 94 c4 0f 	call	0x1f88	; 0x1f88 <vStartFlashCoRoutines>
	
	/* In this port, to use preemptive scheduler define configUSE_PREEMPTION 
	as 1 in portmacro.h.  To use the cooperative scheduler define 
	configUSE_PREEMPTION as 0. */
	vTaskStartScheduler();
     116:	0e 94 f9 07 	call	0xff2	; 0xff2 <vTaskStartScheduler>

	return 0;
}
     11a:	80 e0       	ldi	r24, 0x00	; 0
     11c:	90 e0       	ldi	r25, 0x00	; 0
     11e:	0f 90       	pop	r0
     120:	cf 91       	pop	r28
     122:	df 91       	pop	r29
     124:	0f 91       	pop	r16
     126:	ff 90       	pop	r15
     128:	ef 90       	pop	r14
     12a:	df 90       	pop	r13
     12c:	cf 90       	pop	r12
     12e:	bf 90       	pop	r11
     130:	af 90       	pop	r10
     132:	08 95       	ret

00000134 <vErrorChecks>:
/*-----------------------------------------------------------*/

static void vErrorChecks( void *pvParameters )
{
     134:	1f 93       	push	r17
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
	{
		xErrorHasOccurred = pdTRUE;
     136:	11 e0       	ldi	r17, 0x01	; 1

	/* Cycle for ever, delaying then checking all the other tasks are still
	operating without error. */
	for( ;; )
	{
		vTaskDelay( mainCHECK_PERIOD );
     138:	88 eb       	ldi	r24, 0xB8	; 184
     13a:	9b e0       	ldi	r25, 0x0B	; 11
     13c:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vTaskDelay>

		/* Perform a bit of 32bit maths to ensure the registers used by the 
		integer tasks get some exercise. The result here is not important - 
		see the demo application documentation for more info. */
		ulDummyVariable *= 3;
     140:	20 91 66 00 	lds	r18, 0x0066
     144:	30 91 67 00 	lds	r19, 0x0067
     148:	40 91 68 00 	lds	r20, 0x0068
     14c:	50 91 69 00 	lds	r21, 0x0069
     150:	da 01       	movw	r26, r20
     152:	c9 01       	movw	r24, r18
     154:	88 0f       	add	r24, r24
     156:	99 1f       	adc	r25, r25
     158:	aa 1f       	adc	r26, r26
     15a:	bb 1f       	adc	r27, r27
     15c:	82 0f       	add	r24, r18
     15e:	93 1f       	adc	r25, r19
     160:	a4 1f       	adc	r26, r20
     162:	b5 1f       	adc	r27, r21
     164:	80 93 66 00 	sts	0x0066, r24
     168:	90 93 67 00 	sts	0x0067, r25
     16c:	a0 93 68 00 	sts	0x0068, r26
     170:	b0 93 69 00 	sts	0x0069, r27

static void prvCheckOtherTasksAreStillRunning( void )
{
static portBASE_TYPE xErrorHasOccurred = pdFALSE;

	if( xAreIntegerMathsTaskStillRunning() != pdTRUE )
     174:	0e 94 eb 10 	call	0x21d6	; 0x21d6 <xAreIntegerMathsTaskStillRunning>
     178:	81 30       	cpi	r24, 0x01	; 1
     17a:	11 f0       	breq	.+4      	; 0x180 <vErrorChecks+0x4c>
	{
		xErrorHasOccurred = pdTRUE;
     17c:	10 93 b2 00 	sts	0x00B2, r17
	}

	if( xAreComTestTasksStillRunning() != pdTRUE )
     180:	0e 94 e0 11 	call	0x23c0	; 0x23c0 <xAreComTestTasksStillRunning>
     184:	81 30       	cpi	r24, 0x01	; 1
     186:	11 f0       	breq	.+4      	; 0x18c <vErrorChecks+0x58>
	{
		xErrorHasOccurred = pdTRUE;
     188:	10 93 b2 00 	sts	0x00B2, r17
	}

	if( xArePollingQueuesStillRunning() != pdTRUE )
     18c:	0e 94 12 11 	call	0x2224	; 0x2224 <xArePollingQueuesStillRunning>
     190:	81 30       	cpi	r24, 0x01	; 1
     192:	11 f0       	breq	.+4      	; 0x198 <vErrorChecks+0x64>
	{
		xErrorHasOccurred = pdTRUE;
     194:	10 93 b2 00 	sts	0x00B2, r17
	}

	if( xAreRegTestTasksStillRunning() != pdTRUE )
     198:	0e 94 16 02 	call	0x42c	; 0x42c <xAreRegTestTasksStillRunning>
     19c:	81 30       	cpi	r24, 0x01	; 1
     19e:	11 f0       	breq	.+4      	; 0x1a4 <vErrorChecks+0x70>
	{
		xErrorHasOccurred = pdTRUE;
     1a0:	10 93 b2 00 	sts	0x00B2, r17
	}
	
	if( xErrorHasOccurred == pdFALSE )
     1a4:	80 91 b2 00 	lds	r24, 0x00B2
     1a8:	88 23       	and	r24, r24
     1aa:	31 f6       	brne	.-116    	; 0x138 <vErrorChecks+0x4>
	{
		/* Toggle the LED if everything is okay so we know if an error occurs even if not
		using console IO. */
		vParTestToggleLED( mainCHECK_TASK_LED );
     1ac:	87 e0       	ldi	r24, 0x07	; 7
     1ae:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <vParTestToggleLED>
     1b2:	c2 cf       	rjmp	.-124    	; 0x138 <vErrorChecks+0x4>

000001b4 <vParTestInitialise>:

/*-----------------------------------------------------------*/

void vParTestInitialise( void )
{
	ucCurrentOutputValue = partstALL_OUTPUTS_OFF;
     1b4:	8f ef       	ldi	r24, 0xFF	; 255
     1b6:	80 93 6a 00 	sts	0x006A, r24

	/* Set port B direction to outputs.  Start with all output off. */
	DDRB = partstALL_BITS_OUTPUT;
     1ba:	87 bb       	out	0x17, r24	; 23
	PORTB = ucCurrentOutputValue;
     1bc:	80 91 6a 00 	lds	r24, 0x006A
     1c0:	88 bb       	out	0x18, r24	; 24
}
     1c2:	08 95       	ret

000001c4 <vParTestToggleLED>:
	}
}
/*-----------------------------------------------------------*/

void vParTestToggleLED( unsigned portBASE_TYPE uxLED )
{
     1c4:	1f 93       	push	r17
     1c6:	28 2f       	mov	r18, r24
unsigned char ucBit;

	if( uxLED <= partstMAX_OUTPUT_LED )
     1c8:	88 30       	cpi	r24, 0x08	; 8
     1ca:	e8 f4       	brcc	.+58     	; 0x206 <vParTestToggleLED+0x42>
	{
		ucBit = ( ( unsigned char ) 1 ) << uxLED;
     1cc:	81 e0       	ldi	r24, 0x01	; 1
     1ce:	90 e0       	ldi	r25, 0x00	; 0
     1d0:	02 c0       	rjmp	.+4      	; 0x1d6 <vParTestToggleLED+0x12>
     1d2:	88 0f       	add	r24, r24
     1d4:	99 1f       	adc	r25, r25
     1d6:	2a 95       	dec	r18
     1d8:	e2 f7       	brpl	.-8      	; 0x1d2 <vParTestToggleLED+0xe>
     1da:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     1dc:	0e 94 8c 03 	call	0x718	; 0x718 <vTaskSuspendAll>
		{
			if( ucCurrentOutputValue & ucBit )
     1e0:	80 91 6a 00 	lds	r24, 0x006A
     1e4:	81 23       	and	r24, r17
     1e6:	29 f0       	breq	.+10     	; 0x1f2 <vParTestToggleLED+0x2e>
			{
				ucCurrentOutputValue &= ~ucBit;
     1e8:	80 91 6a 00 	lds	r24, 0x006A
     1ec:	10 95       	com	r17
     1ee:	18 23       	and	r17, r24
     1f0:	03 c0       	rjmp	.+6      	; 0x1f8 <vParTestToggleLED+0x34>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     1f2:	80 91 6a 00 	lds	r24, 0x006A
     1f6:	18 2b       	or	r17, r24
     1f8:	10 93 6a 00 	sts	0x006A, r17
			}

			PORTB = ucCurrentOutputValue;
     1fc:	80 91 6a 00 	lds	r24, 0x006A
     200:	88 bb       	out	0x18, r24	; 24
		}
		xTaskResumeAll();			
     202:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
	}
}
     206:	1f 91       	pop	r17
     208:	08 95       	ret

0000020a <vParTestSetLED>:
	PORTB = ucCurrentOutputValue;
}
/*-----------------------------------------------------------*/

void vParTestSetLED( unsigned portBASE_TYPE uxLED, signed portBASE_TYPE xValue )
{
     20a:	0f 93       	push	r16
     20c:	1f 93       	push	r17
     20e:	28 2f       	mov	r18, r24
     210:	06 2f       	mov	r16, r22
unsigned char ucBit = ( unsigned char ) 1;

	if( uxLED <= partstMAX_OUTPUT_LED )
     212:	88 30       	cpi	r24, 0x08	; 8
     214:	d8 f4       	brcc	.+54     	; 0x24c <vParTestSetLED+0x42>
	{
		ucBit <<= uxLED;	
     216:	81 e0       	ldi	r24, 0x01	; 1
     218:	90 e0       	ldi	r25, 0x00	; 0
     21a:	02 c0       	rjmp	.+4      	; 0x220 <vParTestSetLED+0x16>
     21c:	88 0f       	add	r24, r24
     21e:	99 1f       	adc	r25, r25
     220:	2a 95       	dec	r18
     222:	e2 f7       	brpl	.-8      	; 0x21c <vParTestSetLED+0x12>
     224:	18 2f       	mov	r17, r24

		vTaskSuspendAll();
     226:	0e 94 8c 03 	call	0x718	; 0x718 <vTaskSuspendAll>
		{
			if( xValue == pdTRUE )
     22a:	01 30       	cpi	r16, 0x01	; 1
     22c:	29 f4       	brne	.+10     	; 0x238 <vParTestSetLED+0x2e>
			{
				ucBit ^= ( unsigned char ) 0xff;
				ucCurrentOutputValue &= ucBit;
     22e:	80 91 6a 00 	lds	r24, 0x006A
     232:	10 95       	com	r17
     234:	18 23       	and	r17, r24
     236:	03 c0       	rjmp	.+6      	; 0x23e <vParTestSetLED+0x34>
			}
			else
			{
				ucCurrentOutputValue |= ucBit;
     238:	80 91 6a 00 	lds	r24, 0x006A
     23c:	18 2b       	or	r17, r24
     23e:	10 93 6a 00 	sts	0x006A, r17
			}

			PORTB = ucCurrentOutputValue;
     242:	80 91 6a 00 	lds	r24, 0x006A
     246:	88 bb       	out	0x18, r24	; 24
		}
		xTaskResumeAll();
     248:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
	}
}
     24c:	1f 91       	pop	r17
     24e:	0f 91       	pop	r16
     250:	08 95       	ret

00000252 <vSerialClose>:
	( void ) xPort;

	/* Turn off the interrupts.  We may also want to delete the queues and/or
	re-install the original ISR. */

	portENTER_CRITICAL();
     252:	0f b6       	in	r0, 0x3f	; 63
     254:	f8 94       	cli
     256:	0f 92       	push	r0
	{
		vInterruptOff();
     258:	55 98       	cbi	0x0a, 5	; 10
		ucByte = UCSRB;
		ucByte &= ~serRX_INT_ENABLE;
		UCSRB = ucByte;
     25a:	57 98       	cbi	0x0a, 7	; 10
	}
	portEXIT_CRITICAL();
     25c:	0f 90       	pop	r0
     25e:	0f be       	out	0x3f, r0	; 63
}
     260:	08 95       	ret

00000262 <__vector_14>:
	}
}
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_DATA )
{
     262:	1f 92       	push	r1
     264:	0f 92       	push	r0
     266:	0f b6       	in	r0, 0x3f	; 63
     268:	0f 92       	push	r0
     26a:	11 24       	eor	r1, r1
     26c:	2f 93       	push	r18
     26e:	3f 93       	push	r19
     270:	4f 93       	push	r20
     272:	5f 93       	push	r21
     274:	6f 93       	push	r22
     276:	7f 93       	push	r23
     278:	8f 93       	push	r24
     27a:	9f 93       	push	r25
     27c:	af 93       	push	r26
     27e:	bf 93       	push	r27
     280:	ef 93       	push	r30
     282:	ff 93       	push	r31
     284:	df 93       	push	r29
     286:	cf 93       	push	r28
     288:	00 d0       	rcall	.+0      	; 0x28a <__vector_14+0x28>
     28a:	cd b7       	in	r28, 0x3d	; 61
     28c:	de b7       	in	r29, 0x3e	; 62
signed char cChar, cTaskWoken;

	if( xQueueReceiveFromISR( xCharsForTx, &cChar, &cTaskWoken ) == pdTRUE )
     28e:	80 91 b5 00 	lds	r24, 0x00B5
     292:	90 91 b6 00 	lds	r25, 0x00B6
     296:	be 01       	movw	r22, r28
     298:	6f 5f       	subi	r22, 0xFF	; 255
     29a:	7f 4f       	sbci	r23, 0xFF	; 255
     29c:	ae 01       	movw	r20, r28
     29e:	4e 5f       	subi	r20, 0xFE	; 254
     2a0:	5f 4f       	sbci	r21, 0xFF	; 255
     2a2:	0e 94 64 09 	call	0x12c8	; 0x12c8 <xQueueReceiveFromISR>
     2a6:	81 30       	cpi	r24, 0x01	; 1
     2a8:	19 f4       	brne	.+6      	; 0x2b0 <__vector_14+0x4e>
	{
		/* Send the next character queued for Tx. */
		UDR = cChar;
     2aa:	89 81       	ldd	r24, Y+1	; 0x01
     2ac:	8c b9       	out	0x0c, r24	; 12
     2ae:	01 c0       	rjmp	.+2      	; 0x2b2 <__vector_14+0x50>
	}
	else
	{
		/* Queue empty, nothing to send. */
		vInterruptOff();
     2b0:	55 98       	cbi	0x0a, 5	; 10
	}
}
     2b2:	0f 90       	pop	r0
     2b4:	0f 90       	pop	r0
     2b6:	cf 91       	pop	r28
     2b8:	df 91       	pop	r29
     2ba:	ff 91       	pop	r31
     2bc:	ef 91       	pop	r30
     2be:	bf 91       	pop	r27
     2c0:	af 91       	pop	r26
     2c2:	9f 91       	pop	r25
     2c4:	8f 91       	pop	r24
     2c6:	7f 91       	pop	r23
     2c8:	6f 91       	pop	r22
     2ca:	5f 91       	pop	r21
     2cc:	4f 91       	pop	r20
     2ce:	3f 91       	pop	r19
     2d0:	2f 91       	pop	r18
     2d2:	0f 90       	pop	r0
     2d4:	0f be       	out	0x3f, r0	; 63
     2d6:	0f 90       	pop	r0
     2d8:	1f 90       	pop	r1
     2da:	18 95       	reti

000002dc <__vector_13>:
	portEXIT_CRITICAL();
}
/*-----------------------------------------------------------*/

SIGNAL( SIG_UART_RECV )
{
     2dc:	1f 92       	push	r1
     2de:	0f 92       	push	r0
     2e0:	0f b6       	in	r0, 0x3f	; 63
     2e2:	0f 92       	push	r0
     2e4:	11 24       	eor	r1, r1
     2e6:	2f 93       	push	r18
     2e8:	3f 93       	push	r19
     2ea:	4f 93       	push	r20
     2ec:	5f 93       	push	r21
     2ee:	6f 93       	push	r22
     2f0:	7f 93       	push	r23
     2f2:	8f 93       	push	r24
     2f4:	9f 93       	push	r25
     2f6:	af 93       	push	r26
     2f8:	bf 93       	push	r27
     2fa:	ef 93       	push	r30
     2fc:	ff 93       	push	r31
     2fe:	df 93       	push	r29
     300:	cf 93       	push	r28
     302:	00 d0       	rcall	.+0      	; 0x304 <__vector_13+0x28>
     304:	cd b7       	in	r28, 0x3d	; 61
     306:	de b7       	in	r29, 0x3e	; 62
signed char cChar;
signed portBASE_TYPE xHigherPriorityTaskWoken = pdFALSE;
     308:	1a 82       	std	Y+2, r1	; 0x02

	/* Get the character and post it on the queue of Rxed characters.
	If the post causes a task to wake force a context switch as the woken task
	may have a higher priority than the task we have interrupted. */
	cChar = UDR;
     30a:	8c b1       	in	r24, 0x0c	; 12
     30c:	89 83       	std	Y+1, r24	; 0x01

	xQueueSendFromISR( xRxedChars, &cChar, &xHigherPriorityTaskWoken );
     30e:	80 91 b3 00 	lds	r24, 0x00B3
     312:	90 91 b4 00 	lds	r25, 0x00B4
     316:	be 01       	movw	r22, r28
     318:	6f 5f       	subi	r22, 0xFF	; 255
     31a:	7f 4f       	sbci	r23, 0xFF	; 255
     31c:	ae 01       	movw	r20, r28
     31e:	4e 5f       	subi	r20, 0xFE	; 254
     320:	5f 4f       	sbci	r21, 0xFF	; 255
     322:	20 e0       	ldi	r18, 0x00	; 0
     324:	0e 94 a7 09 	call	0x134e	; 0x134e <xQueueGenericSendFromISR>

	if( xHigherPriorityTaskWoken != pdFALSE )
     328:	8a 81       	ldd	r24, Y+2	; 0x02
     32a:	88 23       	and	r24, r24
     32c:	11 f0       	breq	.+4      	; 0x332 <__vector_13+0x56>
	{
		taskYIELD();
     32e:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
	}
}
     332:	0f 90       	pop	r0
     334:	0f 90       	pop	r0
     336:	cf 91       	pop	r28
     338:	df 91       	pop	r29
     33a:	ff 91       	pop	r31
     33c:	ef 91       	pop	r30
     33e:	bf 91       	pop	r27
     340:	af 91       	pop	r26
     342:	9f 91       	pop	r25
     344:	8f 91       	pop	r24
     346:	7f 91       	pop	r23
     348:	6f 91       	pop	r22
     34a:	5f 91       	pop	r21
     34c:	4f 91       	pop	r20
     34e:	3f 91       	pop	r19
     350:	2f 91       	pop	r18
     352:	0f 90       	pop	r0
     354:	0f be       	out	0x3f, r0	; 63
     356:	0f 90       	pop	r0
     358:	1f 90       	pop	r1
     35a:	18 95       	reti

0000035c <xSerialPutChar>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xSerialPutChar( xComPortHandle pxPort, signed char cOutChar, portTickType xBlockTime )
{
     35c:	df 93       	push	r29
     35e:	cf 93       	push	r28
     360:	0f 92       	push	r0
     362:	cd b7       	in	r28, 0x3d	; 61
     364:	de b7       	in	r29, 0x3e	; 62
     366:	69 83       	std	Y+1, r22	; 0x01
	/* Only one port is supported. */
	( void ) pxPort;

	/* Return false if after the block time there is no room on the Tx queue. */
	if( xQueueSend( xCharsForTx, &cOutChar, xBlockTime ) != pdPASS )
     368:	80 91 b5 00 	lds	r24, 0x00B5
     36c:	90 91 b6 00 	lds	r25, 0x00B6
     370:	be 01       	movw	r22, r28
     372:	6f 5f       	subi	r22, 0xFF	; 255
     374:	7f 4f       	sbci	r23, 0xFF	; 255
     376:	20 e0       	ldi	r18, 0x00	; 0
     378:	0e 94 df 0a 	call	0x15be	; 0x15be <xQueueGenericSend>
     37c:	81 30       	cpi	r24, 0x01	; 1
     37e:	11 f0       	breq	.+4      	; 0x384 <xSerialPutChar+0x28>
     380:	80 e0       	ldi	r24, 0x00	; 0
     382:	02 c0       	rjmp	.+4      	; 0x388 <xSerialPutChar+0x2c>
	{
		return pdFAIL;
	}

	vInterruptOn();
     384:	55 9a       	sbi	0x0a, 5	; 10
     386:	81 e0       	ldi	r24, 0x01	; 1

	return pdPASS;
}
     388:	0f 90       	pop	r0
     38a:	cf 91       	pop	r28
     38c:	df 91       	pop	r29
     38e:	08 95       	ret

00000390 <xSerialGetChar>:
	/* Only one port is supported. */
	( void ) pxPort;

	/* Get the next character from the buffer.  Return false if no characters
	are available, or arrive before xBlockTime expires. */
	if( xQueueReceive( xRxedChars, pcRxedChar, xBlockTime ) )
     390:	80 91 b3 00 	lds	r24, 0x00B3
     394:	90 91 b4 00 	lds	r25, 0x00B4
     398:	20 e0       	ldi	r18, 0x00	; 0
     39a:	0e 94 13 0a 	call	0x1426	; 0x1426 <xQueueGenericReceive>
     39e:	81 11       	cpse	r24, r1
     3a0:	81 e0       	ldi	r24, 0x01	; 1
	}
	else
	{
		return pdFALSE;
	}
}
     3a2:	08 95       	ret

000003a4 <xSerialPortInitMinimal>:
	UCSRB = ucInByte;										\
}
/*-----------------------------------------------------------*/

xComPortHandle xSerialPortInitMinimal( unsigned long ulWantedBaud, unsigned portBASE_TYPE uxQueueLength )
{
     3a4:	df 92       	push	r13
     3a6:	ef 92       	push	r14
     3a8:	ff 92       	push	r15
     3aa:	0f 93       	push	r16
     3ac:	1f 93       	push	r17
     3ae:	7b 01       	movw	r14, r22
     3b0:	8c 01       	movw	r16, r24
     3b2:	d4 2e       	mov	r13, r20
unsigned long ulBaudRateCounter;
unsigned char ucByte;

	portENTER_CRITICAL();
     3b4:	0f b6       	in	r0, 0x3f	; 63
     3b6:	f8 94       	cli
     3b8:	0f 92       	push	r0
	{
		/* Create the queues used by the com test task. */
		xRxedChars = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     3ba:	84 2f       	mov	r24, r20
     3bc:	61 e0       	ldi	r22, 0x01	; 1
     3be:	40 e0       	ldi	r20, 0x00	; 0
     3c0:	0e 94 c5 0b 	call	0x178a	; 0x178a <xQueueGenericCreate>
     3c4:	90 93 b4 00 	sts	0x00B4, r25
     3c8:	80 93 b3 00 	sts	0x00B3, r24
		xCharsForTx = xQueueCreate( uxQueueLength, ( unsigned portBASE_TYPE ) sizeof( signed char ) );
     3cc:	8d 2d       	mov	r24, r13
     3ce:	61 e0       	ldi	r22, 0x01	; 1
     3d0:	40 e0       	ldi	r20, 0x00	; 0
     3d2:	0e 94 c5 0b 	call	0x178a	; 0x178a <xQueueGenericCreate>
     3d6:	90 93 b6 00 	sts	0x00B6, r25
     3da:	80 93 b5 00 	sts	0x00B5, r24

		/* Calculate the baud rate register value from the equation in the
		data sheet. */
		ulBaudRateCounter = ( configCPU_CLOCK_HZ / ( serBAUD_DIV_CONSTANT * ulWantedBaud ) ) - ( unsigned long ) 1;
     3de:	94 e0       	ldi	r25, 0x04	; 4
     3e0:	ee 0c       	add	r14, r14
     3e2:	ff 1c       	adc	r15, r15
     3e4:	00 1f       	adc	r16, r16
     3e6:	11 1f       	adc	r17, r17
     3e8:	9a 95       	dec	r25
     3ea:	d1 f7       	brne	.-12     	; 0x3e0 <xSerialPortInitMinimal+0x3c>
     3ec:	60 e0       	ldi	r22, 0x00	; 0
     3ee:	72 e1       	ldi	r23, 0x12	; 18
     3f0:	8a e7       	ldi	r24, 0x7A	; 122
     3f2:	90 e0       	ldi	r25, 0x00	; 0
     3f4:	a8 01       	movw	r20, r16
     3f6:	97 01       	movw	r18, r14
     3f8:	0e 94 bb 12 	call	0x2576	; 0x2576 <__udivmodsi4>
     3fc:	21 50       	subi	r18, 0x01	; 1
     3fe:	30 40       	sbci	r19, 0x00	; 0
     400:	40 40       	sbci	r20, 0x00	; 0
     402:	50 40       	sbci	r21, 0x00	; 0

		/* Set the baud rate. */	
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
		UBRRL = ucByte;
     404:	29 b9       	out	0x09, r18	; 9

		ulBaudRateCounter >>= ( unsigned long ) 8;
		ucByte = ( unsigned char ) ( ulBaudRateCounter & ( unsigned long ) 0xff );	
     406:	23 2f       	mov	r18, r19
     408:	34 2f       	mov	r19, r20
     40a:	45 2f       	mov	r20, r21
     40c:	55 27       	eor	r21, r21
		UBRRH = ucByte;
     40e:	20 bd       	out	0x20, r18	; 32

		/* Enable the Rx interrupt.  The Tx interrupt will get enabled
		later. Also enable the Rx and Tx. */
		UCSRB = ( serRX_INT_ENABLE | serRX_ENABLE | serTX_ENABLE );
     410:	88 e9       	ldi	r24, 0x98	; 152
     412:	8a b9       	out	0x0a, r24	; 10

		/* Set the data bits to 8. */
		UCSRC = ( serUCSRC_SELECT | serEIGHT_DATA_BITS );
     414:	86 e8       	ldi	r24, 0x86	; 134
     416:	80 bd       	out	0x20, r24	; 32
	}
	portEXIT_CRITICAL();
     418:	0f 90       	pop	r0
     41a:	0f be       	out	0x3f, r0	; 63
	
	/* Unlike other ports, this serial code does not allow for more than one
	com port.  We therefore don't return a pointer to a port structure and can
	instead just return NULL. */
	return NULL;
}
     41c:	80 e0       	ldi	r24, 0x00	; 0
     41e:	90 e0       	ldi	r25, 0x00	; 0
     420:	1f 91       	pop	r17
     422:	0f 91       	pop	r16
     424:	ff 90       	pop	r15
     426:	ef 90       	pop	r14
     428:	df 90       	pop	r13
     42a:	08 95       	ret

0000042c <xAreRegTestTasksStillRunning>:
	xTaskCreate( prvRegisterCheck2, ( signed char * ) "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );		
}
/*-----------------------------------------------------------*/

portBASE_TYPE xAreRegTestTasksStillRunning( void )
{
     42c:	90 e0       	ldi	r25, 0x00	; 0
     42e:	80 91 b7 00 	lds	r24, 0x00B7
     432:	88 23       	and	r24, r24
     434:	09 f4       	brne	.+2      	; 0x438 <xAreRegTestTasksStillRunning+0xc>
     436:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}
	
	return xReturn;
}
     438:	89 2f       	mov	r24, r25
     43a:	08 95       	ret

0000043c <prvRegisterCheck1>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	5"		);		
     43c:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r0,		r31"	);
     43e:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	6"		);
     440:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r1,		r31"	);
     442:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	7"		);
     444:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r2,		r31"	);
     446:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	8"		);
     448:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r3,		r31"	);
     44a:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	9"		);
     44c:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r4,		r31"	);
     44e:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	10"		);
     450:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r5,		r31"	);
     452:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	11"		);
     454:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r6,		r31"	);
     456:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	12"		);
     458:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r7,		r31"	);
     45a:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	13"		);
     45c:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r8,		r31"	);
     45e:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	14"		);
     460:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r9,		r31"	);
     462:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	15"		);
     464:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r10,	r31"	);
     466:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	16"		);
     468:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r11,	r31"	);
     46a:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	17"		);
     46c:	f1 e1       	ldi	r31, 0x11	; 17
		asm( 	"MOV	r12,	r31"	);
     46e:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	18"		);
     470:	f2 e1       	ldi	r31, 0x12	; 18
		asm( 	"MOV	r13,	r31"	);
     472:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	19"		);
     474:	f3 e1       	ldi	r31, 0x13	; 19
		asm( 	"MOV	r14,	r31"	);
     476:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	20"		);
     478:	f4 e1       	ldi	r31, 0x14	; 20
		asm( 	"MOV	r15,	r31"	);
     47a:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	21"		);
     47c:	05 e1       	ldi	r16, 0x15	; 21
		asm(	"LDI	r17,	22"		);
     47e:	16 e1       	ldi	r17, 0x16	; 22
		asm(	"LDI	r18,	23"		);
     480:	27 e1       	ldi	r18, 0x17	; 23
		asm(	"LDI	r19,	24"		);
     482:	38 e1       	ldi	r19, 0x18	; 24
		asm(	"LDI	r20,	25"		);
     484:	49 e1       	ldi	r20, 0x19	; 25
		asm(	"LDI	r21,	26"		);
     486:	5a e1       	ldi	r21, 0x1A	; 26
		asm(	"LDI	r22,	27"		);
     488:	6b e1       	ldi	r22, 0x1B	; 27
		asm(	"LDI	r23,	28"		);
     48a:	7c e1       	ldi	r23, 0x1C	; 28
		asm(	"LDI	r24,	29"		);
     48c:	8d e1       	ldi	r24, 0x1D	; 29
		asm(	"LDI	r25,	30"		);
     48e:	9e e1       	ldi	r25, 0x1E	; 30
		asm(	"LDI	r26,	31"		);
     490:	af e1       	ldi	r26, 0x1F	; 31
		asm(	"LDI	r27,	32"		);
     492:	b0 e2       	ldi	r27, 0x20	; 32
		asm(	"LDI	r30,	33"		);
     494:	e1 e2       	ldi	r30, 0x21	; 33

		asm(	"LDI	r31,	5"			);
     496:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r0"			);
     498:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     49a:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	6"			);
     49e:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r1"			);
     4a0:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     4a2:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	7"			);
     4a6:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r2"			);
     4a8:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     4aa:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	8"			);
     4ae:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r3"			);
     4b0:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     4b2:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	9"			);
     4b6:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r4"			);
     4b8:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     4ba:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	10"			);
     4be:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r5"			);
     4c0:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     4c2:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	11"			);
     4c6:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r6"			);
     4c8:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     4ca:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	12"			);
     4ce:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r7"			);
     4d0:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     4d2:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	13"			);
     4d6:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r8"			);
     4d8:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     4da:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	14"			);
     4de:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r9"			);
     4e0:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     4e2:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	15"			);
     4e6:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r10"		);
     4e8:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     4ea:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	16"			);
     4ee:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r11"		);
     4f0:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     4f2:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	17"			);
     4f6:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r12"		);
     4f8:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     4fa:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	18"			);
     4fe:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r13"		);
     500:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     502:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	19"			);
     506:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r14"		);
     508:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     50a:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	20"			);
     50e:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r15"		);
     510:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     512:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	21"			);
     516:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r16"		);
     518:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     51a:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	22"			);
     51e:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r17"		);
     520:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     522:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	23"			);
     526:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r18"		);
     528:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     52a:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	24"			);
     52e:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r19"		);
     530:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     532:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	25"			);
     536:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r20"		);
     538:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     53a:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	26"			);
     53e:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r21"		);
     540:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     542:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	27"			);
     546:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r22"		);
     548:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     54a:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	28"			);
     54e:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r23"		);
     550:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     552:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	29"			);
     556:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r24"		);
     558:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     55a:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	30"			);
     55e:	fe e1       	ldi	r31, 0x1E	; 30
		asm(	"CPSE	r31,	r25"		);
     560:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     562:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	31"			);
     566:	ff e1       	ldi	r31, 0x1F	; 31
		asm(	"CPSE	r31,	r26"		);
     568:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     56a:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	32"			);
     56e:	f0 e2       	ldi	r31, 0x20	; 32
		asm(	"CPSE	r31,	r27"		);
     570:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     572:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	33"			);
     576:	f1 e2       	ldi	r31, 0x21	; 33
		asm(	"CPSE	r31,	r30"		);
     578:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     57a:	00 92 b7 00 	sts	0x00B7, r0
     57e:	5e cf       	rjmp	.-324    	; 0x43c <prvRegisterCheck1>

00000580 <prvRegisterCheck2>:
{
	( void ) pvParameters;

	for( ;; )
	{
		asm(	"LDI	r31,	1"		);		
     580:	f1 e0       	ldi	r31, 0x01	; 1
		asm( 	"MOV	r0,		r31"	);
     582:	0f 2e       	mov	r0, r31
		asm(	"LDI	r31,	2"		);
     584:	f2 e0       	ldi	r31, 0x02	; 2
		asm( 	"MOV	r1,		r31"	);
     586:	1f 2e       	mov	r1, r31
		asm(	"LDI	r31,	3"		);
     588:	f3 e0       	ldi	r31, 0x03	; 3
		asm( 	"MOV	r2,		r31"	);
     58a:	2f 2e       	mov	r2, r31
		asm(	"LDI	r31,	4"		);
     58c:	f4 e0       	ldi	r31, 0x04	; 4
		asm( 	"MOV	r3,		r31"	);
     58e:	3f 2e       	mov	r3, r31
		asm(	"LDI	r31,	5"		);
     590:	f5 e0       	ldi	r31, 0x05	; 5
		asm( 	"MOV	r4,		r31"	);
     592:	4f 2e       	mov	r4, r31
		asm(	"LDI	r31,	6"		);
     594:	f6 e0       	ldi	r31, 0x06	; 6
		asm( 	"MOV	r5,		r31"	);
     596:	5f 2e       	mov	r5, r31
		asm(	"LDI	r31,	7"		);
     598:	f7 e0       	ldi	r31, 0x07	; 7
		asm( 	"MOV	r6,		r31"	);
     59a:	6f 2e       	mov	r6, r31
		asm(	"LDI	r31,	8"		);
     59c:	f8 e0       	ldi	r31, 0x08	; 8
		asm( 	"MOV	r7,		r31"	);
     59e:	7f 2e       	mov	r7, r31
		asm(	"LDI	r31,	9"		);
     5a0:	f9 e0       	ldi	r31, 0x09	; 9
		asm( 	"MOV	r8,		r31"	);
     5a2:	8f 2e       	mov	r8, r31
		asm(	"LDI	r31,	10"		);
     5a4:	fa e0       	ldi	r31, 0x0A	; 10
		asm( 	"MOV	r9,		r31"	);
     5a6:	9f 2e       	mov	r9, r31
		asm(	"LDI	r31,	11"		);
     5a8:	fb e0       	ldi	r31, 0x0B	; 11
		asm( 	"MOV	r10,	r31"	);
     5aa:	af 2e       	mov	r10, r31
		asm(	"LDI	r31,	12"		);
     5ac:	fc e0       	ldi	r31, 0x0C	; 12
		asm( 	"MOV	r11,	r31"	);
     5ae:	bf 2e       	mov	r11, r31
		asm(	"LDI	r31,	13"		);
     5b0:	fd e0       	ldi	r31, 0x0D	; 13
		asm( 	"MOV	r12,	r31"	);
     5b2:	cf 2e       	mov	r12, r31
		asm(	"LDI	r31,	14"		);
     5b4:	fe e0       	ldi	r31, 0x0E	; 14
		asm( 	"MOV	r13,	r31"	);
     5b6:	df 2e       	mov	r13, r31
		asm(	"LDI	r31,	15"		);
     5b8:	ff e0       	ldi	r31, 0x0F	; 15
		asm( 	"MOV	r14,	r31"	);
     5ba:	ef 2e       	mov	r14, r31
		asm(	"LDI	r31,	16"		);
     5bc:	f0 e1       	ldi	r31, 0x10	; 16
		asm( 	"MOV	r15,	r31"	);
     5be:	ff 2e       	mov	r15, r31
		asm(	"LDI	r16,	17"		);
     5c0:	01 e1       	ldi	r16, 0x11	; 17
		asm(	"LDI	r17,	18"		);
     5c2:	12 e1       	ldi	r17, 0x12	; 18
		asm(	"LDI	r18,	19"		);
     5c4:	23 e1       	ldi	r18, 0x13	; 19
		asm(	"LDI	r19,	20"		);
     5c6:	34 e1       	ldi	r19, 0x14	; 20
		asm(	"LDI	r20,	21"		);
     5c8:	45 e1       	ldi	r20, 0x15	; 21
		asm(	"LDI	r21,	22"		);
     5ca:	56 e1       	ldi	r21, 0x16	; 22
		asm(	"LDI	r22,	23"		);
     5cc:	67 e1       	ldi	r22, 0x17	; 23
		asm(	"LDI	r23,	24"		);
     5ce:	78 e1       	ldi	r23, 0x18	; 24
		asm(	"LDI	r24,	25"		);
     5d0:	89 e1       	ldi	r24, 0x19	; 25
		asm(	"LDI	r25,	26"		);
     5d2:	9a e1       	ldi	r25, 0x1A	; 26
		asm(	"LDI	r26,	27"		);
     5d4:	ab e1       	ldi	r26, 0x1B	; 27
		asm(	"LDI	r27,	28"		);
     5d6:	bc e1       	ldi	r27, 0x1C	; 28
		asm(	"LDI	r30,	29"		);
     5d8:	ed e1       	ldi	r30, 0x1D	; 29

		asm(	"LDI	r31,	1"			);
     5da:	f1 e0       	ldi	r31, 0x01	; 1
		asm(	"CPSE	r31,	r0"			);
     5dc:	f0 11       	cpse	r31, r0
		asm(	"STS	xRegTestError, r0"	);
     5de:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	2"			);
     5e2:	f2 e0       	ldi	r31, 0x02	; 2
		asm(	"CPSE	r31,	r1"			);
     5e4:	f1 11       	cpse	r31, r1
		asm(	"STS	xRegTestError, r0"	);
     5e6:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	3"			);
     5ea:	f3 e0       	ldi	r31, 0x03	; 3
		asm(	"CPSE	r31,	r2"			);
     5ec:	f2 11       	cpse	r31, r2
		asm(	"STS	xRegTestError, r0"	);
     5ee:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	4"			);
     5f2:	f4 e0       	ldi	r31, 0x04	; 4
		asm(	"CPSE	r31,	r3"			);
     5f4:	f3 11       	cpse	r31, r3
		asm(	"STS	xRegTestError, r0"	);
     5f6:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	5"			);
     5fa:	f5 e0       	ldi	r31, 0x05	; 5
		asm(	"CPSE	r31,	r4"			);
     5fc:	f4 11       	cpse	r31, r4
		asm(	"STS	xRegTestError, r0"	);
     5fe:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	6"			);
     602:	f6 e0       	ldi	r31, 0x06	; 6
		asm(	"CPSE	r31,	r5"			);
     604:	f5 11       	cpse	r31, r5
		asm(	"STS	xRegTestError, r0"	);
     606:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	7"			);
     60a:	f7 e0       	ldi	r31, 0x07	; 7
		asm(	"CPSE	r31,	r6"			);
     60c:	f6 11       	cpse	r31, r6
		asm(	"STS	xRegTestError, r0"	);
     60e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	8"			);
     612:	f8 e0       	ldi	r31, 0x08	; 8
		asm(	"CPSE	r31,	r7"			);
     614:	f7 11       	cpse	r31, r7
		asm(	"STS	xRegTestError, r0"	);
     616:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	9"			);
     61a:	f9 e0       	ldi	r31, 0x09	; 9
		asm(	"CPSE	r31,	r8"			);
     61c:	f8 11       	cpse	r31, r8
		asm(	"STS	xRegTestError, r0"	);
     61e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	10"			);
     622:	fa e0       	ldi	r31, 0x0A	; 10
		asm(	"CPSE	r31,	r9"			);
     624:	f9 11       	cpse	r31, r9
		asm(	"STS	xRegTestError, r0"	);
     626:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	11"			);
     62a:	fb e0       	ldi	r31, 0x0B	; 11
		asm(	"CPSE	r31,	r10"		);
     62c:	fa 11       	cpse	r31, r10
		asm(	"STS	xRegTestError, r0"	);
     62e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	12"			);
     632:	fc e0       	ldi	r31, 0x0C	; 12
		asm(	"CPSE	r31,	r11"		);
     634:	fb 11       	cpse	r31, r11
		asm(	"STS	xRegTestError, r0"	);
     636:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	13"			);
     63a:	fd e0       	ldi	r31, 0x0D	; 13
		asm(	"CPSE	r31,	r12"		);
     63c:	fc 11       	cpse	r31, r12
		asm(	"STS	xRegTestError, r0"	);
     63e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	14"			);
     642:	fe e0       	ldi	r31, 0x0E	; 14
		asm(	"CPSE	r31,	r13"		);
     644:	fd 11       	cpse	r31, r13
		asm(	"STS	xRegTestError, r0"	);
     646:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	15"			);
     64a:	ff e0       	ldi	r31, 0x0F	; 15
		asm(	"CPSE	r31,	r14"		);
     64c:	fe 11       	cpse	r31, r14
		asm(	"STS	xRegTestError, r0"	);
     64e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	16"			);
     652:	f0 e1       	ldi	r31, 0x10	; 16
		asm(	"CPSE	r31,	r15"		);
     654:	ff 11       	cpse	r31, r15
		asm(	"STS	xRegTestError, r0"	);
     656:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	17"			);
     65a:	f1 e1       	ldi	r31, 0x11	; 17
		asm(	"CPSE	r31,	r16"		);
     65c:	f0 13       	cpse	r31, r16
		asm(	"STS	xRegTestError, r0"	);
     65e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	18"			);
     662:	f2 e1       	ldi	r31, 0x12	; 18
		asm(	"CPSE	r31,	r17"		);
     664:	f1 13       	cpse	r31, r17
		asm(	"STS	xRegTestError, r0"	);
     666:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	19"			);
     66a:	f3 e1       	ldi	r31, 0x13	; 19
		asm(	"CPSE	r31,	r18"		);
     66c:	f2 13       	cpse	r31, r18
		asm(	"STS	xRegTestError, r0"	);
     66e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	20"			);
     672:	f4 e1       	ldi	r31, 0x14	; 20
		asm(	"CPSE	r31,	r19"		);
     674:	f3 13       	cpse	r31, r19
		asm(	"STS	xRegTestError, r0"	);
     676:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	21"			);
     67a:	f5 e1       	ldi	r31, 0x15	; 21
		asm(	"CPSE	r31,	r20"		);
     67c:	f4 13       	cpse	r31, r20
		asm(	"STS	xRegTestError, r0"	);
     67e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	22"			);
     682:	f6 e1       	ldi	r31, 0x16	; 22
		asm(	"CPSE	r31,	r21"		);
     684:	f5 13       	cpse	r31, r21
		asm(	"STS	xRegTestError, r0"	);
     686:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	23"			);
     68a:	f7 e1       	ldi	r31, 0x17	; 23
		asm(	"CPSE	r31,	r22"		);
     68c:	f6 13       	cpse	r31, r22
		asm(	"STS	xRegTestError, r0"	);
     68e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	24"			);
     692:	f8 e1       	ldi	r31, 0x18	; 24
		asm(	"CPSE	r31,	r23"		);
     694:	f7 13       	cpse	r31, r23
		asm(	"STS	xRegTestError, r0"	);
     696:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	25"			);
     69a:	f9 e1       	ldi	r31, 0x19	; 25
		asm(	"CPSE	r31,	r24"		);
     69c:	f8 13       	cpse	r31, r24
		asm(	"STS	xRegTestError, r0"	);
     69e:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	26"			);
     6a2:	fa e1       	ldi	r31, 0x1A	; 26
		asm(	"CPSE	r31,	r25"		);
     6a4:	f9 13       	cpse	r31, r25
		asm(	"STS	xRegTestError, r0"	);
     6a6:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	27"			);
     6aa:	fb e1       	ldi	r31, 0x1B	; 27
		asm(	"CPSE	r31,	r26"		);
     6ac:	fa 13       	cpse	r31, r26
		asm(	"STS	xRegTestError, r0"	);
     6ae:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	28"			);
     6b2:	fc e1       	ldi	r31, 0x1C	; 28
		asm(	"CPSE	r31,	r27"		);
     6b4:	fb 13       	cpse	r31, r27
		asm(	"STS	xRegTestError, r0"	);
     6b6:	00 92 b7 00 	sts	0x00B7, r0
		asm(	"LDI	r31,	29"			);
     6ba:	fd e1       	ldi	r31, 0x1D	; 29
		asm(	"CPSE	r31,	r30"		);
     6bc:	fe 13       	cpse	r31, r30
		asm(	"STS	xRegTestError, r0"	);
     6be:	00 92 b7 00 	sts	0x00B7, r0
     6c2:	5e cf       	rjmp	.-324    	; 0x580 <prvRegisterCheck2>

000006c4 <vStartRegTestTasks>:
portBASE_TYPE xRegTestError = pdFALSE;

/*-----------------------------------------------------------*/

void vStartRegTestTasks( void )
{
     6c4:	af 92       	push	r10
     6c6:	bf 92       	push	r11
     6c8:	cf 92       	push	r12
     6ca:	df 92       	push	r13
     6cc:	ef 92       	push	r14
     6ce:	ff 92       	push	r15
     6d0:	0f 93       	push	r16
	xTaskCreate( prvRegisterCheck1, ( signed char * ) "Reg1", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );
     6d2:	8e e1       	ldi	r24, 0x1E	; 30
     6d4:	92 e0       	ldi	r25, 0x02	; 2
     6d6:	6b e6       	ldi	r22, 0x6B	; 107
     6d8:	70 e0       	ldi	r23, 0x00	; 0
     6da:	45 e5       	ldi	r20, 0x55	; 85
     6dc:	50 e0       	ldi	r21, 0x00	; 0
     6de:	20 e0       	ldi	r18, 0x00	; 0
     6e0:	30 e0       	ldi	r19, 0x00	; 0
     6e2:	00 e0       	ldi	r16, 0x00	; 0
     6e4:	ee 24       	eor	r14, r14
     6e6:	ff 24       	eor	r15, r15
     6e8:	cc 24       	eor	r12, r12
     6ea:	dd 24       	eor	r13, r13
     6ec:	aa 24       	eor	r10, r10
     6ee:	bb 24       	eor	r11, r11
     6f0:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>
	xTaskCreate( prvRegisterCheck2, ( signed char * ) "Reg2", configMINIMAL_STACK_SIZE, NULL, tskIDLE_PRIORITY, NULL );		
     6f4:	80 ec       	ldi	r24, 0xC0	; 192
     6f6:	92 e0       	ldi	r25, 0x02	; 2
     6f8:	60 e7       	ldi	r22, 0x70	; 112
     6fa:	70 e0       	ldi	r23, 0x00	; 0
     6fc:	45 e5       	ldi	r20, 0x55	; 85
     6fe:	50 e0       	ldi	r21, 0x00	; 0
     700:	20 e0       	ldi	r18, 0x00	; 0
     702:	30 e0       	ldi	r19, 0x00	; 0
     704:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>
}
     708:	0f 91       	pop	r16
     70a:	ff 90       	pop	r15
     70c:	ef 90       	pop	r14
     70e:	df 90       	pop	r13
     710:	cf 90       	pop	r12
     712:	bf 90       	pop	r11
     714:	af 90       	pop	r10
     716:	08 95       	ret

00000718 <vTaskSuspendAll>:

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     718:	80 91 be 00 	lds	r24, 0x00BE
     71c:	8f 5f       	subi	r24, 0xFF	; 255
     71e:	80 93 be 00 	sts	0x00BE, r24
}
     722:	08 95       	ret

00000724 <xTaskGetTickCount>:
portTickType xTaskGetTickCount( void )
{
portTickType xTicks;

	/* Critical section required if running on a 16 bit processor. */
	taskENTER_CRITICAL();
     724:	0f b6       	in	r0, 0x3f	; 63
     726:	f8 94       	cli
     728:	0f 92       	push	r0
	{
		xTicks = xTickCount;
     72a:	20 91 bc 00 	lds	r18, 0x00BC
     72e:	30 91 bd 00 	lds	r19, 0x00BD
	}
	taskEXIT_CRITICAL();
     732:	0f 90       	pop	r0
     734:	0f be       	out	0x3f, r0	; 63

	return xTicks;
}
     736:	c9 01       	movw	r24, r18
     738:	08 95       	ret

0000073a <xTaskGetTickCountFromISR>:
{
portTickType xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	xReturn = xTickCount;
     73a:	20 91 bc 00 	lds	r18, 0x00BC
     73e:	30 91 bd 00 	lds	r19, 0x00BD
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
     742:	c9 01       	movw	r24, r18
     744:	08 95       	ret

00000746 <uxTaskGetNumberOfTasks>:

unsigned portBASE_TYPE uxTaskGetNumberOfTasks( void )
{
	/* A critical section is not required because the variables are of type
	portBASE_TYPE. */
	return uxCurrentNumberOfTasks;
     746:	80 91 c1 00 	lds	r24, 0x00C1
}
     74a:	08 95       	ret

0000074c <vTaskSwitchContext>:
#endif /* configUSE_APPLICATION_TASK_TAG */
/*-----------------------------------------------------------*/

void vTaskSwitchContext( void )
{
	if( uxSchedulerSuspended != ( unsigned portBASE_TYPE ) pdFALSE )
     74c:	80 91 be 00 	lds	r24, 0x00BE
     750:	88 23       	and	r24, r24
     752:	51 f0       	breq	.+20     	; 0x768 <vTaskSwitchContext+0x1c>
	{
		/* The scheduler is currently suspended - do not allow a context
		switch. */
		xMissedYield = pdTRUE;
     754:	81 e0       	ldi	r24, 0x01	; 1
     756:	80 93 ba 00 	sts	0x00BA, r24
     75a:	08 95       	ret
		#endif /* configGENERATE_RUN_TIME_STATS */

		taskFIRST_CHECK_FOR_STACK_OVERFLOW();
		taskSECOND_CHECK_FOR_STACK_OVERFLOW();

		taskSELECT_HIGHEST_PRIORITY_TASK();
     75c:	80 91 bf 00 	lds	r24, 0x00BF
     760:	81 50       	subi	r24, 0x01	; 1
     762:	80 93 bf 00 	sts	0x00BF, r24
     766:	01 c0       	rjmp	.+2      	; 0x76a <vTaskSwitchContext+0x1e>
     768:	99 e0       	ldi	r25, 0x09	; 9
     76a:	e0 91 bf 00 	lds	r30, 0x00BF
     76e:	e9 9f       	mul	r30, r25
     770:	f0 01       	movw	r30, r0
     772:	11 24       	eor	r1, r1
     774:	ea 53       	subi	r30, 0x3A	; 58
     776:	ff 4f       	sbci	r31, 0xFF	; 255
     778:	80 81       	ld	r24, Z
     77a:	88 23       	and	r24, r24
     77c:	79 f3       	breq	.-34     	; 0x75c <vTaskSwitchContext+0x10>
     77e:	90 91 bf 00 	lds	r25, 0x00BF
     782:	89 e0       	ldi	r24, 0x09	; 9
     784:	98 9f       	mul	r25, r24
     786:	d0 01       	movw	r26, r0
     788:	11 24       	eor	r1, r1
     78a:	aa 53       	subi	r26, 0x3A	; 58
     78c:	bf 4f       	sbci	r27, 0xFF	; 255
     78e:	11 96       	adiw	r26, 0x01	; 1
     790:	ed 91       	ld	r30, X+
     792:	fc 91       	ld	r31, X
     794:	12 97       	sbiw	r26, 0x02	; 2
     796:	02 80       	ldd	r0, Z+2	; 0x02
     798:	f3 81       	ldd	r31, Z+3	; 0x03
     79a:	e0 2d       	mov	r30, r0
     79c:	12 96       	adiw	r26, 0x02	; 2
     79e:	fc 93       	st	X, r31
     7a0:	ee 93       	st	-X, r30
     7a2:	11 97       	sbiw	r26, 0x01	; 1
     7a4:	cd 01       	movw	r24, r26
     7a6:	03 96       	adiw	r24, 0x03	; 3
     7a8:	e8 17       	cp	r30, r24
     7aa:	f9 07       	cpc	r31, r25
     7ac:	31 f4       	brne	.+12     	; 0x7ba <vTaskSwitchContext+0x6e>
     7ae:	82 81       	ldd	r24, Z+2	; 0x02
     7b0:	93 81       	ldd	r25, Z+3	; 0x03
     7b2:	12 96       	adiw	r26, 0x02	; 2
     7b4:	9c 93       	st	X, r25
     7b6:	8e 93       	st	-X, r24
     7b8:	11 97       	sbiw	r26, 0x01	; 1
     7ba:	11 96       	adiw	r26, 0x01	; 1
     7bc:	ed 91       	ld	r30, X+
     7be:	fc 91       	ld	r31, X
     7c0:	12 97       	sbiw	r26, 0x02	; 2
     7c2:	86 81       	ldd	r24, Z+6	; 0x06
     7c4:	97 81       	ldd	r25, Z+7	; 0x07
     7c6:	90 93 b9 00 	sts	0x00B9, r25
     7ca:	80 93 b8 00 	sts	0x00B8, r24
     7ce:	08 95       	ret

000007d0 <vTaskSetTimeOutState>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
     7d0:	fc 01       	movw	r30, r24
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     7d2:	80 91 bb 00 	lds	r24, 0x00BB
     7d6:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     7d8:	80 91 bc 00 	lds	r24, 0x00BC
     7dc:	90 91 bd 00 	lds	r25, 0x00BD
     7e0:	92 83       	std	Z+2, r25	; 0x02
     7e2:	81 83       	std	Z+1, r24	; 0x01
}
     7e4:	08 95       	ret

000007e6 <xTaskCheckForTimeOut>:
/*-----------------------------------------------------------*/

portBASE_TYPE xTaskCheckForTimeOut( xTimeOutType * const pxTimeOut, portTickType * const pxTicksToWait )
{
     7e6:	fc 01       	movw	r30, r24
     7e8:	db 01       	movw	r26, r22
portBASE_TYPE xReturn;

	configASSERT( pxTimeOut );
	configASSERT( pxTicksToWait );

	taskENTER_CRITICAL();
     7ea:	0f b6       	in	r0, 0x3f	; 63
     7ec:	f8 94       	cli
     7ee:	0f 92       	push	r0
				xReturn = pdFALSE;
			}
			else /* We are not blocking indefinitely, perform the checks below. */
		#endif

		if( ( xNumOfOverflows != pxTimeOut->xOverflowCount ) && ( ( portTickType ) xTickCount >= ( portTickType ) pxTimeOut->xTimeOnEntering ) )
     7f0:	90 91 bb 00 	lds	r25, 0x00BB
     7f4:	80 81       	ld	r24, Z
     7f6:	98 17       	cp	r25, r24
     7f8:	49 f0       	breq	.+18     	; 0x80c <xTaskCheckForTimeOut+0x26>
     7fa:	20 91 bc 00 	lds	r18, 0x00BC
     7fe:	30 91 bd 00 	lds	r19, 0x00BD
     802:	81 81       	ldd	r24, Z+1	; 0x01
     804:	92 81       	ldd	r25, Z+2	; 0x02
     806:	28 17       	cp	r18, r24
     808:	39 07       	cpc	r19, r25
     80a:	18 f5       	brcc	.+70     	; 0x852 <xTaskCheckForTimeOut+0x6c>
			was called, but has also overflowed since vTaskSetTimeOut() was called.
			It must have wrapped all the way around and gone past us again. This
			passed since vTaskSetTimeout() was called. */
			xReturn = pdTRUE;
		}
		else if( ( ( portTickType ) ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering ) ) < ( portTickType ) *pxTicksToWait )
     80c:	80 91 bc 00 	lds	r24, 0x00BC
     810:	90 91 bd 00 	lds	r25, 0x00BD
     814:	21 81       	ldd	r18, Z+1	; 0x01
     816:	32 81       	ldd	r19, Z+2	; 0x02
     818:	4d 91       	ld	r20, X+
     81a:	5c 91       	ld	r21, X
     81c:	11 97       	sbiw	r26, 0x01	; 1
     81e:	82 1b       	sub	r24, r18
     820:	93 0b       	sbc	r25, r19
     822:	84 17       	cp	r24, r20
     824:	95 07       	cpc	r25, r21
     826:	a8 f4       	brcc	.+42     	; 0x852 <xTaskCheckForTimeOut+0x6c>
		{
			/* Not a genuine timeout. Adjust parameters for time remaining. */
			*pxTicksToWait -= ( ( portTickType ) xTickCount - ( portTickType ) pxTimeOut->xTimeOnEntering );
     828:	80 91 bc 00 	lds	r24, 0x00BC
     82c:	90 91 bd 00 	lds	r25, 0x00BD
     830:	28 1b       	sub	r18, r24
     832:	39 0b       	sbc	r19, r25
     834:	24 0f       	add	r18, r20
     836:	35 1f       	adc	r19, r21
     838:	2d 93       	st	X+, r18
     83a:	3c 93       	st	X, r19
/*-----------------------------------------------------------*/

void vTaskSetTimeOutState( xTimeOutType * const pxTimeOut )
{
	configASSERT( pxTimeOut );
	pxTimeOut->xOverflowCount = xNumOfOverflows;
     83c:	80 91 bb 00 	lds	r24, 0x00BB
     840:	80 83       	st	Z, r24
	pxTimeOut->xTimeOnEntering = xTickCount;
     842:	80 91 bc 00 	lds	r24, 0x00BC
     846:	90 91 bd 00 	lds	r25, 0x00BD
     84a:	92 83       	std	Z+2, r25	; 0x02
     84c:	81 83       	std	Z+1, r24	; 0x01
     84e:	80 e0       	ldi	r24, 0x00	; 0
     850:	01 c0       	rjmp	.+2      	; 0x854 <xTaskCheckForTimeOut+0x6e>
     852:	81 e0       	ldi	r24, 0x01	; 1
		else
		{
			xReturn = pdTRUE;
		}
	}
	taskEXIT_CRITICAL();
     854:	0f 90       	pop	r0
     856:	0f be       	out	0x3f, r0	; 63

	return xReturn;
}
     858:	08 95       	ret

0000085a <vTaskMissedYield>:
/*-----------------------------------------------------------*/

void vTaskMissedYield( void )
{
	xMissedYield = pdTRUE;
     85a:	81 e0       	ldi	r24, 0x01	; 1
     85c:	80 93 ba 00 	sts	0x00BA, r24
}
     860:	08 95       	ret

00000862 <xTaskRemoveFromEventList>:

#endif /* configUSE_TIMERS */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xTaskRemoveFromEventList( const xList * const pxEventList )
{
     862:	0f 93       	push	r16
     864:	1f 93       	push	r17
     866:	cf 93       	push	r28
     868:	df 93       	push	r29
     86a:	fc 01       	movw	r30, r24
	get called - the lock count on the queue will get modified instead.  This
	means we can always expect exclusive access to the event list here.

	This function assumes that a check has already been made to ensure that
	pxEventList is not empty. */
	pxUnblockedTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
     86c:	05 80       	ldd	r0, Z+5	; 0x05
     86e:	f6 81       	ldd	r31, Z+6	; 0x06
     870:	e0 2d       	mov	r30, r0
     872:	06 81       	ldd	r16, Z+6	; 0x06
     874:	17 81       	ldd	r17, Z+7	; 0x07
	configASSERT( pxUnblockedTCB );
	uxListRemove( &( pxUnblockedTCB->xEventListItem ) );
     876:	e8 01       	movw	r28, r16
     878:	2c 96       	adiw	r28, 0x0c	; 12
     87a:	ce 01       	movw	r24, r28
     87c:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>

	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     880:	80 91 be 00 	lds	r24, 0x00BE
     884:	88 23       	and	r24, r24
     886:	a9 f4       	brne	.+42     	; 0x8b2 <xTaskRemoveFromEventList+0x50>
	{
		uxListRemove( &( pxUnblockedTCB->xGenericListItem ) );
     888:	e8 01       	movw	r28, r16
     88a:	22 96       	adiw	r28, 0x02	; 2
     88c:	ce 01       	movw	r24, r28
     88e:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
		prvAddTaskToReadyQueue( pxUnblockedTCB );
     892:	d8 01       	movw	r26, r16
     894:	56 96       	adiw	r26, 0x16	; 22
     896:	9c 91       	ld	r25, X
     898:	80 91 bf 00 	lds	r24, 0x00BF
     89c:	89 17       	cp	r24, r25
     89e:	10 f4       	brcc	.+4      	; 0x8a4 <xTaskRemoveFromEventList+0x42>
     8a0:	90 93 bf 00 	sts	0x00BF, r25
     8a4:	89 e0       	ldi	r24, 0x09	; 9
     8a6:	98 9f       	mul	r25, r24
     8a8:	c0 01       	movw	r24, r0
     8aa:	11 24       	eor	r1, r1
     8ac:	8a 53       	subi	r24, 0x3A	; 58
     8ae:	9f 4f       	sbci	r25, 0xFF	; 255
     8b0:	02 c0       	rjmp	.+4      	; 0x8b6 <xTaskRemoveFromEventList+0x54>
	}
	else
	{
		/* We cannot access the delayed or ready lists, so will hold this
		task pending until the scheduler is resumed. */
		vListInsertEnd( ( xList * ) &( xPendingReadyList ), &( pxUnblockedTCB->xEventListItem ) );
     8b2:	80 e0       	ldi	r24, 0x00	; 0
     8b4:	91 e0       	ldi	r25, 0x01	; 1
     8b6:	be 01       	movw	r22, r28
     8b8:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>
	}

	if( pxUnblockedTCB->uxPriority >= pxCurrentTCB->uxPriority )
     8bc:	e0 91 b8 00 	lds	r30, 0x00B8
     8c0:	f0 91 b9 00 	lds	r31, 0x00B9
     8c4:	20 e0       	ldi	r18, 0x00	; 0
     8c6:	d8 01       	movw	r26, r16
     8c8:	56 96       	adiw	r26, 0x16	; 22
     8ca:	9c 91       	ld	r25, X
     8cc:	86 89       	ldd	r24, Z+22	; 0x16
     8ce:	98 17       	cp	r25, r24
     8d0:	08 f0       	brcs	.+2      	; 0x8d4 <xTaskRemoveFromEventList+0x72>
     8d2:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
     8d4:	82 2f       	mov	r24, r18
     8d6:	df 91       	pop	r29
     8d8:	cf 91       	pop	r28
     8da:	1f 91       	pop	r17
     8dc:	0f 91       	pop	r16
     8de:	08 95       	ret

000008e0 <vTaskIncrementTick>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

void vTaskIncrementTick( void )
{
     8e0:	ff 92       	push	r15
     8e2:	0f 93       	push	r16
     8e4:	1f 93       	push	r17
     8e6:	cf 93       	push	r28
     8e8:	df 93       	push	r29

	/* Called by the portable layer each time a tick interrupt occurs.
	Increments the tick then checks to see if the new tick value will cause any
	tasks to be unblocked. */
	traceTASK_INCREMENT_TICK( xTickCount );
	if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     8ea:	80 91 be 00 	lds	r24, 0x00BE
     8ee:	88 23       	and	r24, r24
     8f0:	09 f0       	breq	.+2      	; 0x8f4 <vTaskIncrementTick+0x14>
     8f2:	8f c0       	rjmp	.+286    	; 0xa12 <vTaskIncrementTick+0x132>
	{
		++xTickCount;
     8f4:	80 91 bc 00 	lds	r24, 0x00BC
     8f8:	90 91 bd 00 	lds	r25, 0x00BD
     8fc:	01 96       	adiw	r24, 0x01	; 1
     8fe:	90 93 bd 00 	sts	0x00BD, r25
     902:	80 93 bc 00 	sts	0x00BC, r24
		if( xTickCount == ( portTickType ) 0U )
     906:	80 91 bc 00 	lds	r24, 0x00BC
     90a:	90 91 bd 00 	lds	r25, 0x00BD
     90e:	89 2b       	or	r24, r25
     910:	79 f5       	brne	.+94     	; 0x970 <vTaskIncrementTick+0x90>
			/* Tick count has overflowed so we need to swap the delay lists.
			If there are any items in pxDelayedTaskList here then there is
			an error! */
			configASSERT( ( listLIST_IS_EMPTY( pxDelayedTaskList ) ) );

			pxTemp = pxDelayedTaskList;
     912:	20 91 fc 00 	lds	r18, 0x00FC
     916:	30 91 fd 00 	lds	r19, 0x00FD
			pxDelayedTaskList = pxOverflowDelayedTaskList;
     91a:	80 91 fe 00 	lds	r24, 0x00FE
     91e:	90 91 ff 00 	lds	r25, 0x00FF
     922:	90 93 fd 00 	sts	0x00FD, r25
     926:	80 93 fc 00 	sts	0x00FC, r24
			pxOverflowDelayedTaskList = pxTemp;
     92a:	30 93 ff 00 	sts	0x00FF, r19
     92e:	20 93 fe 00 	sts	0x00FE, r18
			xNumOfOverflows++;
     932:	80 91 bb 00 	lds	r24, 0x00BB
     936:	8f 5f       	subi	r24, 0xFF	; 255
     938:	80 93 bb 00 	sts	0x00BB, r24

			if( listLIST_IS_EMPTY( pxDelayedTaskList ) != pdFALSE )
     93c:	e0 91 fc 00 	lds	r30, 0x00FC
     940:	f0 91 fd 00 	lds	r31, 0x00FD
     944:	80 81       	ld	r24, Z
     946:	88 23       	and	r24, r24
     948:	19 f4       	brne	.+6      	; 0x950 <vTaskIncrementTick+0x70>
				/* The new current delayed list is empty.  Set
				xNextTaskUnblockTime to the maximum possible value so it is
				extremely unlikely that the
				if( xTickCount >= xNextTaskUnblockTime ) test will pass until
				there is an item in the delayed list. */
				xNextTaskUnblockTime = portMAX_DELAY;
     94a:	8f ef       	ldi	r24, 0xFF	; 255
     94c:	9f ef       	ldi	r25, 0xFF	; 255
     94e:	0c c0       	rjmp	.+24     	; 0x968 <vTaskIncrementTick+0x88>
			{
				/* The new current delayed list is not empty, get the value of
				the item at the head of the delayed list.  This is the time at
				which the task at the head of the delayed list should be removed
				from the Blocked state. */
				pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedTaskList );
     950:	e0 91 fc 00 	lds	r30, 0x00FC
     954:	f0 91 fd 00 	lds	r31, 0x00FD
     958:	05 80       	ldd	r0, Z+5	; 0x05
     95a:	f6 81       	ldd	r31, Z+6	; 0x06
     95c:	e0 2d       	mov	r30, r0
     95e:	06 80       	ldd	r0, Z+6	; 0x06
     960:	f7 81       	ldd	r31, Z+7	; 0x07
     962:	e0 2d       	mov	r30, r0
				xNextTaskUnblockTime = listGET_LIST_ITEM_VALUE( &( pxTCB->xGenericListItem ) );
     964:	82 81       	ldd	r24, Z+2	; 0x02
     966:	93 81       	ldd	r25, Z+3	; 0x03
     968:	90 93 7b 00 	sts	0x007B, r25
     96c:	80 93 7a 00 	sts	0x007A, r24
			}
		}

		/* See if this tick has made a timeout expire. */
		prvCheckDelayedTasks();
     970:	20 91 bc 00 	lds	r18, 0x00BC
     974:	30 91 bd 00 	lds	r19, 0x00BD
     978:	80 91 7a 00 	lds	r24, 0x007A
     97c:	90 91 7b 00 	lds	r25, 0x007B
     980:	28 17       	cp	r18, r24
     982:	39 07       	cpc	r19, r25
     984:	08 f4       	brcc	.+2      	; 0x988 <vTaskIncrementTick+0xa8>
     986:	4a c0       	rjmp	.+148    	; 0xa1c <vTaskIncrementTick+0x13c>
     988:	89 e0       	ldi	r24, 0x09	; 9
     98a:	f8 2e       	mov	r15, r24
     98c:	e0 91 fc 00 	lds	r30, 0x00FC
     990:	f0 91 fd 00 	lds	r31, 0x00FD
     994:	80 81       	ld	r24, Z
     996:	88 23       	and	r24, r24
     998:	39 f4       	brne	.+14     	; 0x9a8 <vTaskIncrementTick+0xc8>
     99a:	8f ef       	ldi	r24, 0xFF	; 255
     99c:	9f ef       	ldi	r25, 0xFF	; 255
     99e:	90 93 7b 00 	sts	0x007B, r25
     9a2:	80 93 7a 00 	sts	0x007A, r24
     9a6:	3a c0       	rjmp	.+116    	; 0xa1c <vTaskIncrementTick+0x13c>
     9a8:	e0 91 fc 00 	lds	r30, 0x00FC
     9ac:	f0 91 fd 00 	lds	r31, 0x00FD
     9b0:	05 80       	ldd	r0, Z+5	; 0x05
     9b2:	f6 81       	ldd	r31, Z+6	; 0x06
     9b4:	e0 2d       	mov	r30, r0
     9b6:	c6 81       	ldd	r28, Z+6	; 0x06
     9b8:	d7 81       	ldd	r29, Z+7	; 0x07
     9ba:	2a 81       	ldd	r18, Y+2	; 0x02
     9bc:	3b 81       	ldd	r19, Y+3	; 0x03
     9be:	80 91 bc 00 	lds	r24, 0x00BC
     9c2:	90 91 bd 00 	lds	r25, 0x00BD
     9c6:	82 17       	cp	r24, r18
     9c8:	93 07       	cpc	r25, r19
     9ca:	28 f4       	brcc	.+10     	; 0x9d6 <vTaskIncrementTick+0xf6>
     9cc:	30 93 7b 00 	sts	0x007B, r19
     9d0:	20 93 7a 00 	sts	0x007A, r18
     9d4:	23 c0       	rjmp	.+70     	; 0xa1c <vTaskIncrementTick+0x13c>
     9d6:	8e 01       	movw	r16, r28
     9d8:	0e 5f       	subi	r16, 0xFE	; 254
     9da:	1f 4f       	sbci	r17, 0xFF	; 255
     9dc:	c8 01       	movw	r24, r16
     9de:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
     9e2:	8c 89       	ldd	r24, Y+20	; 0x14
     9e4:	9d 89       	ldd	r25, Y+21	; 0x15
     9e6:	89 2b       	or	r24, r25
     9e8:	21 f0       	breq	.+8      	; 0x9f2 <vTaskIncrementTick+0x112>
     9ea:	ce 01       	movw	r24, r28
     9ec:	0c 96       	adiw	r24, 0x0c	; 12
     9ee:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
     9f2:	9e 89       	ldd	r25, Y+22	; 0x16
     9f4:	80 91 bf 00 	lds	r24, 0x00BF
     9f8:	89 17       	cp	r24, r25
     9fa:	10 f4       	brcc	.+4      	; 0xa00 <vTaskIncrementTick+0x120>
     9fc:	90 93 bf 00 	sts	0x00BF, r25
     a00:	9f 9d       	mul	r25, r15
     a02:	c0 01       	movw	r24, r0
     a04:	11 24       	eor	r1, r1
     a06:	8a 53       	subi	r24, 0x3A	; 58
     a08:	9f 4f       	sbci	r25, 0xFF	; 255
     a0a:	b8 01       	movw	r22, r16
     a0c:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>
     a10:	bd cf       	rjmp	.-134    	; 0x98c <vTaskIncrementTick+0xac>
	}
	else
	{
		++uxMissedTicks;
     a12:	80 91 c0 00 	lds	r24, 0x00C0
     a16:	8f 5f       	subi	r24, 0xFF	; 255
     a18:	80 93 c0 00 	sts	0x00C0, r24
		{
			vApplicationTickHook();
		}
	}
	#endif /* configUSE_TICK_HOOK */
}
     a1c:	df 91       	pop	r29
     a1e:	cf 91       	pop	r28
     a20:	1f 91       	pop	r17
     a22:	0f 91       	pop	r16
     a24:	ff 90       	pop	r15
     a26:	08 95       	ret

00000a28 <prvAddCurrentTaskToDelayedList>:
	#endif /* vTaskDelete */
}
/*-----------------------------------------------------------*/

static void prvAddCurrentTaskToDelayedList( portTickType xTimeToWake )
{
     a28:	cf 93       	push	r28
     a2a:	df 93       	push	r29
     a2c:	ec 01       	movw	r28, r24
	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentTCB->xGenericListItem ), xTimeToWake );
     a2e:	e0 91 b8 00 	lds	r30, 0x00B8
     a32:	f0 91 b9 00 	lds	r31, 0x00B9
     a36:	93 83       	std	Z+3, r25	; 0x03
     a38:	82 83       	std	Z+2, r24	; 0x02

	if( xTimeToWake < xTickCount )
     a3a:	80 91 bc 00 	lds	r24, 0x00BC
     a3e:	90 91 bd 00 	lds	r25, 0x00BD
     a42:	c8 17       	cp	r28, r24
     a44:	d9 07       	cpc	r29, r25
     a46:	68 f4       	brcc	.+26     	; 0xa62 <prvAddCurrentTaskToDelayedList+0x3a>
	{
		/* Wake time has overflowed.  Place this item in the overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     a48:	80 91 fe 00 	lds	r24, 0x00FE
     a4c:	90 91 ff 00 	lds	r25, 0x00FF
     a50:	60 91 b8 00 	lds	r22, 0x00B8
     a54:	70 91 b9 00 	lds	r23, 0x00B9
     a58:	6e 5f       	subi	r22, 0xFE	; 254
     a5a:	7f 4f       	sbci	r23, 0xFF	; 255
     a5c:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInsert>
     a60:	17 c0       	rjmp	.+46     	; 0xa90 <prvAddCurrentTaskToDelayedList+0x68>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the current block list. */
		vListInsert( ( xList * ) pxDelayedTaskList, ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) );
     a62:	80 91 fc 00 	lds	r24, 0x00FC
     a66:	90 91 fd 00 	lds	r25, 0x00FD
     a6a:	60 91 b8 00 	lds	r22, 0x00B8
     a6e:	70 91 b9 00 	lds	r23, 0x00B9
     a72:	6e 5f       	subi	r22, 0xFE	; 254
     a74:	7f 4f       	sbci	r23, 0xFF	; 255
     a76:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInsert>

		/* If the task entering the blocked state was placed at the head of the
		list of blocked tasks then xNextTaskUnblockTime needs to be updated
		too. */
		if( xTimeToWake < xNextTaskUnblockTime )
     a7a:	80 91 7a 00 	lds	r24, 0x007A
     a7e:	90 91 7b 00 	lds	r25, 0x007B
     a82:	c8 17       	cp	r28, r24
     a84:	d9 07       	cpc	r29, r25
     a86:	20 f4       	brcc	.+8      	; 0xa90 <prvAddCurrentTaskToDelayedList+0x68>
		{
			xNextTaskUnblockTime = xTimeToWake;
     a88:	d0 93 7b 00 	sts	0x007B, r29
     a8c:	c0 93 7a 00 	sts	0x007A, r28
		}
	}
}
     a90:	df 91       	pop	r29
     a92:	cf 91       	pop	r28
     a94:	08 95       	ret

00000a96 <vTaskPlaceOnEventList>:
	}
}
/*-----------------------------------------------------------*/

void vTaskPlaceOnEventList( const xList * const pxEventList, portTickType xTicksToWait )
{
     a96:	0f 93       	push	r16
     a98:	1f 93       	push	r17
     a9a:	8b 01       	movw	r16, r22
	SCHEDULER SUSPENDED. */

	/* Place the event list item of the TCB in the appropriate event list.
	This is placed in the list in priority order so the highest priority task
	is the first to be woken by the event. */
	vListInsert( ( xList * ) pxEventList, ( xListItem * ) &( pxCurrentTCB->xEventListItem ) );
     a9c:	60 91 b8 00 	lds	r22, 0x00B8
     aa0:	70 91 b9 00 	lds	r23, 0x00B9
     aa4:	64 5f       	subi	r22, 0xF4	; 244
     aa6:	7f 4f       	sbci	r23, 0xFF	; 255
     aa8:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInsert>

	/* We must remove ourselves from the ready list before adding ourselves
	to the blocked list as the same list item is used for both lists.  We have
	exclusive access to the ready lists as the scheduler is locked. */
	if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     aac:	80 91 b8 00 	lds	r24, 0x00B8
     ab0:	90 91 b9 00 	lds	r25, 0x00B9
     ab4:	02 96       	adiw	r24, 0x02	; 2
     ab6:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
	}
	#else /* INCLUDE_vTaskSuspend */
	{
			/* Calculate the time at which the task should be woken if the event does
			not occur.  This may overflow but this doesn't matter. */
			xTimeToWake = xTickCount + xTicksToWait;
     aba:	80 91 bc 00 	lds	r24, 0x00BC
     abe:	90 91 bd 00 	lds	r25, 0x00BD
			prvAddCurrentTaskToDelayedList( xTimeToWake );
     ac2:	80 0f       	add	r24, r16
     ac4:	91 1f       	adc	r25, r17
     ac6:	0e 94 14 05 	call	0xa28	; 0xa28 <prvAddCurrentTaskToDelayedList>
	}
	#endif /* INCLUDE_vTaskSuspend */
}
     aca:	1f 91       	pop	r17
     acc:	0f 91       	pop	r16
     ace:	08 95       	ret

00000ad0 <xTaskResumeAll>:

#endif /* configUSE_TICKLESS_IDLE */
/*----------------------------------------------------------*/

signed portBASE_TYPE xTaskResumeAll( void )
{
     ad0:	cf 92       	push	r12
     ad2:	df 92       	push	r13
     ad4:	ff 92       	push	r15
     ad6:	0f 93       	push	r16
     ad8:	1f 93       	push	r17
     ada:	df 93       	push	r29
     adc:	cf 93       	push	r28
     ade:	0f 92       	push	r0
     ae0:	cd b7       	in	r28, 0x3d	; 61
     ae2:	de b7       	in	r29, 0x3e	; 62
	/* It is possible that an ISR caused a task to be removed from an event
	list while the scheduler was suspended.  If this was the case then the
	removed task will have been added to the xPendingReadyList.  Once the
	scheduler has been resumed it is safe to move all the pending ready
	tasks from this list into their appropriate ready list. */
	taskENTER_CRITICAL();
     ae4:	0f b6       	in	r0, 0x3f	; 63
     ae6:	f8 94       	cli
     ae8:	0f 92       	push	r0
	{
		--uxSchedulerSuspended;
     aea:	80 91 be 00 	lds	r24, 0x00BE
     aee:	81 50       	subi	r24, 0x01	; 1
     af0:	80 93 be 00 	sts	0x00BE, r24

		if( uxSchedulerSuspended == ( unsigned portBASE_TYPE ) pdFALSE )
     af4:	80 91 be 00 	lds	r24, 0x00BE
     af8:	88 23       	and	r24, r24
     afa:	09 f0       	breq	.+2      	; 0xafe <xTaskResumeAll+0x2e>
     afc:	58 c0       	rjmp	.+176    	; 0xbae <xTaskResumeAll+0xde>
		{
			if( uxCurrentNumberOfTasks > ( unsigned portBASE_TYPE ) 0U )
     afe:	80 91 c1 00 	lds	r24, 0x00C1
     b02:	88 23       	and	r24, r24
     b04:	09 f4       	brne	.+2      	; 0xb08 <xTaskResumeAll+0x38>
     b06:	53 c0       	rjmp	.+166    	; 0xbae <xTaskResumeAll+0xde>
     b08:	19 82       	std	Y+1, r1	; 0x01
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
					uxListRemove( &( pxTCB->xEventListItem ) );
					uxListRemove( &( pxTCB->xGenericListItem ) );
					prvAddTaskToReadyQueue( pxTCB );
     b0a:	99 e0       	ldi	r25, 0x09	; 9
     b0c:	f9 2e       	mov	r15, r25
     b0e:	2d c0       	rjmp	.+90     	; 0xb6a <xTaskResumeAll+0x9a>

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY(  ( ( xList * ) &xPendingReadyList ) );
     b10:	e0 91 05 01 	lds	r30, 0x0105
     b14:	f0 91 06 01 	lds	r31, 0x0106
     b18:	c6 80       	ldd	r12, Z+6	; 0x06
     b1a:	d7 80       	ldd	r13, Z+7	; 0x07
					uxListRemove( &( pxTCB->xEventListItem ) );
     b1c:	c6 01       	movw	r24, r12
     b1e:	0c 96       	adiw	r24, 0x0c	; 12
     b20:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
					uxListRemove( &( pxTCB->xGenericListItem ) );
     b24:	86 01       	movw	r16, r12
     b26:	0e 5f       	subi	r16, 0xFE	; 254
     b28:	1f 4f       	sbci	r17, 0xFF	; 255
     b2a:	c8 01       	movw	r24, r16
     b2c:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
					prvAddTaskToReadyQueue( pxTCB );
     b30:	d6 01       	movw	r26, r12
     b32:	56 96       	adiw	r26, 0x16	; 22
     b34:	9c 91       	ld	r25, X
     b36:	80 91 bf 00 	lds	r24, 0x00BF
     b3a:	89 17       	cp	r24, r25
     b3c:	10 f4       	brcc	.+4      	; 0xb42 <xTaskResumeAll+0x72>
     b3e:	90 93 bf 00 	sts	0x00BF, r25
     b42:	9f 9d       	mul	r25, r15
     b44:	c0 01       	movw	r24, r0
     b46:	11 24       	eor	r1, r1
     b48:	8a 53       	subi	r24, 0x3A	; 58
     b4a:	9f 4f       	sbci	r25, 0xFF	; 255
     b4c:	b8 01       	movw	r22, r16
     b4e:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>

					/* If we have moved a task that has a priority higher than
					the current task then we should yield. */
					if( pxTCB->uxPriority >= pxCurrentTCB->uxPriority )
     b52:	e0 91 b8 00 	lds	r30, 0x00B8
     b56:	f0 91 b9 00 	lds	r31, 0x00B9
     b5a:	d6 01       	movw	r26, r12
     b5c:	56 96       	adiw	r26, 0x16	; 22
     b5e:	9c 91       	ld	r25, X
     b60:	86 89       	ldd	r24, Z+22	; 0x16
     b62:	98 17       	cp	r25, r24
     b64:	10 f0       	brcs	.+4      	; 0xb6a <xTaskResumeAll+0x9a>
     b66:	b1 e0       	ldi	r27, 0x01	; 1
     b68:	b9 83       	std	Y+1, r27	; 0x01
			{
				portBASE_TYPE xYieldRequired = pdFALSE;

				/* Move any readied tasks from the pending list into the
				appropriate ready list. */
				while( listLIST_IS_EMPTY( ( xList * ) &xPendingReadyList ) == pdFALSE )
     b6a:	80 91 00 01 	lds	r24, 0x0100
     b6e:	88 23       	and	r24, r24
     b70:	79 f6       	brne	.-98     	; 0xb10 <xTaskResumeAll+0x40>
				}

				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     b72:	80 91 c0 00 	lds	r24, 0x00C0
     b76:	88 23       	and	r24, r24
     b78:	41 f4       	brne	.+16     	; 0xb8a <xTaskResumeAll+0xba>
     b7a:	0c c0       	rjmp	.+24     	; 0xb94 <xTaskResumeAll+0xc4>
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
					{
						vTaskIncrementTick();
     b7c:	0e 94 70 04 	call	0x8e0	; 0x8e0 <vTaskIncrementTick>
						--uxMissedTicks;
     b80:	80 91 c0 00 	lds	r24, 0x00C0
     b84:	81 50       	subi	r24, 0x01	; 1
     b86:	80 93 c0 00 	sts	0x00C0, r24
				/* If any ticks occurred while the scheduler was suspended then
				they should be processed now.  This ensures the tick count does not
				slip, and that any delayed tasks are resumed at the correct time. */
				if( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
				{
					while( uxMissedTicks > ( unsigned portBASE_TYPE ) 0U )
     b8a:	80 91 c0 00 	lds	r24, 0x00C0
     b8e:	88 23       	and	r24, r24
     b90:	a9 f7       	brne	.-22     	; 0xb7c <xTaskResumeAll+0xac>
     b92:	07 c0       	rjmp	.+14     	; 0xba2 <xTaskResumeAll+0xd2>
						xYieldRequired = pdTRUE;
					}
					#endif
				}

				if( ( xYieldRequired == pdTRUE ) || ( xMissedYield == pdTRUE ) )
     b94:	e9 81       	ldd	r30, Y+1	; 0x01
     b96:	e1 30       	cpi	r30, 0x01	; 1
     b98:	21 f0       	breq	.+8      	; 0xba2 <xTaskResumeAll+0xd2>
     b9a:	80 91 ba 00 	lds	r24, 0x00BA
     b9e:	81 30       	cpi	r24, 0x01	; 1
     ba0:	31 f4       	brne	.+12     	; 0xbae <xTaskResumeAll+0xde>
				{
					xAlreadyYielded = pdTRUE;
					xMissedYield = pdFALSE;
     ba2:	10 92 ba 00 	sts	0x00BA, r1
					portYIELD_WITHIN_API();
     ba6:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
     baa:	81 e0       	ldi	r24, 0x01	; 1
     bac:	01 c0       	rjmp	.+2      	; 0xbb0 <xTaskResumeAll+0xe0>
     bae:	80 e0       	ldi	r24, 0x00	; 0
				}
			}
		}
	}
	taskEXIT_CRITICAL();
     bb0:	0f 90       	pop	r0
     bb2:	0f be       	out	0x3f, r0	; 63

	return xAlreadyYielded;
}
     bb4:	0f 90       	pop	r0
     bb6:	cf 91       	pop	r28
     bb8:	df 91       	pop	r29
     bba:	1f 91       	pop	r17
     bbc:	0f 91       	pop	r16
     bbe:	ff 90       	pop	r15
     bc0:	df 90       	pop	r13
     bc2:	cf 90       	pop	r12
     bc4:	08 95       	ret

00000bc6 <vTaskDelay>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelay == 1 )

	void vTaskDelay( portTickType xTicksToDelay )
	{
     bc6:	0f 93       	push	r16
     bc8:	1f 93       	push	r17
     bca:	cf 93       	push	r28
     bcc:	df 93       	push	r29
     bce:	ec 01       	movw	r28, r24
	portTickType xTimeToWake;
	signed portBASE_TYPE xAlreadyYielded = pdFALSE;

		/* A delay time of zero just forces a reschedule. */
		if( xTicksToDelay > ( portTickType ) 0U )
     bd0:	00 97       	sbiw	r24, 0x00	; 0
     bd2:	c9 f0       	breq	.+50     	; 0xc06 <vTaskDelay+0x40>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     bd4:	80 91 be 00 	lds	r24, 0x00BE
     bd8:	8f 5f       	subi	r24, 0xFF	; 255
     bda:	80 93 be 00 	sts	0x00BE, r24
				This task cannot be in an event list as it is the currently
				executing task. */

				/* Calculate the time to wake - this may overflow but this is
				not a problem. */
				xTimeToWake = xTickCount + xTicksToDelay;
     bde:	00 91 bc 00 	lds	r16, 0x00BC
     be2:	10 91 bd 00 	lds	r17, 0x00BD

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     be6:	80 91 b8 00 	lds	r24, 0x00B8
     bea:	90 91 b9 00 	lds	r25, 0x00B9
     bee:	02 96       	adiw	r24, 0x02	; 2
     bf0:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
					/* The current task must be in a ready list, so there is
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}
				prvAddCurrentTaskToDelayedList( xTimeToWake );
     bf4:	ce 01       	movw	r24, r28
     bf6:	80 0f       	add	r24, r16
     bf8:	91 1f       	adc	r25, r17
     bfa:	0e 94 14 05 	call	0xa28	; 0xa28 <prvAddCurrentTaskToDelayedList>
			}
			xAlreadyYielded = xTaskResumeAll();
     bfe:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
		}

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     c02:	88 23       	and	r24, r24
     c04:	11 f4       	brne	.+4      	; 0xc0a <vTaskDelay+0x44>
		{
			portYIELD_WITHIN_API();
     c06:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
		}
	}
     c0a:	df 91       	pop	r29
     c0c:	cf 91       	pop	r28
     c0e:	1f 91       	pop	r17
     c10:	0f 91       	pop	r16
     c12:	08 95       	ret

00000c14 <vTaskDelayUntil>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelayUntil == 1 )

	void vTaskDelayUntil( portTickType * const pxPreviousWakeTime, portTickType xTimeIncrement )
	{
     c14:	cf 93       	push	r28
     c16:	df 93       	push	r29
     c18:	fc 01       	movw	r30, r24
     c1a:	eb 01       	movw	r28, r22

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     c1c:	80 91 be 00 	lds	r24, 0x00BE
     c20:	8f 5f       	subi	r24, 0xFF	; 255
     c22:	80 93 be 00 	sts	0x00BE, r24
		configASSERT( ( xTimeIncrement > 0U ) );

		vTaskSuspendAll();
		{
			/* Generate the tick time at which the task wants to wake. */
			xTimeToWake = *pxPreviousWakeTime + xTimeIncrement;
     c26:	20 81       	ld	r18, Z
     c28:	31 81       	ldd	r19, Z+1	; 0x01
     c2a:	c2 0f       	add	r28, r18
     c2c:	d3 1f       	adc	r29, r19

			if( xTickCount < *pxPreviousWakeTime )
     c2e:	80 91 bc 00 	lds	r24, 0x00BC
     c32:	90 91 bd 00 	lds	r25, 0x00BD
     c36:	82 17       	cp	r24, r18
     c38:	93 07       	cpc	r25, r19
     c3a:	28 f4       	brcc	.+10     	; 0xc46 <vTaskDelayUntil+0x32>
				/* The tick count has overflowed since this function was
				lasted called.  In this case the only time we should ever
				actually delay is if the wake time has also	overflowed,
				and the wake time is greater than the tick time.  When this
				is the case it is as if neither time had overflowed. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) && ( xTimeToWake > xTickCount ) )
     c3c:	c2 17       	cp	r28, r18
     c3e:	d3 07       	cpc	r29, r19
     c40:	28 f0       	brcs	.+10     	; 0xc4c <vTaskDelayUntil+0x38>
     c42:	20 e0       	ldi	r18, 0x00	; 0
     c44:	0c c0       	rjmp	.+24     	; 0xc5e <vTaskDelayUntil+0x4a>
			else
			{
				/* The tick time has not overflowed.  In this case we will
				delay if either the wake time has overflowed, and/or the
				tick time is less than the wake time. */
				if( ( xTimeToWake < *pxPreviousWakeTime ) || ( xTimeToWake > xTickCount ) )
     c46:	c2 17       	cp	r28, r18
     c48:	d3 07       	cpc	r29, r19
     c4a:	40 f0       	brcs	.+16     	; 0xc5c <vTaskDelayUntil+0x48>
     c4c:	80 91 bc 00 	lds	r24, 0x00BC
     c50:	90 91 bd 00 	lds	r25, 0x00BD
     c54:	20 e0       	ldi	r18, 0x00	; 0
     c56:	8c 17       	cp	r24, r28
     c58:	9d 07       	cpc	r25, r29
     c5a:	08 f4       	brcc	.+2      	; 0xc5e <vTaskDelayUntil+0x4a>
     c5c:	21 e0       	ldi	r18, 0x01	; 1
					xShouldDelay = pdTRUE;
				}
			}

			/* Update the wake time ready for the next call. */
			*pxPreviousWakeTime = xTimeToWake;
     c5e:	d1 83       	std	Z+1, r29	; 0x01
     c60:	c0 83       	st	Z, r28

			if( xShouldDelay != pdFALSE )
     c62:	22 23       	and	r18, r18
     c64:	51 f0       	breq	.+20     	; 0xc7a <vTaskDelayUntil+0x66>
				traceTASK_DELAY_UNTIL();

				/* We must remove ourselves from the ready list before adding
				ourselves to the blocked list as the same list item is used for
				both lists. */
				if( uxListRemove( ( xListItem * ) &( pxCurrentTCB->xGenericListItem ) ) == 0 )
     c66:	80 91 b8 00 	lds	r24, 0x00B8
     c6a:	90 91 b9 00 	lds	r25, 0x00B9
     c6e:	02 96       	adiw	r24, 0x02	; 2
     c70:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
					no need to check, and the port reset macro can be called
					directly. */
					portRESET_READY_PRIORITY( pxCurrentTCB->uxPriority, uxTopReadyPriority );
				}

				prvAddCurrentTaskToDelayedList( xTimeToWake );
     c74:	ce 01       	movw	r24, r28
     c76:	0e 94 14 05 	call	0xa28	; 0xa28 <prvAddCurrentTaskToDelayedList>
			}
		}
		xAlreadyYielded = xTaskResumeAll();
     c7a:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>

		/* Force a reschedule if xTaskResumeAll has not already done so, we may
		have put ourselves to sleep. */
		if( xAlreadyYielded == pdFALSE )
     c7e:	88 23       	and	r24, r24
     c80:	11 f4       	brne	.+4      	; 0xc86 <vTaskDelayUntil+0x72>
		{
			portYIELD_WITHIN_API();
     c82:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
		}
	}
     c86:	df 91       	pop	r29
     c88:	cf 91       	pop	r28
     c8a:	08 95       	ret

00000c8c <vTaskDelete>:
/*-----------------------------------------------------------*/

#if ( INCLUDE_vTaskDelete == 1 )

	void vTaskDelete( xTaskHandle xTaskToDelete )
	{
     c8c:	ef 92       	push	r14
     c8e:	ff 92       	push	r15
     c90:	0f 93       	push	r16
     c92:	1f 93       	push	r17
     c94:	cf 93       	push	r28
     c96:	df 93       	push	r29
     c98:	8c 01       	movw	r16, r24
	tskTCB *pxTCB;

		taskENTER_CRITICAL();
     c9a:	0f b6       	in	r0, 0x3f	; 63
     c9c:	f8 94       	cli
     c9e:	0f 92       	push	r0
		{
			/* Ensure a yield is performed if the current task is being
			deleted. */
			if( xTaskToDelete == pxCurrentTCB )
     ca0:	80 91 b8 00 	lds	r24, 0x00B8
     ca4:	90 91 b9 00 	lds	r25, 0x00B9
     ca8:	08 17       	cp	r16, r24
     caa:	19 07       	cpc	r17, r25
     cac:	19 f4       	brne	.+6      	; 0xcb4 <vTaskDelete+0x28>
     cae:	00 e0       	ldi	r16, 0x00	; 0
     cb0:	10 e0       	ldi	r17, 0x00	; 0
     cb2:	03 c0       	rjmp	.+6      	; 0xcba <vTaskDelete+0x2e>
			{
				xTaskToDelete = NULL;
			}

			/* If null is passed in here then we are deleting ourselves. */
			pxTCB = prvGetTCBFromHandle( xTaskToDelete );
     cb4:	01 15       	cp	r16, r1
     cb6:	11 05       	cpc	r17, r1
     cb8:	29 f4       	brne	.+10     	; 0xcc4 <vTaskDelete+0x38>
     cba:	c0 91 b8 00 	lds	r28, 0x00B8
     cbe:	d0 91 b9 00 	lds	r29, 0x00B9
     cc2:	01 c0       	rjmp	.+2      	; 0xcc6 <vTaskDelete+0x3a>
     cc4:	e8 01       	movw	r28, r16

			/* Remove task from the ready list and place in the	termination list.
			This will stop the task from be scheduled.  The idle task will check
			the termination list and free up any memory allocated by the
			scheduler for the TCB and stack. */
			if( uxListRemove( ( xListItem * ) &( pxTCB->xGenericListItem ) ) == 0 )
     cc6:	22 e0       	ldi	r18, 0x02	; 2
     cc8:	e2 2e       	mov	r14, r18
     cca:	f1 2c       	mov	r15, r1
     ccc:	ec 0e       	add	r14, r28
     cce:	fd 1e       	adc	r15, r29
     cd0:	c7 01       	movw	r24, r14
     cd2:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
			{
				taskRESET_READY_PRIORITY( pxTCB->uxPriority );
			}

			/* Is the task waiting on an event also? */
			if( pxTCB->xEventListItem.pvContainer != NULL )
     cd6:	8c 89       	ldd	r24, Y+20	; 0x14
     cd8:	9d 89       	ldd	r25, Y+21	; 0x15
     cda:	89 2b       	or	r24, r25
     cdc:	21 f0       	breq	.+8      	; 0xce6 <vTaskDelete+0x5a>
			{
				uxListRemove( &( pxTCB->xEventListItem ) );
     cde:	ce 01       	movw	r24, r28
     ce0:	0c 96       	adiw	r24, 0x0c	; 12
     ce2:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
			}

			vListInsertEnd( ( xList * ) &xTasksWaitingTermination, &( pxTCB->xGenericListItem ) );
     ce6:	89 e0       	ldi	r24, 0x09	; 9
     ce8:	91 e0       	ldi	r25, 0x01	; 1
     cea:	b7 01       	movw	r22, r14
     cec:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>

			/* Increment the ucTasksDeleted variable so the idle task knows
			there is a task that has been deleted and that it should therefore
			check the xTasksWaitingTermination list. */
			++uxTasksDeleted;
     cf0:	80 91 c3 00 	lds	r24, 0x00C3
     cf4:	8f 5f       	subi	r24, 0xFF	; 255
     cf6:	80 93 c3 00 	sts	0x00C3, r24

			/* Increment the uxTaskNumberVariable also so kernel aware debuggers
			can detect that the task lists need re-generating. */
			uxTaskNumber++;
     cfa:	80 91 c4 00 	lds	r24, 0x00C4
     cfe:	8f 5f       	subi	r24, 0xFF	; 255
     d00:	80 93 c4 00 	sts	0x00C4, r24

			traceTASK_DELETE( pxTCB );
		}
		taskEXIT_CRITICAL();
     d04:	0f 90       	pop	r0
     d06:	0f be       	out	0x3f, r0	; 63

		/* Force a reschedule if we have just deleted the current task. */
		if( xSchedulerRunning != pdFALSE )
     d08:	80 91 c2 00 	lds	r24, 0x00C2
     d0c:	88 23       	and	r24, r24
     d0e:	21 f0       	breq	.+8      	; 0xd18 <vTaskDelete+0x8c>
		{
			if( ( void * ) xTaskToDelete == NULL )
     d10:	01 2b       	or	r16, r17
     d12:	11 f4       	brne	.+4      	; 0xd18 <vTaskDelete+0x8c>
			{
				portYIELD_WITHIN_API();
     d14:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
			}
		}
	}
     d18:	df 91       	pop	r29
     d1a:	cf 91       	pop	r28
     d1c:	1f 91       	pop	r17
     d1e:	0f 91       	pop	r16
     d20:	ff 90       	pop	r15
     d22:	ef 90       	pop	r14
     d24:	08 95       	ret

00000d26 <vTaskEndScheduler>:
void vTaskEndScheduler( void )
{
	/* Stop the scheduler interrupts and call the portable scheduler end
	routine so the original ISRs can be restored if necessary.  The port
	layer must ensure interrupts enable	bit is left in the correct state. */
	portDISABLE_INTERRUPTS();
     d26:	f8 94       	cli
	xSchedulerRunning = pdFALSE;
     d28:	10 92 c2 00 	sts	0x00C2, r1
	vPortEndScheduler();
     d2c:	0e 94 09 0f 	call	0x1e12	; 0x1e12 <vPortEndScheduler>
}
     d30:	08 95       	ret

00000d32 <prvIdleTask>:
 *
 * void prvIdleTask( void *pvParameters );
 *
 */
static portTASK_FUNCTION( prvIdleTask, pvParameters )
{
     d32:	0f 93       	push	r16
     d34:	1f 93       	push	r17
     d36:	2c c0       	rjmp	.+88     	; 0xd90 <prvIdleTask+0x5e>

void vTaskSuspendAll( void )
{
	/* A critical section is not required as the variable is of type
	portBASE_TYPE. */
	++uxSchedulerSuspended;
     d38:	80 91 be 00 	lds	r24, 0x00BE
     d3c:	8f 5f       	subi	r24, 0xFF	; 255
     d3e:	80 93 be 00 	sts	0x00BE, r24
		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
		{
			vTaskSuspendAll();
				xListIsEmpty = listLIST_IS_EMPTY( &xTasksWaitingTermination );
     d42:	10 91 09 01 	lds	r17, 0x0109
			xTaskResumeAll();
     d46:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>

			if( xListIsEmpty == pdFALSE )
     d4a:	11 23       	and	r17, r17
     d4c:	09 f1       	breq	.+66     	; 0xd90 <prvIdleTask+0x5e>
			{
				tskTCB *pxTCB;

				taskENTER_CRITICAL();
     d4e:	0f b6       	in	r0, 0x3f	; 63
     d50:	f8 94       	cli
     d52:	0f 92       	push	r0
				{
					pxTCB = ( tskTCB * ) listGET_OWNER_OF_HEAD_ENTRY( ( ( xList * ) &xTasksWaitingTermination ) );
     d54:	e0 91 0e 01 	lds	r30, 0x010E
     d58:	f0 91 0f 01 	lds	r31, 0x010F
     d5c:	06 81       	ldd	r16, Z+6	; 0x06
     d5e:	17 81       	ldd	r17, Z+7	; 0x07
					uxListRemove( &( pxTCB->xGenericListItem ) );
     d60:	c8 01       	movw	r24, r16
     d62:	02 96       	adiw	r24, 0x02	; 2
     d64:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
					--uxCurrentNumberOfTasks;
     d68:	80 91 c1 00 	lds	r24, 0x00C1
     d6c:	81 50       	subi	r24, 0x01	; 1
     d6e:	80 93 c1 00 	sts	0x00C1, r24
					--uxTasksDeleted;
     d72:	80 91 c3 00 	lds	r24, 0x00C3
     d76:	81 50       	subi	r24, 0x01	; 1
     d78:	80 93 c3 00 	sts	0x00C3, r24
				}
				taskEXIT_CRITICAL();
     d7c:	0f 90       	pop	r0
     d7e:	0f be       	out	0x3f, r0	; 63
		want to allocate and clean RAM statically. */
		portCLEAN_UP_TCB( pxTCB );

		/* Free up the memory allocated by the scheduler for the task.  It is up to
		the task to free any memory allocated at the application level. */
		vPortFreeAligned( pxTCB->pxStack );
     d80:	f8 01       	movw	r30, r16
     d82:	87 89       	ldd	r24, Z+23	; 0x17
     d84:	90 8d       	ldd	r25, Z+24	; 0x18
     d86:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vPortFree>
		vPortFree( pxTCB );
     d8a:	c8 01       	movw	r24, r16
     d8c:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vPortFree>
	{
		portBASE_TYPE xListIsEmpty;

		/* ucTasksDeleted is used to prevent vTaskSuspendAll() being called
		too often in the idle task. */
		while( uxTasksDeleted > ( unsigned portBASE_TYPE ) 0U )
     d90:	80 91 c3 00 	lds	r24, 0x00C3
     d94:	88 23       	and	r24, r24
     d96:	81 f6       	brne	.-96     	; 0xd38 <prvIdleTask+0x6>

			A critical region is not required here as we are just reading from
			the list, and an occasional incorrect value will not matter.  If
			the ready list at the idle priority contains more than one task
			then a task other than the idle task is ready to execute. */
			if( listCURRENT_LIST_LENGTH( &( pxReadyTasksLists[ tskIDLE_PRIORITY ] ) ) > ( unsigned portBASE_TYPE ) 1 )
     d98:	80 91 c6 00 	lds	r24, 0x00C6
     d9c:	82 30       	cpi	r24, 0x02	; 2
     d9e:	10 f0       	brcs	.+4      	; 0xda4 <prvIdleTask+0x72>
			{
				taskYIELD();
     da0:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
			/* Call the user defined function from within the idle task.  This
			allows the application designer to add background functionality
			without the overhead of a separate task.
			NOTE: vApplicationIdleHook() MUST NOT, UNDER ANY CIRCUMSTANCES,
			CALL A FUNCTION THAT MIGHT BLOCK. */
			vApplicationIdleHook();
     da4:	0e 94 47 00 	call	0x8e	; 0x8e <vApplicationIdleHook>
     da8:	f3 cf       	rjmp	.-26     	; 0xd90 <prvIdleTask+0x5e>

00000daa <xTaskGenericCreate>:
#endif

/*lint +e956 */

signed portBASE_TYPE xTaskGenericCreate( pdTASK_CODE pxTaskCode, const signed char * const pcName, unsigned short usStackDepth, void *pvParameters, unsigned portBASE_TYPE uxPriority, xTaskHandle *pxCreatedTask, portSTACK_TYPE *puxStackBuffer, const xMemoryRegion * const xRegions )
{
     daa:	2f 92       	push	r2
     dac:	3f 92       	push	r3
     dae:	5f 92       	push	r5
     db0:	6f 92       	push	r6
     db2:	7f 92       	push	r7
     db4:	8f 92       	push	r8
     db6:	9f 92       	push	r9
     db8:	af 92       	push	r10
     dba:	bf 92       	push	r11
     dbc:	cf 92       	push	r12
     dbe:	df 92       	push	r13
     dc0:	ef 92       	push	r14
     dc2:	ff 92       	push	r15
     dc4:	0f 93       	push	r16
     dc6:	1f 93       	push	r17
     dc8:	df 93       	push	r29
     dca:	cf 93       	push	r28
     dcc:	00 d0       	rcall	.+0      	; 0xdce <xTaskGenericCreate+0x24>
     dce:	00 d0       	rcall	.+0      	; 0xdd0 <xTaskGenericCreate+0x26>
     dd0:	cd b7       	in	r28, 0x3d	; 61
     dd2:	de b7       	in	r29, 0x3e	; 62
     dd4:	9a 83       	std	Y+2, r25	; 0x02
     dd6:	89 83       	std	Y+1, r24	; 0x01
     dd8:	4b 01       	movw	r8, r22
     dda:	5a 01       	movw	r10, r20
     ddc:	19 01       	movw	r2, r18
     dde:	50 2e       	mov	r5, r16
     de0:	37 01       	movw	r6, r14
{
tskTCB *pxNewTCB;

	/* Allocate space for the TCB.  Where the memory comes from depends on
	the implementation of the port malloc function. */
	pxNewTCB = ( tskTCB * ) pvPortMalloc( sizeof( tskTCB ) );
     de2:	81 e2       	ldi	r24, 0x21	; 33
     de4:	90 e0       	ldi	r25, 0x00	; 0
     de6:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <pvPortMalloc>
     dea:	8b 83       	std	Y+3, r24	; 0x03
     dec:	9c 83       	std	Y+4, r25	; 0x04

	if( pxNewTCB != NULL )
     dee:	8b 81       	ldd	r24, Y+3	; 0x03
     df0:	9c 81       	ldd	r25, Y+4	; 0x04
     df2:	89 2b       	or	r24, r25
     df4:	89 f0       	breq	.+34     	; 0xe18 <xTaskGenericCreate+0x6e>
	{
		/* Allocate space for the stack used by the task being created.
		The base of the stack memory stored in the TCB so the task can
		be deleted later if required. */
		pxNewTCB->pxStack = ( portSTACK_TYPE * ) pvPortMallocAligned( ( ( ( size_t )usStackDepth ) * sizeof( portSTACK_TYPE ) ), puxStackBuffer );
     df6:	c1 14       	cp	r12, r1
     df8:	d1 04       	cpc	r13, r1
     dfa:	21 f4       	brne	.+8      	; 0xe04 <xTaskGenericCreate+0x5a>
     dfc:	c5 01       	movw	r24, r10
     dfe:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <pvPortMalloc>
     e02:	6c 01       	movw	r12, r24
     e04:	eb 81       	ldd	r30, Y+3	; 0x03
     e06:	fc 81       	ldd	r31, Y+4	; 0x04
     e08:	d0 8e       	std	Z+24, r13	; 0x18
     e0a:	c7 8a       	std	Z+23, r12	; 0x17

		if( pxNewTCB->pxStack == NULL )
     e0c:	c1 14       	cp	r12, r1
     e0e:	d1 04       	cpc	r13, r1
     e10:	29 f4       	brne	.+10     	; 0xe1c <xTaskGenericCreate+0x72>
		{
			/* Could not allocate the stack.  Delete the allocated TCB. */
			vPortFree( pxNewTCB );
     e12:	cf 01       	movw	r24, r30
     e14:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vPortFree>
     e18:	8f ef       	ldi	r24, 0xFF	; 255
     e1a:	d5 c0       	rjmp	.+426    	; 0xfc6 <xTaskGenericCreate+0x21c>
			pxNewTCB = NULL;
		}
		else
		{
			/* Just to help debugging. */
			memset( pxNewTCB->pxStack, ( int ) tskSTACK_FILL_BYTE, ( size_t ) usStackDepth * sizeof( portSTACK_TYPE ) );
     e1c:	c6 01       	movw	r24, r12
     e1e:	65 ea       	ldi	r22, 0xA5	; 165
     e20:	70 e0       	ldi	r23, 0x00	; 0
     e22:	a5 01       	movw	r20, r10
     e24:	0e 94 01 13 	call	0x2602	; 0x2602 <memset>
		stack grows from high memory to low (as per the 80x86) or visa versa.
		portSTACK_GROWTH is used to make the result positive or negative as
		required by the port. */
		#if( portSTACK_GROWTH < 0 )
		{
			pxTopOfStack = pxNewTCB->pxStack + ( usStackDepth - ( unsigned short ) 1 );
     e28:	08 94       	sec
     e2a:	a1 08       	sbc	r10, r1
     e2c:	b1 08       	sbc	r11, r1
     e2e:	eb 81       	ldd	r30, Y+3	; 0x03
     e30:	fc 81       	ldd	r31, Y+4	; 0x04
     e32:	e7 88       	ldd	r14, Z+23	; 0x17
     e34:	f0 8c       	ldd	r15, Z+24	; 0x18
     e36:	ea 0c       	add	r14, r10
     e38:	fb 1c       	adc	r15, r11
{
	/* Store the function name in the TCB. */
	#if configMAX_TASK_NAME_LEN > 1
	{
		/* Don't bring strncpy into the build unnecessarily. */
		strncpy( ( char * ) pxTCB->pcTaskName, ( const char * ) pcName, ( unsigned short ) configMAX_TASK_NAME_LEN );
     e3a:	cf 01       	movw	r24, r30
     e3c:	49 96       	adiw	r24, 0x19	; 25
     e3e:	b4 01       	movw	r22, r8
     e40:	48 e0       	ldi	r20, 0x08	; 8
     e42:	50 e0       	ldi	r21, 0x00	; 0
     e44:	0e 94 08 13 	call	0x2610	; 0x2610 <strncpy>
	}
	#endif /* configMAX_TASK_NAME_LEN */
	pxTCB->pcTaskName[ ( unsigned short ) configMAX_TASK_NAME_LEN - ( unsigned short ) 1 ] = ( signed char ) '\0';
     e48:	eb 81       	ldd	r30, Y+3	; 0x03
     e4a:	fc 81       	ldd	r31, Y+4	; 0x04
     e4c:	10 a2       	std	Z+32, r1	; 0x20
     e4e:	05 2d       	mov	r16, r5
     e50:	f3 e0       	ldi	r31, 0x03	; 3
     e52:	f5 15       	cp	r31, r5
     e54:	08 f4       	brcc	.+2      	; 0xe58 <xTaskGenericCreate+0xae>
     e56:	03 e0       	ldi	r16, 0x03	; 3
	if( uxPriority >= configMAX_PRIORITIES )
	{
		uxPriority = configMAX_PRIORITIES - ( unsigned portBASE_TYPE ) 1U;
	}

	pxTCB->uxPriority = uxPriority;
     e58:	eb 81       	ldd	r30, Y+3	; 0x03
     e5a:	fc 81       	ldd	r31, Y+4	; 0x04
     e5c:	06 8b       	std	Z+22, r16	; 0x16
	{
		pxTCB->uxBasePriority = uxPriority;
	}
	#endif /* configUSE_MUTEXES */

	vListInitialiseItem( &( pxTCB->xGenericListItem ) );
     e5e:	42 e0       	ldi	r20, 0x02	; 2
     e60:	c4 2e       	mov	r12, r20
     e62:	d1 2c       	mov	r13, r1
     e64:	ce 0e       	add	r12, r30
     e66:	df 1e       	adc	r13, r31
     e68:	c6 01       	movw	r24, r12
     e6a:	0e 94 01 0c 	call	0x1802	; 0x1802 <vListInitialiseItem>
	vListInitialiseItem( &( pxTCB->xEventListItem ) );
     e6e:	8b 81       	ldd	r24, Y+3	; 0x03
     e70:	9c 81       	ldd	r25, Y+4	; 0x04
     e72:	0c 96       	adiw	r24, 0x0c	; 12
     e74:	0e 94 01 0c 	call	0x1802	; 0x1802 <vListInitialiseItem>

	/* Set the pxTCB as a link back from the xListItem.  This is so we can get
	back to	the containing TCB from a generic item in a list. */
	listSET_LIST_ITEM_OWNER( &( pxTCB->xGenericListItem ), pxTCB );
     e78:	8b 81       	ldd	r24, Y+3	; 0x03
     e7a:	9c 81       	ldd	r25, Y+4	; 0x04
     e7c:	fc 01       	movw	r30, r24
     e7e:	91 87       	std	Z+9, r25	; 0x09
     e80:	80 87       	std	Z+8, r24	; 0x08

	/* Event lists are always in priority order. */
	listSET_LIST_ITEM_VALUE( &( pxTCB->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
     e82:	84 e0       	ldi	r24, 0x04	; 4
     e84:	90 e0       	ldi	r25, 0x00	; 0
     e86:	80 1b       	sub	r24, r16
     e88:	91 09       	sbc	r25, r1
     e8a:	95 87       	std	Z+13, r25	; 0x0d
     e8c:	84 87       	std	Z+12, r24	; 0x0c
	listSET_LIST_ITEM_OWNER( &( pxTCB->xEventListItem ), pxTCB );
     e8e:	f3 8b       	std	Z+19, r31	; 0x13
     e90:	e2 8b       	std	Z+18, r30	; 0x12
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters, xRunPrivileged );
		}
		#else /* portUSING_MPU_WRAPPERS */
		{
			pxNewTCB->pxTopOfStack = pxPortInitialiseStack( pxTopOfStack, pxTaskCode, pvParameters );
     e92:	c7 01       	movw	r24, r14
     e94:	69 81       	ldd	r22, Y+1	; 0x01
     e96:	7a 81       	ldd	r23, Y+2	; 0x02
     e98:	a1 01       	movw	r20, r2
     e9a:	0e 94 8c 0e 	call	0x1d18	; 0x1d18 <pxPortInitialiseStack>
     e9e:	eb 81       	ldd	r30, Y+3	; 0x03
     ea0:	fc 81       	ldd	r31, Y+4	; 0x04
     ea2:	91 83       	std	Z+1, r25	; 0x01
     ea4:	80 83       	st	Z, r24
		#endif /* portUSING_MPU_WRAPPERS */

		/* Check the alignment of the initialised stack. */
		portALIGNMENT_ASSERT_pxCurrentTCB( ( ( ( unsigned long ) pxNewTCB->pxTopOfStack & ( unsigned long ) portBYTE_ALIGNMENT_MASK ) == 0UL ) );

		if( ( void * ) pxCreatedTask != NULL )
     ea6:	61 14       	cp	r6, r1
     ea8:	71 04       	cpc	r7, r1
     eaa:	21 f0       	breq	.+8      	; 0xeb4 <xTaskGenericCreate+0x10a>
		{
			/* Pass the TCB out - in an anonymous way.  The calling function/
			task can use this as a handle to delete the task later if
			required.*/
			*pxCreatedTask = ( xTaskHandle ) pxNewTCB;
     eac:	cf 01       	movw	r24, r30
     eae:	f3 01       	movw	r30, r6
     eb0:	91 83       	std	Z+1, r25	; 0x01
     eb2:	80 83       	st	Z, r24
		}

		/* We are going to manipulate the task queues to add this task to a
		ready list, so must make sure no interrupts occur. */
		taskENTER_CRITICAL();
     eb4:	0f b6       	in	r0, 0x3f	; 63
     eb6:	f8 94       	cli
     eb8:	0f 92       	push	r0
		{
			uxCurrentNumberOfTasks++;
     eba:	80 91 c1 00 	lds	r24, 0x00C1
     ebe:	8f 5f       	subi	r24, 0xFF	; 255
     ec0:	80 93 c1 00 	sts	0x00C1, r24
			if( pxCurrentTCB == NULL )
     ec4:	80 91 b8 00 	lds	r24, 0x00B8
     ec8:	90 91 b9 00 	lds	r25, 0x00B9
     ecc:	89 2b       	or	r24, r25
     ece:	b9 f5       	brne	.+110    	; 0xf3e <xTaskGenericCreate+0x194>
			{
				/* There are no other tasks, or all the other tasks are in
				the suspended state - make this the current task. */
				pxCurrentTCB =  pxNewTCB;
     ed0:	eb 81       	ldd	r30, Y+3	; 0x03
     ed2:	fc 81       	ldd	r31, Y+4	; 0x04
     ed4:	f0 93 b9 00 	sts	0x00B9, r31
     ed8:	e0 93 b8 00 	sts	0x00B8, r30

				if( uxCurrentNumberOfTasks == ( unsigned portBASE_TYPE ) 1 )
     edc:	80 91 c1 00 	lds	r24, 0x00C1
     ee0:	81 30       	cpi	r24, 0x01	; 1
     ee2:	f1 f5       	brne	.+124    	; 0xf60 <xTaskGenericCreate+0x1b6>
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = ( unsigned portBASE_TYPE ) 0U; uxPriority < configMAX_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyTasksLists[ uxPriority ] ) );
     ee4:	86 ec       	ldi	r24, 0xC6	; 198
     ee6:	90 e0       	ldi	r25, 0x00	; 0
     ee8:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
     eec:	8f ec       	ldi	r24, 0xCF	; 207
     eee:	90 e0       	ldi	r25, 0x00	; 0
     ef0:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
     ef4:	88 ed       	ldi	r24, 0xD8	; 216
     ef6:	90 e0       	ldi	r25, 0x00	; 0
     ef8:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
     efc:	81 ee       	ldi	r24, 0xE1	; 225
     efe:	90 e0       	ldi	r25, 0x00	; 0
     f00:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedTaskList1 );
     f04:	3a ee       	ldi	r19, 0xEA	; 234
     f06:	e3 2e       	mov	r14, r19
     f08:	30 e0       	ldi	r19, 0x00	; 0
     f0a:	f3 2e       	mov	r15, r19
     f0c:	c7 01       	movw	r24, r14
     f0e:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedTaskList2 );
     f12:	03 ef       	ldi	r16, 0xF3	; 243
     f14:	10 e0       	ldi	r17, 0x00	; 0
     f16:	c8 01       	movw	r24, r16
     f18:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyList );
     f1c:	80 e0       	ldi	r24, 0x00	; 0
     f1e:	91 e0       	ldi	r25, 0x01	; 1
     f20:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>

	#if ( INCLUDE_vTaskDelete == 1 )
	{
		vListInitialise( ( xList * ) &xTasksWaitingTermination );
     f24:	89 e0       	ldi	r24, 0x09	; 9
     f26:	91 e0       	ldi	r25, 0x01	; 1
     f28:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
	}
	#endif /* INCLUDE_vTaskSuspend */

	/* Start with pxDelayedTaskList using list1 and the pxOverflowDelayedTaskList
	using list2. */
	pxDelayedTaskList = &xDelayedTaskList1;
     f2c:	f0 92 fd 00 	sts	0x00FD, r15
     f30:	e0 92 fc 00 	sts	0x00FC, r14
	pxOverflowDelayedTaskList = &xDelayedTaskList2;
     f34:	10 93 ff 00 	sts	0x00FF, r17
     f38:	00 93 fe 00 	sts	0x00FE, r16
     f3c:	11 c0       	rjmp	.+34     	; 0xf60 <xTaskGenericCreate+0x1b6>
			else
			{
				/* If the scheduler is not already running, make this task the
				current task if it is the highest priority task to be created
				so far. */
				if( xSchedulerRunning == pdFALSE )
     f3e:	80 91 c2 00 	lds	r24, 0x00C2
     f42:	88 23       	and	r24, r24
     f44:	69 f4       	brne	.+26     	; 0xf60 <xTaskGenericCreate+0x1b6>
				{
					if( pxCurrentTCB->uxPriority <= uxPriority )
     f46:	e0 91 b8 00 	lds	r30, 0x00B8
     f4a:	f0 91 b9 00 	lds	r31, 0x00B9
     f4e:	86 89       	ldd	r24, Z+22	; 0x16
     f50:	58 16       	cp	r5, r24
     f52:	30 f0       	brcs	.+12     	; 0xf60 <xTaskGenericCreate+0x1b6>
					{
						pxCurrentTCB = pxNewTCB;
     f54:	8b 81       	ldd	r24, Y+3	; 0x03
     f56:	9c 81       	ldd	r25, Y+4	; 0x04
     f58:	90 93 b9 00 	sts	0x00B9, r25
     f5c:	80 93 b8 00 	sts	0x00B8, r24
				}
			}

			/* Remember the top priority to make context switching faster.  Use
			the priority in pxNewTCB as this has been capped to a valid value. */
			if( pxNewTCB->uxPriority > uxTopUsedPriority )
     f60:	eb 81       	ldd	r30, Y+3	; 0x03
     f62:	fc 81       	ldd	r31, Y+4	; 0x04
     f64:	96 89       	ldd	r25, Z+22	; 0x16
     f66:	80 91 c5 00 	lds	r24, 0x00C5
     f6a:	89 17       	cp	r24, r25
     f6c:	10 f4       	brcc	.+4      	; 0xf72 <xTaskGenericCreate+0x1c8>
			{
				uxTopUsedPriority = pxNewTCB->uxPriority;
     f6e:	90 93 c5 00 	sts	0x00C5, r25
			}

			uxTaskNumber++;
     f72:	80 91 c4 00 	lds	r24, 0x00C4
     f76:	8f 5f       	subi	r24, 0xFF	; 255
     f78:	80 93 c4 00 	sts	0x00C4, r24
				pxNewTCB->uxTCBNumber = uxTaskNumber;
			}
			#endif /* configUSE_TRACE_FACILITY */
			traceTASK_CREATE( pxNewTCB );

			prvAddTaskToReadyQueue( pxNewTCB );
     f7c:	eb 81       	ldd	r30, Y+3	; 0x03
     f7e:	fc 81       	ldd	r31, Y+4	; 0x04
     f80:	96 89       	ldd	r25, Z+22	; 0x16
     f82:	80 91 bf 00 	lds	r24, 0x00BF
     f86:	89 17       	cp	r24, r25
     f88:	10 f4       	brcc	.+4      	; 0xf8e <xTaskGenericCreate+0x1e4>
     f8a:	90 93 bf 00 	sts	0x00BF, r25
     f8e:	eb 81       	ldd	r30, Y+3	; 0x03
     f90:	fc 81       	ldd	r31, Y+4	; 0x04
     f92:	86 89       	ldd	r24, Z+22	; 0x16
     f94:	29 e0       	ldi	r18, 0x09	; 9
     f96:	82 9f       	mul	r24, r18
     f98:	c0 01       	movw	r24, r0
     f9a:	11 24       	eor	r1, r1
     f9c:	8a 53       	subi	r24, 0x3A	; 58
     f9e:	9f 4f       	sbci	r25, 0xFF	; 255
     fa0:	b6 01       	movw	r22, r12
     fa2:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>

			xReturn = pdPASS;
			portSETUP_TCB( pxNewTCB );
		}
		taskEXIT_CRITICAL();
     fa6:	0f 90       	pop	r0
     fa8:	0f be       	out	0x3f, r0	; 63
		traceTASK_CREATE_FAILED();
	}

	if( xReturn == pdPASS )
	{
		if( xSchedulerRunning != pdFALSE )
     faa:	80 91 c2 00 	lds	r24, 0x00C2
     fae:	88 23       	and	r24, r24
     fb0:	49 f0       	breq	.+18     	; 0xfc4 <xTaskGenericCreate+0x21a>
		{
			/* If the created task is of a higher priority than the current task
			then it should run now. */
			if( pxCurrentTCB->uxPriority < uxPriority )
     fb2:	e0 91 b8 00 	lds	r30, 0x00B8
     fb6:	f0 91 b9 00 	lds	r31, 0x00B9
     fba:	86 89       	ldd	r24, Z+22	; 0x16
     fbc:	85 15       	cp	r24, r5
     fbe:	10 f4       	brcc	.+4      	; 0xfc4 <xTaskGenericCreate+0x21a>
			{
				portYIELD_WITHIN_API();
     fc0:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
     fc4:	81 e0       	ldi	r24, 0x01	; 1
			}
		}
	}

	return xReturn;
}
     fc6:	0f 90       	pop	r0
     fc8:	0f 90       	pop	r0
     fca:	0f 90       	pop	r0
     fcc:	0f 90       	pop	r0
     fce:	cf 91       	pop	r28
     fd0:	df 91       	pop	r29
     fd2:	1f 91       	pop	r17
     fd4:	0f 91       	pop	r16
     fd6:	ff 90       	pop	r15
     fd8:	ef 90       	pop	r14
     fda:	df 90       	pop	r13
     fdc:	cf 90       	pop	r12
     fde:	bf 90       	pop	r11
     fe0:	af 90       	pop	r10
     fe2:	9f 90       	pop	r9
     fe4:	8f 90       	pop	r8
     fe6:	7f 90       	pop	r7
     fe8:	6f 90       	pop	r6
     fea:	5f 90       	pop	r5
     fec:	3f 90       	pop	r3
     fee:	2f 90       	pop	r2
     ff0:	08 95       	ret

00000ff2 <vTaskStartScheduler>:

#endif /* ( ( INCLUDE_xTaskResumeFromISR == 1 ) && ( INCLUDE_vTaskSuspend == 1 ) ) */
/*-----------------------------------------------------------*/

void vTaskStartScheduler( void )
{
     ff2:	af 92       	push	r10
     ff4:	bf 92       	push	r11
     ff6:	cf 92       	push	r12
     ff8:	df 92       	push	r13
     ffa:	ef 92       	push	r14
     ffc:	ff 92       	push	r15
     ffe:	0f 93       	push	r16
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), &xIdleTaskHandle );
	}
	#else
	{
		/* Create the idle task without storing its handle. */
		xReturn = xTaskCreate( prvIdleTask, ( signed char * ) "IDLE", tskIDLE_STACK_SIZE, ( void * ) NULL, ( tskIDLE_PRIORITY | portPRIVILEGE_BIT ), NULL );
    1000:	89 e9       	ldi	r24, 0x99	; 153
    1002:	96 e0       	ldi	r25, 0x06	; 6
    1004:	65 e7       	ldi	r22, 0x75	; 117
    1006:	70 e0       	ldi	r23, 0x00	; 0
    1008:	45 e5       	ldi	r20, 0x55	; 85
    100a:	50 e0       	ldi	r21, 0x00	; 0
    100c:	20 e0       	ldi	r18, 0x00	; 0
    100e:	30 e0       	ldi	r19, 0x00	; 0
    1010:	00 e0       	ldi	r16, 0x00	; 0
    1012:	ee 24       	eor	r14, r14
    1014:	ff 24       	eor	r15, r15
    1016:	cc 24       	eor	r12, r12
    1018:	dd 24       	eor	r13, r13
    101a:	aa 24       	eor	r10, r10
    101c:	bb 24       	eor	r11, r11
    101e:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>
			xReturn = xTimerCreateTimerTask();
		}
	}
	#endif /* configUSE_TIMERS */

	if( xReturn == pdPASS )
    1022:	81 30       	cpi	r24, 0x01	; 1
    1024:	49 f4       	brne	.+18     	; 0x1038 <vTaskStartScheduler+0x46>
		so interrupts will automatically get re-enabled when the first task
		starts to run.

		STEPPING THROUGH HERE USING A DEBUGGER CAN CAUSE BIG PROBLEMS IF THE
		DEBUGGER ALLOWS INTERRUPTS TO BE PROCESSED. */
		portDISABLE_INTERRUPTS();
    1026:	f8 94       	cli

		xSchedulerRunning = pdTRUE;
    1028:	80 93 c2 00 	sts	0x00C2, r24
		xTickCount = ( portTickType ) 0U;
    102c:	10 92 bd 00 	sts	0x00BD, r1
    1030:	10 92 bc 00 	sts	0x00BC, r1
		the run time counter time base. */
		portCONFIGURE_TIMER_FOR_RUN_TIME_STATS();

		/* Setting up the timer tick is hardware specific and thus in the
		portable interface. */
		if( xPortStartScheduler() != pdFALSE )
    1034:	0e 94 d4 0e 	call	0x1da8	; 0x1da8 <xPortStartScheduler>
		/* This line will only be reached if the kernel could not be started,
		because there was not enough FreeRTOS heap to create the idle task
		or the timer task. */
		configASSERT( xReturn );
	}
}
    1038:	0f 91       	pop	r16
    103a:	ff 90       	pop	r15
    103c:	ef 90       	pop	r14
    103e:	df 90       	pop	r13
    1040:	cf 90       	pop	r12
    1042:	bf 90       	pop	r11
    1044:	af 90       	pop	r10
    1046:	08 95       	ret

00001048 <uxQueueMessagesWaiting>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	taskENTER_CRITICAL();
    1048:	0f b6       	in	r0, 0x3f	; 63
    104a:	f8 94       	cli
    104c:	0f 92       	push	r0
		uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    104e:	fc 01       	movw	r30, r24
    1050:	82 8d       	ldd	r24, Z+26	; 0x1a
	taskEXIT_CRITICAL();
    1052:	0f 90       	pop	r0
    1054:	0f be       	out	0x3f, r0	; 63

	return uxReturn;
}
    1056:	08 95       	ret

00001058 <uxQueueMessagesWaitingFromISR>:
{
unsigned portBASE_TYPE uxReturn;

	configASSERT( xQueue );

	uxReturn = ( ( xQUEUE * ) xQueue )->uxMessagesWaiting;
    1058:	fc 01       	movw	r30, r24
    105a:	82 8d       	ldd	r24, Z+26	; 0x1a

	return uxReturn;
}
    105c:	08 95       	ret

0000105e <xQueueIsQueueEmptyFromISR>:
signed portBASE_TYPE xQueueIsQueueEmptyFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == 0 )
    105e:	fc 01       	movw	r30, r24
    1060:	82 8d       	ldd	r24, Z+26	; 0x1a
    1062:	90 e0       	ldi	r25, 0x00	; 0
    1064:	88 23       	and	r24, r24
    1066:	09 f4       	brne	.+2      	; 0x106a <xQueueIsQueueEmptyFromISR+0xc>
    1068:	91 e0       	ldi	r25, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    106a:	89 2f       	mov	r24, r25
    106c:	08 95       	ret

0000106e <xQueueIsQueueFullFromISR>:
signed portBASE_TYPE xQueueIsQueueFullFromISR( const xQueueHandle xQueue )
{
signed portBASE_TYPE xReturn;

	configASSERT( xQueue );
	if( ( ( xQUEUE * ) xQueue )->uxMessagesWaiting == ( ( xQUEUE * ) xQueue )->uxLength )
    106e:	fc 01       	movw	r30, r24
    1070:	92 8d       	ldd	r25, Z+26	; 0x1a
    1072:	20 e0       	ldi	r18, 0x00	; 0
    1074:	83 8d       	ldd	r24, Z+27	; 0x1b
    1076:	98 17       	cp	r25, r24
    1078:	09 f4       	brne	.+2      	; 0x107c <xQueueIsQueueFullFromISR+0xe>
    107a:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    107c:	82 2f       	mov	r24, r18
    107e:	08 95       	ret

00001080 <prvCopyDataToQueue>:

#endif /* configUSE_TRACE_FACILITY */
/*-----------------------------------------------------------*/

static void prvCopyDataToQueue( xQUEUE *pxQueue, const void *pvItemToQueue, portBASE_TYPE xPosition )
{
    1080:	cf 93       	push	r28
    1082:	df 93       	push	r29
    1084:	ec 01       	movw	r28, r24
    1086:	84 2f       	mov	r24, r20
	if( pxQueue->uxItemSize == ( unsigned portBASE_TYPE ) 0 )
    1088:	4c 8d       	ldd	r20, Y+28	; 0x1c
    108a:	44 23       	and	r20, r20
    108c:	a1 f1       	breq	.+104    	; 0x10f6 <prvCopyDataToQueue+0x76>
				pxQueue->pxMutexHolder = NULL;
			}
		}
		#endif
	}
	else if( xPosition == queueSEND_TO_BACK )
    108e:	88 23       	and	r24, r24
    1090:	b1 f4       	brne	.+44     	; 0x10be <prvCopyDataToQueue+0x3e>
	{
		memcpy( ( void * ) pxQueue->pcWriteTo, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    1092:	8c 81       	ldd	r24, Y+4	; 0x04
    1094:	9d 81       	ldd	r25, Y+5	; 0x05
    1096:	50 e0       	ldi	r21, 0x00	; 0
    1098:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <memcpy>
		pxQueue->pcWriteTo += pxQueue->uxItemSize;
    109c:	8c 8d       	ldd	r24, Y+28	; 0x1c
    109e:	2c 81       	ldd	r18, Y+4	; 0x04
    10a0:	3d 81       	ldd	r19, Y+5	; 0x05
    10a2:	28 0f       	add	r18, r24
    10a4:	31 1d       	adc	r19, r1
    10a6:	3d 83       	std	Y+5, r19	; 0x05
    10a8:	2c 83       	std	Y+4, r18	; 0x04
		if( pxQueue->pcWriteTo >= pxQueue->pcTail )
    10aa:	8a 81       	ldd	r24, Y+2	; 0x02
    10ac:	9b 81       	ldd	r25, Y+3	; 0x03
    10ae:	28 17       	cp	r18, r24
    10b0:	39 07       	cpc	r19, r25
    10b2:	08 f1       	brcs	.+66     	; 0x10f6 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcWriteTo = pxQueue->pcHead;
    10b4:	88 81       	ld	r24, Y
    10b6:	99 81       	ldd	r25, Y+1	; 0x01
    10b8:	9d 83       	std	Y+5, r25	; 0x05
    10ba:	8c 83       	std	Y+4, r24	; 0x04
    10bc:	1c c0       	rjmp	.+56     	; 0x10f6 <prvCopyDataToQueue+0x76>
		}
	}
	else
	{
		memcpy( ( void * ) pxQueue->pcReadFrom, pvItemToQueue, ( unsigned ) pxQueue->uxItemSize );
    10be:	8e 81       	ldd	r24, Y+6	; 0x06
    10c0:	9f 81       	ldd	r25, Y+7	; 0x07
    10c2:	50 e0       	ldi	r21, 0x00	; 0
    10c4:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <memcpy>
		pxQueue->pcReadFrom -= pxQueue->uxItemSize;
    10c8:	8c 8d       	ldd	r24, Y+28	; 0x1c
    10ca:	90 e0       	ldi	r25, 0x00	; 0
    10cc:	44 27       	eor	r20, r20
    10ce:	55 27       	eor	r21, r21
    10d0:	48 1b       	sub	r20, r24
    10d2:	59 0b       	sbc	r21, r25
    10d4:	8e 81       	ldd	r24, Y+6	; 0x06
    10d6:	9f 81       	ldd	r25, Y+7	; 0x07
    10d8:	84 0f       	add	r24, r20
    10da:	95 1f       	adc	r25, r21
    10dc:	9f 83       	std	Y+7, r25	; 0x07
    10de:	8e 83       	std	Y+6, r24	; 0x06
		if( pxQueue->pcReadFrom < pxQueue->pcHead )
    10e0:	28 81       	ld	r18, Y
    10e2:	39 81       	ldd	r19, Y+1	; 0x01
    10e4:	82 17       	cp	r24, r18
    10e6:	93 07       	cpc	r25, r19
    10e8:	30 f4       	brcc	.+12     	; 0x10f6 <prvCopyDataToQueue+0x76>
		{
			pxQueue->pcReadFrom = ( pxQueue->pcTail - pxQueue->uxItemSize );
    10ea:	8a 81       	ldd	r24, Y+2	; 0x02
    10ec:	9b 81       	ldd	r25, Y+3	; 0x03
    10ee:	84 0f       	add	r24, r20
    10f0:	95 1f       	adc	r25, r21
    10f2:	9f 83       	std	Y+7, r25	; 0x07
    10f4:	8e 83       	std	Y+6, r24	; 0x06
		}
	}

	++( pxQueue->uxMessagesWaiting );
    10f6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    10f8:	8f 5f       	subi	r24, 0xFF	; 255
    10fa:	8a 8f       	std	Y+26, r24	; 0x1a
}
    10fc:	df 91       	pop	r29
    10fe:	cf 91       	pop	r28
    1100:	08 95       	ret

00001102 <xQueueCRReceiveFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceiveFromISR( xQueueHandle xQueue, void *pvBuffer, signed portBASE_TYPE *pxCoRoutineWoken )
	{
    1102:	0f 93       	push	r16
    1104:	1f 93       	push	r17
    1106:	cf 93       	push	r28
    1108:	df 93       	push	r29
    110a:	fb 01       	movw	r30, r22
    110c:	8a 01       	movw	r16, r20
	signed portBASE_TYPE xReturn;
	xQUEUE * pxQueue;

		pxQueue = ( xQUEUE * ) xQueue;
    110e:	ec 01       	movw	r28, r24

		/* We cannot block from an ISR, so check there is data available. If
		not then just leave without doing anything. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    1110:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1112:	88 23       	and	r24, r24
    1114:	61 f1       	breq	.+88     	; 0x116e <xQueueCRReceiveFromISR+0x6c>
		{
			/* Copy the data from the queue. */
			pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1116:	8c 8d       	ldd	r24, Y+28	; 0x1c
    1118:	2e 81       	ldd	r18, Y+6	; 0x06
    111a:	3f 81       	ldd	r19, Y+7	; 0x07
    111c:	28 0f       	add	r18, r24
    111e:	31 1d       	adc	r19, r1
    1120:	3f 83       	std	Y+7, r19	; 0x07
    1122:	2e 83       	std	Y+6, r18	; 0x06
			if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    1124:	8a 81       	ldd	r24, Y+2	; 0x02
    1126:	9b 81       	ldd	r25, Y+3	; 0x03
    1128:	28 17       	cp	r18, r24
    112a:	39 07       	cpc	r19, r25
    112c:	20 f0       	brcs	.+8      	; 0x1136 <xQueueCRReceiveFromISR+0x34>
			{
				pxQueue->pcReadFrom = pxQueue->pcHead;
    112e:	88 81       	ld	r24, Y
    1130:	99 81       	ldd	r25, Y+1	; 0x01
    1132:	9f 83       	std	Y+7, r25	; 0x07
    1134:	8e 83       	std	Y+6, r24	; 0x06
			}
			--( pxQueue->uxMessagesWaiting );
    1136:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1138:	81 50       	subi	r24, 0x01	; 1
    113a:	8a 8f       	std	Y+26, r24	; 0x1a
			memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    113c:	4c 8d       	ldd	r20, Y+28	; 0x1c
    113e:	6e 81       	ldd	r22, Y+6	; 0x06
    1140:	7f 81       	ldd	r23, Y+7	; 0x07
    1142:	cf 01       	movw	r24, r30
    1144:	50 e0       	ldi	r21, 0x00	; 0
    1146:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <memcpy>

			if( ( *pxCoRoutineWoken ) == pdFALSE )
    114a:	f8 01       	movw	r30, r16
    114c:	80 81       	ld	r24, Z
    114e:	88 23       	and	r24, r24
    1150:	69 f4       	brne	.+26     	; 0x116c <xQueueCRReceiveFromISR+0x6a>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1152:	88 85       	ldd	r24, Y+8	; 0x08
    1154:	88 23       	and	r24, r24
    1156:	51 f0       	breq	.+20     	; 0x116c <xQueueCRReceiveFromISR+0x6a>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1158:	ce 01       	movw	r24, r28
    115a:	08 96       	adiw	r24, 0x08	; 8
    115c:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xCoRoutineRemoveFromEventList>
    1160:	88 23       	and	r24, r24
    1162:	21 f0       	breq	.+8      	; 0x116c <xQueueCRReceiveFromISR+0x6a>
					{
						*pxCoRoutineWoken = pdTRUE;
    1164:	81 e0       	ldi	r24, 0x01	; 1
    1166:	f8 01       	movw	r30, r16
    1168:	80 83       	st	Z, r24
    116a:	01 c0       	rjmp	.+2      	; 0x116e <xQueueCRReceiveFromISR+0x6c>
    116c:	81 e0       	ldi	r24, 0x01	; 1
		{
			xReturn = pdFAIL;
		}

		return xReturn;
	}
    116e:	df 91       	pop	r29
    1170:	cf 91       	pop	r28
    1172:	1f 91       	pop	r17
    1174:	0f 91       	pop	r16
    1176:	08 95       	ret

00001178 <xQueueCRSendFromISR>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSendFromISR( xQueueHandle xQueue, const void *pvItemToQueue, signed portBASE_TYPE xCoRoutinePreviouslyWoken )
	{
    1178:	1f 93       	push	r17
    117a:	cf 93       	push	r28
    117c:	df 93       	push	r29
    117e:	14 2f       	mov	r17, r20
	xQUEUE *pxQueue;

		pxQueue = ( xQUEUE * ) xQueue;
    1180:	ec 01       	movw	r28, r24

		/* Cannot block within an ISR so if there is no space on the queue then
		exit without doing anything. */
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1182:	9a 8d       	ldd	r25, Y+26	; 0x1a
    1184:	8b 8d       	ldd	r24, Y+27	; 0x1b
    1186:	98 17       	cp	r25, r24
    1188:	88 f4       	brcc	.+34     	; 0x11ac <xQueueCRSendFromISR+0x34>
		{
			prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    118a:	ce 01       	movw	r24, r28
    118c:	40 e0       	ldi	r20, 0x00	; 0
    118e:	0e 94 40 08 	call	0x1080	; 0x1080 <prvCopyDataToQueue>

			/* We only want to wake one co-routine per ISR, so check that a
			co-routine has not already been woken. */
			if( xCoRoutinePreviouslyWoken == pdFALSE )
    1192:	11 23       	and	r17, r17
    1194:	59 f4       	brne	.+22     	; 0x11ac <xQueueCRSendFromISR+0x34>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1196:	89 89       	ldd	r24, Y+17	; 0x11
    1198:	88 23       	and	r24, r24
    119a:	41 f0       	breq	.+16     	; 0x11ac <xQueueCRSendFromISR+0x34>
				{
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    119c:	ce 01       	movw	r24, r28
    119e:	41 96       	adiw	r24, 0x11	; 17
    11a0:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xCoRoutineRemoveFromEventList>
    11a4:	48 2f       	mov	r20, r24
    11a6:	81 11       	cpse	r24, r1
    11a8:	41 e0       	ldi	r20, 0x01	; 1
    11aa:	14 2f       	mov	r17, r20
				}
			}
		}

		return xCoRoutinePreviouslyWoken;
	}
    11ac:	81 2f       	mov	r24, r17
    11ae:	df 91       	pop	r29
    11b0:	cf 91       	pop	r28
    11b2:	1f 91       	pop	r17
    11b4:	08 95       	ret

000011b6 <xQueueCRReceive>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRReceive( xQueueHandle xQueue, void *pvBuffer, portTickType xTicksToWait )
	{
    11b6:	cf 93       	push	r28
    11b8:	df 93       	push	r29
    11ba:	fb 01       	movw	r30, r22
	signed portBASE_TYPE xReturn;
	xQUEUE *pxQueue;

		pxQueue = ( xQUEUE * ) xQueue;
    11bc:	ec 01       	movw	r28, r24

		/* If the queue is already empty we may have to block.  A critical section
		is required to prevent an interrupt adding something to the queue
		between the check to see if the queue is empty and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    11be:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting == ( unsigned portBASE_TYPE ) 0 )
    11c0:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11c2:	88 23       	and	r24, r24
    11c4:	71 f4       	brne	.+28     	; 0x11e2 <xQueueCRReceive+0x2c>
			{
				/* There are no messages in the queue, do we want to block or just
				leave with nothing? */
				if( xTicksToWait > ( portTickType ) 0 )
    11c6:	41 15       	cp	r20, r1
    11c8:	51 05       	cpc	r21, r1
    11ca:	41 f0       	breq	.+16     	; 0x11dc <xQueueCRReceive+0x26>
				{
					/* As this is a co-routine we cannot block directly, but return
					indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToReceive ) );
    11cc:	61 96       	adiw	r28, 0x11	; 17
    11ce:	ca 01       	movw	r24, r20
    11d0:	be 01       	movw	r22, r28
    11d2:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    11d6:	78 94       	sei
    11d8:	8c ef       	ldi	r24, 0xFC	; 252
    11da:	2f c0       	rjmp	.+94     	; 0x123a <xQueueCRReceive+0x84>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    11dc:	78 94       	sei
    11de:	80 e0       	ldi	r24, 0x00	; 0
    11e0:	2c c0       	rjmp	.+88     	; 0x123a <xQueueCRReceive+0x84>
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
    11e2:	78 94       	sei

		portDISABLE_INTERRUPTS();
    11e4:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    11e6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    11e8:	88 23       	and	r24, r24
    11ea:	31 f1       	breq	.+76     	; 0x1238 <xQueueCRReceive+0x82>
			{
				/* Data is available from the queue. */
				pxQueue->pcReadFrom += pxQueue->uxItemSize;
    11ec:	8c 8d       	ldd	r24, Y+28	; 0x1c
    11ee:	2e 81       	ldd	r18, Y+6	; 0x06
    11f0:	3f 81       	ldd	r19, Y+7	; 0x07
    11f2:	28 0f       	add	r18, r24
    11f4:	31 1d       	adc	r19, r1
    11f6:	3f 83       	std	Y+7, r19	; 0x07
    11f8:	2e 83       	std	Y+6, r18	; 0x06
				if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    11fa:	8a 81       	ldd	r24, Y+2	; 0x02
    11fc:	9b 81       	ldd	r25, Y+3	; 0x03
    11fe:	28 17       	cp	r18, r24
    1200:	39 07       	cpc	r19, r25
    1202:	20 f0       	brcs	.+8      	; 0x120c <xQueueCRReceive+0x56>
				{
					pxQueue->pcReadFrom = pxQueue->pcHead;
    1204:	88 81       	ld	r24, Y
    1206:	99 81       	ldd	r25, Y+1	; 0x01
    1208:	9f 83       	std	Y+7, r25	; 0x07
    120a:	8e 83       	std	Y+6, r24	; 0x06
				}
				--( pxQueue->uxMessagesWaiting );
    120c:	8a 8d       	ldd	r24, Y+26	; 0x1a
    120e:	81 50       	subi	r24, 0x01	; 1
    1210:	8a 8f       	std	Y+26, r24	; 0x1a
				memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1212:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1214:	6e 81       	ldd	r22, Y+6	; 0x06
    1216:	7f 81       	ldd	r23, Y+7	; 0x07
    1218:	cf 01       	movw	r24, r30
    121a:	50 e0       	ldi	r21, 0x00	; 0
    121c:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <memcpy>

				xReturn = pdPASS;

				/* Were any co-routines waiting for space to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1220:	88 85       	ldd	r24, Y+8	; 0x08
    1222:	88 23       	and	r24, r24
    1224:	41 f0       	breq	.+16     	; 0x1236 <xQueueCRReceive+0x80>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1226:	ce 01       	movw	r24, r28
    1228:	08 96       	adiw	r24, 0x08	; 8
    122a:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xCoRoutineRemoveFromEventList>
    122e:	88 23       	and	r24, r24
    1230:	11 f0       	breq	.+4      	; 0x1236 <xQueueCRReceive+0x80>
    1232:	8b ef       	ldi	r24, 0xFB	; 251
    1234:	01 c0       	rjmp	.+2      	; 0x1238 <xQueueCRReceive+0x82>
    1236:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = pdFAIL;
			}
		}
		portENABLE_INTERRUPTS();
    1238:	78 94       	sei

		return xReturn;
	}
    123a:	df 91       	pop	r29
    123c:	cf 91       	pop	r28
    123e:	08 95       	ret

00001240 <xQueueCRSend>:
/*-----------------------------------------------------------*/

#if ( configUSE_CO_ROUTINES == 1 )

	signed portBASE_TYPE xQueueCRSend( xQueueHandle xQueue, const void *pvItemToQueue, portTickType xTicksToWait )
	{
    1240:	cf 93       	push	r28
    1242:	df 93       	push	r29
	signed portBASE_TYPE xReturn;
	xQUEUE *pxQueue;

		pxQueue = ( xQUEUE * ) xQueue;
    1244:	ec 01       	movw	r28, r24

		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
    1246:	f8 94       	cli

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1248:	0f b6       	in	r0, 0x3f	; 63
    124a:	f8 94       	cli
    124c:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    124e:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1250:	9b 8d       	ldd	r25, Y+27	; 0x1b
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1252:	0f 90       	pop	r0
    1254:	0f be       	out	0x3f, r0	; 63
		/* If the queue is already full we may have to block.  A critical section
		is required to prevent an interrupt removing something from the queue
		between the check to see if the queue is full and blocking on the queue. */
		portDISABLE_INTERRUPTS();
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    1256:	89 17       	cp	r24, r25
    1258:	71 f4       	brne	.+28     	; 0x1276 <xQueueCRSend+0x36>
			{
				/* The queue is full - do we want to block or just leave without
				posting? */
				if( xTicksToWait > ( portTickType ) 0 )
    125a:	41 15       	cp	r20, r1
    125c:	51 05       	cpc	r21, r1
    125e:	41 f0       	breq	.+16     	; 0x1270 <xQueueCRSend+0x30>
				{
					/* As this is called from a coroutine we cannot block directly, but
					return indicating that we need to block. */
					vCoRoutineAddToDelayedList( xTicksToWait, &( pxQueue->xTasksWaitingToSend ) );
    1260:	28 96       	adiw	r28, 0x08	; 8
    1262:	ca 01       	movw	r24, r20
    1264:	be 01       	movw	r22, r28
    1266:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vCoRoutineAddToDelayedList>
					portENABLE_INTERRUPTS();
    126a:	78 94       	sei
    126c:	8c ef       	ldi	r24, 0xFC	; 252
    126e:	1b c0       	rjmp	.+54     	; 0x12a6 <xQueueCRSend+0x66>
					return errQUEUE_BLOCKED;
				}
				else
				{
					portENABLE_INTERRUPTS();
    1270:	78 94       	sei
    1272:	80 e0       	ldi	r24, 0x00	; 0
    1274:	18 c0       	rjmp	.+48     	; 0x12a6 <xQueueCRSend+0x66>
					return errQUEUE_FULL;
				}
			}
		}
		portENABLE_INTERRUPTS();
    1276:	78 94       	sei

		portDISABLE_INTERRUPTS();
    1278:	f8 94       	cli
		{
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    127a:	8a 8d       	ldd	r24, Y+26	; 0x1a
    127c:	89 17       	cp	r24, r25
    127e:	10 f0       	brcs	.+4      	; 0x1284 <xQueueCRSend+0x44>
    1280:	80 e0       	ldi	r24, 0x00	; 0
    1282:	10 c0       	rjmp	.+32     	; 0x12a4 <xQueueCRSend+0x64>
			{
				/* There is room in the queue, copy the data into the queue. */
				prvCopyDataToQueue( pxQueue, pvItemToQueue, queueSEND_TO_BACK );
    1284:	ce 01       	movw	r24, r28
    1286:	40 e0       	ldi	r20, 0x00	; 0
    1288:	0e 94 40 08 	call	0x1080	; 0x1080 <prvCopyDataToQueue>
				xReturn = pdPASS;

				/* Were any co-routines waiting for data to become available? */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    128c:	89 89       	ldd	r24, Y+17	; 0x11
    128e:	88 23       	and	r24, r24
    1290:	41 f0       	breq	.+16     	; 0x12a2 <xQueueCRSend+0x62>
				{
					/* In this instance the co-routine could be placed directly
					into the ready list as we are within a critical section.
					Instead the same pending ready list mechanism is used as if
					the event were caused from within an interrupt. */
					if( xCoRoutineRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    1292:	ce 01       	movw	r24, r28
    1294:	41 96       	adiw	r24, 0x11	; 17
    1296:	0e 94 8c 0c 	call	0x1918	; 0x1918 <xCoRoutineRemoveFromEventList>
    129a:	88 23       	and	r24, r24
    129c:	11 f0       	breq	.+4      	; 0x12a2 <xQueueCRSend+0x62>
    129e:	8b ef       	ldi	r24, 0xFB	; 251
    12a0:	01 c0       	rjmp	.+2      	; 0x12a4 <xQueueCRSend+0x64>
    12a2:	81 e0       	ldi	r24, 0x01	; 1
			else
			{
				xReturn = errQUEUE_FULL;
			}
		}
		portENABLE_INTERRUPTS();
    12a4:	78 94       	sei

		return xReturn;
	}
    12a6:	df 91       	pop	r29
    12a8:	cf 91       	pop	r28
    12aa:	08 95       	ret

000012ac <vQueueDelete>:
	return uxReturn;
}
/*-----------------------------------------------------------*/

void vQueueDelete( xQueueHandle xQueue )
{
    12ac:	0f 93       	push	r16
    12ae:	1f 93       	push	r17
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    12b0:	8c 01       	movw	r16, r24
	#if ( configQUEUE_REGISTRY_SIZE > 0 )
	{
		prvQueueUnregisterQueue( pxQueue );
	}
	#endif
	vPortFree( pxQueue->pcHead );
    12b2:	fc 01       	movw	r30, r24
    12b4:	80 81       	ld	r24, Z
    12b6:	91 81       	ldd	r25, Z+1	; 0x01
    12b8:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vPortFree>
	vPortFree( pxQueue );
    12bc:	c8 01       	movw	r24, r16
    12be:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vPortFree>
}
    12c2:	1f 91       	pop	r17
    12c4:	0f 91       	pop	r16
    12c6:	08 95       	ret

000012c8 <xQueueReceiveFromISR>:
	}
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueReceiveFromISR( xQueueHandle xQueue, void * const pvBuffer, signed portBASE_TYPE *pxHigherPriorityTaskWoken )
{
    12c8:	0f 93       	push	r16
    12ca:	1f 93       	push	r17
    12cc:	cf 93       	push	r28
    12ce:	df 93       	push	r29
    12d0:	fb 01       	movw	r30, r22
    12d2:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    12d4:	ec 01       	movw	r28, r24
	configASSERT( !( ( pvBuffer == NULL ) && ( pxQueue->uxItemSize != ( unsigned portBASE_TYPE ) 0U ) ) );

	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		/* We cannot block from an ISR, so check there is data available. */
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    12d6:	8a 8d       	ldd	r24, Y+26	; 0x1a
    12d8:	88 23       	and	r24, r24
    12da:	a1 f1       	breq	.+104    	; 0x1344 <xQueueReceiveFromISR+0x7c>
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    12dc:	48 81       	ld	r20, Y
    12de:	59 81       	ldd	r21, Y+1	; 0x01
    12e0:	41 15       	cp	r20, r1
    12e2:	51 05       	cpc	r21, r1
    12e4:	a9 f0       	breq	.+42     	; 0x1310 <xQueueReceiveFromISR+0x48>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    12e6:	8c 8d       	ldd	r24, Y+28	; 0x1c
    12e8:	2e 81       	ldd	r18, Y+6	; 0x06
    12ea:	3f 81       	ldd	r19, Y+7	; 0x07
    12ec:	28 0f       	add	r18, r24
    12ee:	31 1d       	adc	r19, r1
    12f0:	3f 83       	std	Y+7, r19	; 0x07
    12f2:	2e 83       	std	Y+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    12f4:	8a 81       	ldd	r24, Y+2	; 0x02
    12f6:	9b 81       	ldd	r25, Y+3	; 0x03
    12f8:	28 17       	cp	r18, r24
    12fa:	39 07       	cpc	r19, r25
    12fc:	10 f0       	brcs	.+4      	; 0x1302 <xQueueReceiveFromISR+0x3a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    12fe:	5f 83       	std	Y+7, r21	; 0x07
    1300:	4e 83       	std	Y+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    1302:	4c 8d       	ldd	r20, Y+28	; 0x1c
    1304:	6e 81       	ldd	r22, Y+6	; 0x06
    1306:	7f 81       	ldd	r23, Y+7	; 0x07
    1308:	cf 01       	movw	r24, r30
    130a:	50 e0       	ldi	r21, 0x00	; 0
    130c:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <memcpy>
		if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
		{
			traceQUEUE_RECEIVE_FROM_ISR( pxQueue );

			prvCopyDataFromQueue( pxQueue, pvBuffer );
			--( pxQueue->uxMessagesWaiting );
    1310:	8a 8d       	ldd	r24, Y+26	; 0x1a
    1312:	81 50       	subi	r24, 0x01	; 1
    1314:	8a 8f       	std	Y+26, r24	; 0x1a

			/* If the queue is locked we will not modify the event list.  Instead
			we update the lock count so the task that unlocks the queue will know
			that an ISR has removed data while the queue was locked. */
			if( pxQueue->xRxLock == queueUNLOCKED )
    1316:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1318:	8f 3f       	cpi	r24, 0xFF	; 255
    131a:	81 f4       	brne	.+32     	; 0x133c <xQueueReceiveFromISR+0x74>
			{
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    131c:	88 85       	ldd	r24, Y+8	; 0x08
    131e:	88 23       	and	r24, r24
    1320:	81 f0       	breq	.+32     	; 0x1342 <xQueueReceiveFromISR+0x7a>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    1322:	ce 01       	movw	r24, r28
    1324:	08 96       	adiw	r24, 0x08	; 8
    1326:	0e 94 31 04 	call	0x862	; 0x862 <xTaskRemoveFromEventList>
    132a:	88 23       	and	r24, r24
    132c:	51 f0       	breq	.+20     	; 0x1342 <xQueueReceiveFromISR+0x7a>
					{
						/* The task waiting has a higher priority than us so
						force a context switch. */
						if( pxHigherPriorityTaskWoken != NULL )
    132e:	01 15       	cp	r16, r1
    1330:	11 05       	cpc	r17, r1
    1332:	39 f0       	breq	.+14     	; 0x1342 <xQueueReceiveFromISR+0x7a>
						{
							*pxHigherPriorityTaskWoken = pdTRUE;
    1334:	81 e0       	ldi	r24, 0x01	; 1
    1336:	f8 01       	movw	r30, r16
    1338:	80 83       	st	Z, r24
    133a:	04 c0       	rjmp	.+8      	; 0x1344 <xQueueReceiveFromISR+0x7c>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was removed while it was locked. */
				++( pxQueue->xRxLock );
    133c:	8d 8d       	ldd	r24, Y+29	; 0x1d
    133e:	8f 5f       	subi	r24, 0xFF	; 255
    1340:	8d 8f       	std	Y+29, r24	; 0x1d
    1342:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    1344:	df 91       	pop	r29
    1346:	cf 91       	pop	r28
    1348:	1f 91       	pop	r17
    134a:	0f 91       	pop	r16
    134c:	08 95       	ret

0000134e <xQueueGenericSendFromISR>:

#endif /* configUSE_ALTERNATIVE_API */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSendFromISR( xQueueHandle xQueue, const void * const pvItemToQueue, signed portBASE_TYPE *pxHigherPriorityTaskWoken, portBASE_TYPE xCopyPosition )
{
    134e:	0f 93       	push	r16
    1350:	1f 93       	push	r17
    1352:	cf 93       	push	r28
    1354:	df 93       	push	r29
    1356:	8a 01       	movw	r16, r20
signed portBASE_TYPE xReturn;
unsigned portBASE_TYPE uxSavedInterruptStatus;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    1358:	ec 01       	movw	r28, r24
	queue read, instead we return a flag to say whether a context switch is
	required or not (i.e. has a task with a higher priority than us been woken
	by this	post). */
	uxSavedInterruptStatus = portSET_INTERRUPT_MASK_FROM_ISR();
	{
		if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    135a:	9a 8d       	ldd	r25, Y+26	; 0x1a
    135c:	8b 8d       	ldd	r24, Y+27	; 0x1b
    135e:	98 17       	cp	r25, r24
    1360:	10 f0       	brcs	.+4      	; 0x1366 <xQueueGenericSendFromISR+0x18>
    1362:	80 e0       	ldi	r24, 0x00	; 0
    1364:	1b c0       	rjmp	.+54     	; 0x139c <xQueueGenericSendFromISR+0x4e>
		{
			traceQUEUE_SEND_FROM_ISR( pxQueue );

			prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    1366:	ce 01       	movw	r24, r28
    1368:	42 2f       	mov	r20, r18
    136a:	0e 94 40 08 	call	0x1080	; 0x1080 <prvCopyDataToQueue>

			/* If the queue is locked we do not alter the event list.  This will
			be done when the queue is unlocked later. */
			if( pxQueue->xTxLock == queueUNLOCKED )
    136e:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1370:	8f 3f       	cpi	r24, 0xFF	; 255
    1372:	81 f4       	brne	.+32     	; 0x1394 <xQueueGenericSendFromISR+0x46>
						}
					}
				}
				#else /* configUSE_QUEUE_SETS */
				{
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1374:	89 89       	ldd	r24, Y+17	; 0x11
    1376:	88 23       	and	r24, r24
    1378:	81 f0       	breq	.+32     	; 0x139a <xQueueGenericSendFromISR+0x4c>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    137a:	ce 01       	movw	r24, r28
    137c:	41 96       	adiw	r24, 0x11	; 17
    137e:	0e 94 31 04 	call	0x862	; 0x862 <xTaskRemoveFromEventList>
    1382:	88 23       	and	r24, r24
    1384:	51 f0       	breq	.+20     	; 0x139a <xQueueGenericSendFromISR+0x4c>
						{
							/* The task waiting has a higher priority so record that a
							context	switch is required. */
							if( pxHigherPriorityTaskWoken != NULL )
    1386:	01 15       	cp	r16, r1
    1388:	11 05       	cpc	r17, r1
    138a:	39 f0       	breq	.+14     	; 0x139a <xQueueGenericSendFromISR+0x4c>
							{
								*pxHigherPriorityTaskWoken = pdTRUE;
    138c:	81 e0       	ldi	r24, 0x01	; 1
    138e:	f8 01       	movw	r30, r16
    1390:	80 83       	st	Z, r24
    1392:	04 c0       	rjmp	.+8      	; 0x139c <xQueueGenericSendFromISR+0x4e>
			}
			else
			{
				/* Increment the lock count so the task that unlocks the queue
				knows that data was posted while it was locked. */
				++( pxQueue->xTxLock );
    1394:	8e 8d       	ldd	r24, Y+30	; 0x1e
    1396:	8f 5f       	subi	r24, 0xFF	; 255
    1398:	8e 8f       	std	Y+30, r24	; 0x1e
    139a:	81 e0       	ldi	r24, 0x01	; 1
		}
	}
	portCLEAR_INTERRUPT_MASK_FROM_ISR( uxSavedInterruptStatus );

	return xReturn;
}
    139c:	df 91       	pop	r29
    139e:	cf 91       	pop	r28
    13a0:	1f 91       	pop	r17
    13a2:	0f 91       	pop	r16
    13a4:	08 95       	ret

000013a6 <prvUnlockQueue>:
	}
}
/*-----------------------------------------------------------*/

static void prvUnlockQueue( xQUEUE *pxQueue )
{
    13a6:	0f 93       	push	r16
    13a8:	1f 93       	push	r17
    13aa:	cf 93       	push	r28
    13ac:	df 93       	push	r29
    13ae:	ec 01       	movw	r28, r24

	/* The lock counts contains the number of extra data items placed or
	removed from the queue while the queue was locked.  When a queue is
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
    13b0:	0f b6       	in	r0, 0x3f	; 63
    13b2:	f8 94       	cli
    13b4:	0f 92       	push	r0
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13b6:	8c 01       	movw	r16, r24
    13b8:	0f 5e       	subi	r16, 0xEF	; 239
    13ba:	1f 4f       	sbci	r17, 0xFF	; 255
    13bc:	0d c0       	rjmp	.+26     	; 0x13d8 <prvUnlockQueue+0x32>
			}
			#else /* configUSE_QUEUE_SETS */
			{
				/* Tasks that are removed from the event list will get added to
				the pending ready list as the scheduler is still suspended. */
				if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    13be:	89 89       	ldd	r24, Y+17	; 0x11
    13c0:	88 23       	and	r24, r24
    13c2:	69 f0       	breq	.+26     	; 0x13de <prvUnlockQueue+0x38>
				{
					if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    13c4:	c8 01       	movw	r24, r16
    13c6:	0e 94 31 04 	call	0x862	; 0x862 <xTaskRemoveFromEventList>
    13ca:	88 23       	and	r24, r24
    13cc:	11 f0       	breq	.+4      	; 0x13d2 <prvUnlockQueue+0x2c>
					{
						/* The task waiting has a higher priority so record that a
						context	switch is required. */
						vTaskMissedYield();
    13ce:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskMissedYield>
					break;
				}
			}
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
    13d2:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13d4:	81 50       	subi	r24, 0x01	; 1
    13d6:	8e 8f       	std	Y+30, r24	; 0x1e
	locked items can be added or removed, but the event lists cannot be
	updated. */
	taskENTER_CRITICAL();
	{
		/* See if data was added to the queue while it was locked. */
		while( pxQueue->xTxLock > queueLOCKED_UNMODIFIED )
    13d8:	8e 8d       	ldd	r24, Y+30	; 0x1e
    13da:	18 16       	cp	r1, r24
    13dc:	84 f3       	brlt	.-32     	; 0x13be <prvUnlockQueue+0x18>
			#endif /* configUSE_QUEUE_SETS */

			--( pxQueue->xTxLock );
		}

		pxQueue->xTxLock = queueUNLOCKED;
    13de:	8f ef       	ldi	r24, 0xFF	; 255
    13e0:	8e 8f       	std	Y+30, r24	; 0x1e
	}
	taskEXIT_CRITICAL();
    13e2:	0f 90       	pop	r0
    13e4:	0f be       	out	0x3f, r0	; 63

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
    13e6:	0f b6       	in	r0, 0x3f	; 63
    13e8:	f8 94       	cli
    13ea:	0f 92       	push	r0
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13ec:	8e 01       	movw	r16, r28
    13ee:	08 5f       	subi	r16, 0xF8	; 248
    13f0:	1f 4f       	sbci	r17, 0xFF	; 255
    13f2:	0d c0       	rjmp	.+26     	; 0x140e <prvUnlockQueue+0x68>
	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
		{
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    13f4:	88 85       	ldd	r24, Y+8	; 0x08
    13f6:	88 23       	and	r24, r24
    13f8:	69 f0       	breq	.+26     	; 0x1414 <prvUnlockQueue+0x6e>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) != pdFALSE )
    13fa:	c8 01       	movw	r24, r16
    13fc:	0e 94 31 04 	call	0x862	; 0x862 <xTaskRemoveFromEventList>
    1400:	88 23       	and	r24, r24
    1402:	11 f0       	breq	.+4      	; 0x1408 <prvUnlockQueue+0x62>
				{
					vTaskMissedYield();
    1404:	0e 94 2d 04 	call	0x85a	; 0x85a <vTaskMissedYield>
				}

				--( pxQueue->xRxLock );
    1408:	8d 8d       	ldd	r24, Y+29	; 0x1d
    140a:	81 50       	subi	r24, 0x01	; 1
    140c:	8d 8f       	std	Y+29, r24	; 0x1d
	taskEXIT_CRITICAL();

	/* Do the same for the Rx lock. */
	taskENTER_CRITICAL();
	{
		while( pxQueue->xRxLock > queueLOCKED_UNMODIFIED )
    140e:	8d 8d       	ldd	r24, Y+29	; 0x1d
    1410:	18 16       	cp	r1, r24
    1412:	84 f3       	brlt	.-32     	; 0x13f4 <prvUnlockQueue+0x4e>
			{
				break;
			}
		}

		pxQueue->xRxLock = queueUNLOCKED;
    1414:	8f ef       	ldi	r24, 0xFF	; 255
    1416:	8d 8f       	std	Y+29, r24	; 0x1d
	}
	taskEXIT_CRITICAL();
    1418:	0f 90       	pop	r0
    141a:	0f be       	out	0x3f, r0	; 63
}
    141c:	df 91       	pop	r29
    141e:	cf 91       	pop	r28
    1420:	1f 91       	pop	r17
    1422:	0f 91       	pop	r16
    1424:	08 95       	ret

00001426 <xQueueGenericReceive>:
	return xReturn;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericReceive( xQueueHandle xQueue, void * const pvBuffer, portTickType xTicksToWait, portBASE_TYPE xJustPeeking )
{
    1426:	7f 92       	push	r7
    1428:	8f 92       	push	r8
    142a:	9f 92       	push	r9
    142c:	af 92       	push	r10
    142e:	bf 92       	push	r11
    1430:	cf 92       	push	r12
    1432:	df 92       	push	r13
    1434:	ef 92       	push	r14
    1436:	ff 92       	push	r15
    1438:	0f 93       	push	r16
    143a:	1f 93       	push	r17
    143c:	df 93       	push	r29
    143e:	cf 93       	push	r28
    1440:	00 d0       	rcall	.+0      	; 0x1442 <xQueueGenericReceive+0x1c>
    1442:	00 d0       	rcall	.+0      	; 0x1444 <xQueueGenericReceive+0x1e>
    1444:	0f 92       	push	r0
    1446:	cd b7       	in	r28, 0x3d	; 61
    1448:	de b7       	in	r29, 0x3e	; 62
    144a:	96 2e       	mov	r9, r22
    144c:	87 2e       	mov	r8, r23
    144e:	5d 83       	std	Y+5, r21	; 0x05
    1450:	4c 83       	std	Y+4, r20	; 0x04
    1452:	72 2e       	mov	r7, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
signed char *pcOriginalReadPosition;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    1454:	8c 01       	movw	r16, r24
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1456:	91 e1       	ldi	r25, 0x11	; 17
    1458:	c9 2e       	mov	r12, r25
    145a:	d1 2c       	mov	r13, r1
    145c:	c0 0e       	add	r12, r16
    145e:	d1 1e       	adc	r13, r17
    1460:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1462:	7e 01       	movw	r14, r28
    1464:	08 94       	sec
    1466:	e1 1c       	adc	r14, r1
    1468:	f1 1c       	adc	r15, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    146a:	84 e0       	ldi	r24, 0x04	; 4
    146c:	a8 2e       	mov	r10, r24
    146e:	b1 2c       	mov	r11, r1
    1470:	ac 0e       	add	r10, r28
    1472:	bd 1e       	adc	r11, r29
    1474:	01 c0       	rjmp	.+2      	; 0x1478 <xQueueGenericReceive+0x52>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1476:	21 e0       	ldi	r18, 0x01	; 1
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */

	for( ;; )
	{
		taskENTER_CRITICAL();
    1478:	0f b6       	in	r0, 0x3f	; 63
    147a:	f8 94       	cli
    147c:	0f 92       	push	r0
		{
			/* Is there data in the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting > ( unsigned portBASE_TYPE ) 0 )
    147e:	f8 01       	movw	r30, r16
    1480:	82 8d       	ldd	r24, Z+26	; 0x1a
    1482:	88 23       	and	r24, r24
    1484:	09 f4       	brne	.+2      	; 0x1488 <xQueueGenericReceive+0x62>
    1486:	3e c0       	rjmp	.+124    	; 0x1504 <xQueueGenericReceive+0xde>
			{
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;
    1488:	e6 80       	ldd	r14, Z+6	; 0x06
    148a:	f7 80       	ldd	r15, Z+7	; 0x07
}
/*-----------------------------------------------------------*/

static void prvCopyDataFromQueue( xQUEUE * const pxQueue, const void *pvBuffer )
{
	if( pxQueue->uxQueueType != queueQUEUE_IS_MUTEX )
    148c:	40 81       	ld	r20, Z
    148e:	51 81       	ldd	r21, Z+1	; 0x01
    1490:	41 15       	cp	r20, r1
    1492:	51 05       	cpc	r21, r1
    1494:	b1 f0       	breq	.+44     	; 0x14c2 <xQueueGenericReceive+0x9c>
	{
		pxQueue->pcReadFrom += pxQueue->uxItemSize;
    1496:	84 8d       	ldd	r24, Z+28	; 0x1c
    1498:	97 01       	movw	r18, r14
    149a:	28 0f       	add	r18, r24
    149c:	31 1d       	adc	r19, r1
    149e:	37 83       	std	Z+7, r19	; 0x07
    14a0:	26 83       	std	Z+6, r18	; 0x06
		if( pxQueue->pcReadFrom >= pxQueue->pcTail )
    14a2:	82 81       	ldd	r24, Z+2	; 0x02
    14a4:	93 81       	ldd	r25, Z+3	; 0x03
    14a6:	28 17       	cp	r18, r24
    14a8:	39 07       	cpc	r19, r25
    14aa:	10 f0       	brcs	.+4      	; 0x14b0 <xQueueGenericReceive+0x8a>
		{
			pxQueue->pcReadFrom = pxQueue->pcHead;
    14ac:	57 83       	std	Z+7, r21	; 0x07
    14ae:	46 83       	std	Z+6, r20	; 0x06
		}
		memcpy( ( void * ) pvBuffer, ( void * ) pxQueue->pcReadFrom, ( unsigned ) pxQueue->uxItemSize );
    14b0:	f8 01       	movw	r30, r16
    14b2:	44 8d       	ldd	r20, Z+28	; 0x1c
    14b4:	66 81       	ldd	r22, Z+6	; 0x06
    14b6:	77 81       	ldd	r23, Z+7	; 0x07
    14b8:	89 2d       	mov	r24, r9
    14ba:	98 2d       	mov	r25, r8
    14bc:	50 e0       	ldi	r21, 0x00	; 0
    14be:	0e 94 f8 12 	call	0x25f0	; 0x25f0 <memcpy>
				/* Remember our read position in case we are just peeking. */
				pcOriginalReadPosition = pxQueue->pcReadFrom;

				prvCopyDataFromQueue( pxQueue, pvBuffer );

				if( xJustPeeking == pdFALSE )
    14c2:	77 20       	and	r7, r7
    14c4:	71 f4       	brne	.+28     	; 0x14e2 <xQueueGenericReceive+0xbc>
				{
					traceQUEUE_RECEIVE( pxQueue );

					/* We are actually removing data. */
					--( pxQueue->uxMessagesWaiting );
    14c6:	f8 01       	movw	r30, r16
    14c8:	82 8d       	ldd	r24, Z+26	; 0x1a
    14ca:	81 50       	subi	r24, 0x01	; 1
    14cc:	82 8f       	std	Z+26, r24	; 0x1a
							pxQueue->pxMutexHolder = xTaskGetCurrentTaskHandle();
						}
					}
					#endif

					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    14ce:	80 85       	ldd	r24, Z+8	; 0x08
    14d0:	88 23       	and	r24, r24
    14d2:	a1 f0       	breq	.+40     	; 0x14fc <xQueueGenericReceive+0xd6>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    14d4:	c8 01       	movw	r24, r16
    14d6:	08 96       	adiw	r24, 0x08	; 8
    14d8:	0e 94 31 04 	call	0x862	; 0x862 <xTaskRemoveFromEventList>
    14dc:	81 30       	cpi	r24, 0x01	; 1
    14de:	71 f4       	brne	.+28     	; 0x14fc <xQueueGenericReceive+0xd6>
    14e0:	0b c0       	rjmp	.+22     	; 0x14f8 <xQueueGenericReceive+0xd2>
				{
					traceQUEUE_PEEK( pxQueue );

					/* The data is not being removed, so reset the read
					pointer. */
					pxQueue->pcReadFrom = pcOriginalReadPosition;
    14e2:	f8 01       	movw	r30, r16
    14e4:	f7 82       	std	Z+7, r15	; 0x07
    14e6:	e6 82       	std	Z+6, r14	; 0x06

					/* The data is being left in the queue, so see if there are
					any other tasks waiting for the data. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    14e8:	81 89       	ldd	r24, Z+17	; 0x11
    14ea:	88 23       	and	r24, r24
    14ec:	39 f0       	breq	.+14     	; 0x14fc <xQueueGenericReceive+0xd6>
					{
						/* Tasks that are removed from the event list will get added to
						the pending ready list as the scheduler is still suspended. */
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) != pdFALSE )
    14ee:	c6 01       	movw	r24, r12
    14f0:	0e 94 31 04 	call	0x862	; 0x862 <xTaskRemoveFromEventList>
    14f4:	88 23       	and	r24, r24
    14f6:	11 f0       	breq	.+4      	; 0x14fc <xQueueGenericReceive+0xd6>
						{
							/* The task waiting has a higher priority than this task. */
							portYIELD_WITHIN_API();
    14f8:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
						}
					}
				}

				taskEXIT_CRITICAL();
    14fc:	0f 90       	pop	r0
    14fe:	0f be       	out	0x3f, r0	; 63
    1500:	81 e0       	ldi	r24, 0x01	; 1
    1502:	4a c0       	rjmp	.+148    	; 0x1598 <xQueueGenericReceive+0x172>
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1504:	8c 81       	ldd	r24, Y+4	; 0x04
    1506:	9d 81       	ldd	r25, Y+5	; 0x05
    1508:	89 2b       	or	r24, r25
    150a:	19 f4       	brne	.+6      	; 0x1512 <xQueueGenericReceive+0xec>
				{
					/* The queue was empty and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    150c:	0f 90       	pop	r0
    150e:	0f be       	out	0x3f, r0	; 63
    1510:	42 c0       	rjmp	.+132    	; 0x1596 <xQueueGenericReceive+0x170>
					traceQUEUE_RECEIVE_FAILED( pxQueue );
					return errQUEUE_EMPTY;
				}
				else if( xEntryTimeSet == pdFALSE )
    1512:	22 23       	and	r18, r18
    1514:	19 f4       	brne	.+6      	; 0x151c <xQueueGenericReceive+0xf6>
				{
					/* The queue was empty and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    1516:	c7 01       	movw	r24, r14
    1518:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    151c:	0f 90       	pop	r0
    151e:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1520:	0e 94 8c 03 	call	0x718	; 0x718 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1524:	0f b6       	in	r0, 0x3f	; 63
    1526:	f8 94       	cli
    1528:	0f 92       	push	r0
    152a:	f8 01       	movw	r30, r16
    152c:	85 8d       	ldd	r24, Z+29	; 0x1d
    152e:	8f 3f       	cpi	r24, 0xFF	; 255
    1530:	09 f4       	brne	.+2      	; 0x1534 <xQueueGenericReceive+0x10e>
    1532:	15 8e       	std	Z+29, r1	; 0x1d
    1534:	f8 01       	movw	r30, r16
    1536:	86 8d       	ldd	r24, Z+30	; 0x1e
    1538:	8f 3f       	cpi	r24, 0xFF	; 255
    153a:	09 f4       	brne	.+2      	; 0x153e <xQueueGenericReceive+0x118>
    153c:	16 8e       	std	Z+30, r1	; 0x1e
    153e:	0f 90       	pop	r0
    1540:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1542:	c7 01       	movw	r24, r14
    1544:	b5 01       	movw	r22, r10
    1546:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <xTaskCheckForTimeOut>
    154a:	88 23       	and	r24, r24
    154c:	f9 f4       	brne	.+62     	; 0x158c <xQueueGenericReceive+0x166>

static signed portBASE_TYPE prvIsQueueEmpty( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    154e:	0f b6       	in	r0, 0x3f	; 63
    1550:	f8 94       	cli
    1552:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == 0 )
    1554:	f8 01       	movw	r30, r16
    1556:	82 8d       	ldd	r24, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    1558:	0f 90       	pop	r0
    155a:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueEmpty( pxQueue ) != pdFALSE )
    155c:	88 23       	and	r24, r24
    155e:	81 f4       	brne	.+32     	; 0x1580 <xQueueGenericReceive+0x15a>
						portEXIT_CRITICAL();
					}
				}
				#endif

				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToReceive ), xTicksToWait );
    1560:	6c 81       	ldd	r22, Y+4	; 0x04
    1562:	7d 81       	ldd	r23, Y+5	; 0x05
    1564:	c6 01       	movw	r24, r12
    1566:	0e 94 4b 05 	call	0xa96	; 0xa96 <vTaskPlaceOnEventList>
				prvUnlockQueue( pxQueue );
    156a:	c8 01       	movw	r24, r16
    156c:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <prvUnlockQueue>
				if( xTaskResumeAll() == pdFALSE )
    1570:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
    1574:	88 23       	and	r24, r24
    1576:	09 f0       	breq	.+2      	; 0x157a <xQueueGenericReceive+0x154>
    1578:	7e cf       	rjmp	.-260    	; 0x1476 <xQueueGenericReceive+0x50>
				{
					portYIELD_WITHIN_API();
    157a:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
    157e:	7b cf       	rjmp	.-266    	; 0x1476 <xQueueGenericReceive+0x50>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    1580:	c8 01       	movw	r24, r16
    1582:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    1586:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
    158a:	75 cf       	rjmp	.-278    	; 0x1476 <xQueueGenericReceive+0x50>
			}
		}
		else
		{
			prvUnlockQueue( pxQueue );
    158c:	c8 01       	movw	r24, r16
    158e:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    1592:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
    1596:	80 e0       	ldi	r24, 0x00	; 0
			traceQUEUE_RECEIVE_FAILED( pxQueue );
			return errQUEUE_EMPTY;
		}
	}
}
    1598:	0f 90       	pop	r0
    159a:	0f 90       	pop	r0
    159c:	0f 90       	pop	r0
    159e:	0f 90       	pop	r0
    15a0:	0f 90       	pop	r0
    15a2:	cf 91       	pop	r28
    15a4:	df 91       	pop	r29
    15a6:	1f 91       	pop	r17
    15a8:	0f 91       	pop	r16
    15aa:	ff 90       	pop	r15
    15ac:	ef 90       	pop	r14
    15ae:	df 90       	pop	r13
    15b0:	cf 90       	pop	r12
    15b2:	bf 90       	pop	r11
    15b4:	af 90       	pop	r10
    15b6:	9f 90       	pop	r9
    15b8:	8f 90       	pop	r8
    15ba:	7f 90       	pop	r7
    15bc:	08 95       	ret

000015be <xQueueGenericSend>:

#endif /* configUSE_COUNTING_SEMAPHORES */
/*-----------------------------------------------------------*/

signed portBASE_TYPE xQueueGenericSend( xQueueHandle xQueue, const void * const pvItemToQueue, portTickType xTicksToWait, portBASE_TYPE xCopyPosition )
{
    15be:	7f 92       	push	r7
    15c0:	8f 92       	push	r8
    15c2:	9f 92       	push	r9
    15c4:	af 92       	push	r10
    15c6:	bf 92       	push	r11
    15c8:	cf 92       	push	r12
    15ca:	df 92       	push	r13
    15cc:	ef 92       	push	r14
    15ce:	ff 92       	push	r15
    15d0:	0f 93       	push	r16
    15d2:	1f 93       	push	r17
    15d4:	df 93       	push	r29
    15d6:	cf 93       	push	r28
    15d8:	00 d0       	rcall	.+0      	; 0x15da <xQueueGenericSend+0x1c>
    15da:	00 d0       	rcall	.+0      	; 0x15dc <xQueueGenericSend+0x1e>
    15dc:	0f 92       	push	r0
    15de:	cd b7       	in	r28, 0x3d	; 61
    15e0:	de b7       	in	r29, 0x3e	; 62
    15e2:	6b 01       	movw	r12, r22
    15e4:	5d 83       	std	Y+5, r21	; 0x05
    15e6:	4c 83       	std	Y+4, r20	; 0x04
    15e8:	72 2e       	mov	r7, r18
signed portBASE_TYPE xEntryTimeSet = pdFALSE;
xTimeOutType xTimeOut;
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    15ea:	8c 01       	movw	r16, r24
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    15ec:	48 e0       	ldi	r20, 0x08	; 8
    15ee:	e4 2e       	mov	r14, r20
    15f0:	f1 2c       	mov	r15, r1
    15f2:	e8 0e       	add	r14, r24
    15f4:	f9 1e       	adc	r15, r25
    15f6:	20 e0       	ldi	r18, 0x00	; 0
				}
				else if( xEntryTimeSet == pdFALSE )
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    15f8:	5e 01       	movw	r10, r28
    15fa:	08 94       	sec
    15fc:	a1 1c       	adc	r10, r1
    15fe:	b1 1c       	adc	r11, r1

		vTaskSuspendAll();
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1600:	34 e0       	ldi	r19, 0x04	; 4
    1602:	83 2e       	mov	r8, r19
    1604:	91 2c       	mov	r9, r1
    1606:	8c 0e       	add	r8, r28
    1608:	9d 1e       	adc	r9, r29
    160a:	01 c0       	rjmp	.+2      	; 0x160e <xQueueGenericSend+0x50>
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    160c:	21 e0       	ldi	r18, 0x01	; 1
	/* This function relaxes the coding standard somewhat to allow return
	statements within the function itself.  This is done in the interest
	of execution time efficiency. */
	for( ;; )
	{
		taskENTER_CRITICAL();
    160e:	0f b6       	in	r0, 0x3f	; 63
    1610:	f8 94       	cli
    1612:	0f 92       	push	r0
		{
			/* Is there room on the queue now?  To be running we must be
			the highest priority task wanting to access the queue. */
			if( pxQueue->uxMessagesWaiting < pxQueue->uxLength )
    1614:	f8 01       	movw	r30, r16
    1616:	92 8d       	ldd	r25, Z+26	; 0x1a
    1618:	83 8d       	ldd	r24, Z+27	; 0x1b
    161a:	98 17       	cp	r25, r24
    161c:	a8 f4       	brcc	.+42     	; 0x1648 <xQueueGenericSend+0x8a>
			{
				traceQUEUE_SEND( pxQueue );
				prvCopyDataToQueue( pxQueue, pvItemToQueue, xCopyPosition );
    161e:	c8 01       	movw	r24, r16
    1620:	b6 01       	movw	r22, r12
    1622:	47 2d       	mov	r20, r7
    1624:	0e 94 40 08 	call	0x1080	; 0x1080 <prvCopyDataToQueue>
				}
				#else /* configUSE_QUEUE_SETS */
				{
					/* If there was a task waiting for data to arrive on the
					queue then unblock it now. */
					if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToReceive ) ) == pdFALSE )
    1628:	f8 01       	movw	r30, r16
    162a:	81 89       	ldd	r24, Z+17	; 0x11
    162c:	88 23       	and	r24, r24
    162e:	41 f0       	breq	.+16     	; 0x1640 <xQueueGenericSend+0x82>
					{
						if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToReceive ) ) == pdTRUE )
    1630:	c8 01       	movw	r24, r16
    1632:	41 96       	adiw	r24, 0x11	; 17
    1634:	0e 94 31 04 	call	0x862	; 0x862 <xTaskRemoveFromEventList>
    1638:	81 30       	cpi	r24, 0x01	; 1
    163a:	11 f4       	brne	.+4      	; 0x1640 <xQueueGenericSend+0x82>
						{
							/* The unblocked task has a priority higher than
							our own so yield immediately.  Yes it is ok to do
							this from within the critical section - the kernel
							takes care of that. */
							portYIELD_WITHIN_API();
    163c:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
						}
					}
				}
				#endif /* configUSE_QUEUE_SETS */

				taskEXIT_CRITICAL();
    1640:	0f 90       	pop	r0
    1642:	0f be       	out	0x3f, r0	; 63
    1644:	81 e0       	ldi	r24, 0x01	; 1
    1646:	4c c0       	rjmp	.+152    	; 0x16e0 <xQueueGenericSend+0x122>
				function. */
				return pdPASS;
			}
			else
			{
				if( xTicksToWait == ( portTickType ) 0 )
    1648:	8c 81       	ldd	r24, Y+4	; 0x04
    164a:	9d 81       	ldd	r25, Y+5	; 0x05
    164c:	89 2b       	or	r24, r25
    164e:	19 f4       	brne	.+6      	; 0x1656 <xQueueGenericSend+0x98>
				{
					/* The queue was full and no block time is specified (or
					the block time has expired) so leave now. */
					taskEXIT_CRITICAL();
    1650:	0f 90       	pop	r0
    1652:	0f be       	out	0x3f, r0	; 63
    1654:	44 c0       	rjmp	.+136    	; 0x16de <xQueueGenericSend+0x120>
					/* Return to the original privilege level before exiting
					the function. */
					traceQUEUE_SEND_FAILED( pxQueue );
					return errQUEUE_FULL;
				}
				else if( xEntryTimeSet == pdFALSE )
    1656:	22 23       	and	r18, r18
    1658:	19 f4       	brne	.+6      	; 0x1660 <xQueueGenericSend+0xa2>
				{
					/* The queue was full and a block time was specified so
					configure the timeout structure. */
					vTaskSetTimeOutState( &xTimeOut );
    165a:	c5 01       	movw	r24, r10
    165c:	0e 94 e8 03 	call	0x7d0	; 0x7d0 <vTaskSetTimeOutState>
					xEntryTimeSet = pdTRUE;
				}
			}
		}
		taskEXIT_CRITICAL();
    1660:	0f 90       	pop	r0
    1662:	0f be       	out	0x3f, r0	; 63

		/* Interrupts and other tasks can send to and receive from the queue
		now the critical section has been exited. */

		vTaskSuspendAll();
    1664:	0e 94 8c 03 	call	0x718	; 0x718 <vTaskSuspendAll>
		prvLockQueue( pxQueue );
    1668:	0f b6       	in	r0, 0x3f	; 63
    166a:	f8 94       	cli
    166c:	0f 92       	push	r0
    166e:	f8 01       	movw	r30, r16
    1670:	85 8d       	ldd	r24, Z+29	; 0x1d
    1672:	8f 3f       	cpi	r24, 0xFF	; 255
    1674:	09 f4       	brne	.+2      	; 0x1678 <xQueueGenericSend+0xba>
    1676:	15 8e       	std	Z+29, r1	; 0x1d
    1678:	f8 01       	movw	r30, r16
    167a:	86 8d       	ldd	r24, Z+30	; 0x1e
    167c:	8f 3f       	cpi	r24, 0xFF	; 255
    167e:	09 f4       	brne	.+2      	; 0x1682 <xQueueGenericSend+0xc4>
    1680:	16 8e       	std	Z+30, r1	; 0x1e
    1682:	0f 90       	pop	r0
    1684:	0f be       	out	0x3f, r0	; 63

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
    1686:	c5 01       	movw	r24, r10
    1688:	b4 01       	movw	r22, r8
    168a:	0e 94 f3 03 	call	0x7e6	; 0x7e6 <xTaskCheckForTimeOut>
    168e:	88 23       	and	r24, r24
    1690:	09 f5       	brne	.+66     	; 0x16d4 <xQueueGenericSend+0x116>

static signed portBASE_TYPE prvIsQueueFull( const xQUEUE *pxQueue )
{
signed portBASE_TYPE xReturn;

	taskENTER_CRITICAL();
    1692:	0f b6       	in	r0, 0x3f	; 63
    1694:	f8 94       	cli
    1696:	0f 92       	push	r0
	{
		if( pxQueue->uxMessagesWaiting == pxQueue->uxLength )
    1698:	f8 01       	movw	r30, r16
    169a:	92 8d       	ldd	r25, Z+26	; 0x1a
		else
		{
			xReturn = pdFALSE;
		}
	}
	taskEXIT_CRITICAL();
    169c:	0f 90       	pop	r0
    169e:	0f be       	out	0x3f, r0	; 63
		prvLockQueue( pxQueue );

		/* Update the timeout state to see if it has expired yet. */
		if( xTaskCheckForTimeOut( &xTimeOut, &xTicksToWait ) == pdFALSE )
		{
			if( prvIsQueueFull( pxQueue ) != pdFALSE )
    16a0:	f8 01       	movw	r30, r16
    16a2:	83 8d       	ldd	r24, Z+27	; 0x1b
    16a4:	98 17       	cp	r25, r24
    16a6:	81 f4       	brne	.+32     	; 0x16c8 <xQueueGenericSend+0x10a>
			{
				traceBLOCKING_ON_QUEUE_SEND( pxQueue );
				vTaskPlaceOnEventList( &( pxQueue->xTasksWaitingToSend ), xTicksToWait );
    16a8:	6c 81       	ldd	r22, Y+4	; 0x04
    16aa:	7d 81       	ldd	r23, Y+5	; 0x05
    16ac:	c7 01       	movw	r24, r14
    16ae:	0e 94 4b 05 	call	0xa96	; 0xa96 <vTaskPlaceOnEventList>
				/* Unlocking the queue means queue events can effect the
				event list.  It is possible	that interrupts occurring now
				remove this task from the event	list again - but as the
				scheduler is suspended the task will go onto the pending
				ready last instead of the actual ready list. */
				prvUnlockQueue( pxQueue );
    16b2:	c8 01       	movw	r24, r16
    16b4:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <prvUnlockQueue>
				/* Resuming the scheduler will move tasks from the pending
				ready list into the ready list - so it is feasible that this
				task is already in a ready list before it yields - in which
				case the yield will not cause a context switch unless there
				is also a higher priority task in the pending ready list. */
				if( xTaskResumeAll() == pdFALSE )
    16b8:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
    16bc:	88 23       	and	r24, r24
    16be:	09 f0       	breq	.+2      	; 0x16c2 <xQueueGenericSend+0x104>
    16c0:	a5 cf       	rjmp	.-182    	; 0x160c <xQueueGenericSend+0x4e>
				{
					portYIELD_WITHIN_API();
    16c2:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
    16c6:	a2 cf       	rjmp	.-188    	; 0x160c <xQueueGenericSend+0x4e>
				}
			}
			else
			{
				/* Try again. */
				prvUnlockQueue( pxQueue );
    16c8:	c8 01       	movw	r24, r16
    16ca:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <prvUnlockQueue>
				( void ) xTaskResumeAll();
    16ce:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
    16d2:	9c cf       	rjmp	.-200    	; 0x160c <xQueueGenericSend+0x4e>
			}
		}
		else
		{
			/* The timeout has expired. */
			prvUnlockQueue( pxQueue );
    16d4:	c8 01       	movw	r24, r16
    16d6:	0e 94 d3 09 	call	0x13a6	; 0x13a6 <prvUnlockQueue>
			( void ) xTaskResumeAll();
    16da:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
    16de:	80 e0       	ldi	r24, 0x00	; 0
			function. */
			traceQUEUE_SEND_FAILED( pxQueue );
			return errQUEUE_FULL;
		}
	}
}
    16e0:	0f 90       	pop	r0
    16e2:	0f 90       	pop	r0
    16e4:	0f 90       	pop	r0
    16e6:	0f 90       	pop	r0
    16e8:	0f 90       	pop	r0
    16ea:	cf 91       	pop	r28
    16ec:	df 91       	pop	r29
    16ee:	1f 91       	pop	r17
    16f0:	0f 91       	pop	r16
    16f2:	ff 90       	pop	r15
    16f4:	ef 90       	pop	r14
    16f6:	df 90       	pop	r13
    16f8:	cf 90       	pop	r12
    16fa:	bf 90       	pop	r11
    16fc:	af 90       	pop	r10
    16fe:	9f 90       	pop	r9
    1700:	8f 90       	pop	r8
    1702:	7f 90       	pop	r7
    1704:	08 95       	ret

00001706 <xQueueGenericReset>:
	}														\
	taskEXIT_CRITICAL()
/*-----------------------------------------------------------*/

portBASE_TYPE xQueueGenericReset( xQueueHandle xQueue, portBASE_TYPE xNewQueue )
{
    1706:	cf 93       	push	r28
    1708:	df 93       	push	r29
xQUEUE *pxQueue;

	pxQueue = ( xQUEUE * ) xQueue;
    170a:	ec 01       	movw	r28, r24
	configASSERT( pxQueue );

	taskENTER_CRITICAL();
    170c:	0f b6       	in	r0, 0x3f	; 63
    170e:	f8 94       	cli
    1710:	0f 92       	push	r0
	{
		pxQueue->pcTail = pxQueue->pcHead + ( pxQueue->uxLength * pxQueue->uxItemSize );
    1712:	ec 8d       	ldd	r30, Y+28	; 0x1c
    1714:	2b 8d       	ldd	r18, Y+27	; 0x1b
    1716:	e2 9f       	mul	r30, r18
    1718:	c0 01       	movw	r24, r0
    171a:	11 24       	eor	r1, r1
    171c:	48 81       	ld	r20, Y
    171e:	59 81       	ldd	r21, Y+1	; 0x01
    1720:	84 0f       	add	r24, r20
    1722:	95 1f       	adc	r25, r21
    1724:	9b 83       	std	Y+3, r25	; 0x03
    1726:	8a 83       	std	Y+2, r24	; 0x02
		pxQueue->uxMessagesWaiting = ( unsigned portBASE_TYPE ) 0U;
    1728:	1a 8e       	std	Y+26, r1	; 0x1a
		pxQueue->pcWriteTo = pxQueue->pcHead;
    172a:	5d 83       	std	Y+5, r21	; 0x05
    172c:	4c 83       	std	Y+4, r20	; 0x04
		pxQueue->pcReadFrom = pxQueue->pcHead + ( ( pxQueue->uxLength - ( unsigned portBASE_TYPE ) 1U ) * pxQueue->uxItemSize );
    172e:	30 e0       	ldi	r19, 0x00	; 0
    1730:	21 50       	subi	r18, 0x01	; 1
    1732:	30 40       	sbci	r19, 0x00	; 0
    1734:	f0 e0       	ldi	r31, 0x00	; 0
    1736:	2e 9f       	mul	r18, r30
    1738:	c0 01       	movw	r24, r0
    173a:	2f 9f       	mul	r18, r31
    173c:	90 0d       	add	r25, r0
    173e:	3e 9f       	mul	r19, r30
    1740:	90 0d       	add	r25, r0
    1742:	11 24       	eor	r1, r1
    1744:	48 0f       	add	r20, r24
    1746:	59 1f       	adc	r21, r25
    1748:	5f 83       	std	Y+7, r21	; 0x07
    174a:	4e 83       	std	Y+6, r20	; 0x06
		pxQueue->xRxLock = queueUNLOCKED;
    174c:	8f ef       	ldi	r24, 0xFF	; 255
    174e:	8d 8f       	std	Y+29, r24	; 0x1d
		pxQueue->xTxLock = queueUNLOCKED;
    1750:	8e 8f       	std	Y+30, r24	; 0x1e

		if( xNewQueue == pdFALSE )
    1752:	66 23       	and	r22, r22
    1754:	61 f4       	brne	.+24     	; 0x176e <xQueueGenericReset+0x68>
			/* If there are tasks blocked waiting to read from the queue, then
			the tasks will remain blocked as after this function exits the queue
			will still be empty.  If there are tasks blocked waiting to	write to
			the queue, then one should be unblocked as after this function exits
			it will be possible to write to it. */
			if( listLIST_IS_EMPTY( &( pxQueue->xTasksWaitingToSend ) ) == pdFALSE )
    1756:	88 85       	ldd	r24, Y+8	; 0x08
    1758:	88 23       	and	r24, r24
    175a:	89 f0       	breq	.+34     	; 0x177e <xQueueGenericReset+0x78>
			{
				if( xTaskRemoveFromEventList( &( pxQueue->xTasksWaitingToSend ) ) == pdTRUE )
    175c:	ce 01       	movw	r24, r28
    175e:	08 96       	adiw	r24, 0x08	; 8
    1760:	0e 94 31 04 	call	0x862	; 0x862 <xTaskRemoveFromEventList>
    1764:	81 30       	cpi	r24, 0x01	; 1
    1766:	59 f4       	brne	.+22     	; 0x177e <xQueueGenericReset+0x78>
				{
					portYIELD_WITHIN_API();
    1768:	0e 94 68 0f 	call	0x1ed0	; 0x1ed0 <vPortYield>
    176c:	08 c0       	rjmp	.+16     	; 0x177e <xQueueGenericReset+0x78>
			}
		}
		else
		{
			/* Ensure the event queues start in the correct state. */
			vListInitialise( &( pxQueue->xTasksWaitingToSend ) );
    176e:	ce 01       	movw	r24, r28
    1770:	08 96       	adiw	r24, 0x08	; 8
    1772:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
			vListInitialise( &( pxQueue->xTasksWaitingToReceive ) );
    1776:	ce 01       	movw	r24, r28
    1778:	41 96       	adiw	r24, 0x11	; 17
    177a:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
		}
	}
	taskEXIT_CRITICAL();
    177e:	0f 90       	pop	r0
    1780:	0f be       	out	0x3f, r0	; 63

	/* A value is returned for calling semantic consistency with previous
	versions. */
	return pdPASS;
}
    1782:	81 e0       	ldi	r24, 0x01	; 1
    1784:	df 91       	pop	r29
    1786:	cf 91       	pop	r28
    1788:	08 95       	ret

0000178a <xQueueGenericCreate>:
/*-----------------------------------------------------------*/

xQueueHandle xQueueGenericCreate( unsigned portBASE_TYPE uxQueueLength, unsigned portBASE_TYPE uxItemSize, unsigned char ucQueueType )
{
    178a:	0f 93       	push	r16
    178c:	1f 93       	push	r17
    178e:	cf 93       	push	r28
    1790:	df 93       	push	r29
    1792:	18 2f       	mov	r17, r24
    1794:	06 2f       	mov	r16, r22
	/* Remove compiler warnings about unused parameters should
	configUSE_TRACE_FACILITY not be set to 1. */
	( void ) ucQueueType;

	/* Allocate the new queue structure. */
	if( uxQueueLength > ( unsigned portBASE_TYPE ) 0 )
    1796:	88 23       	and	r24, r24
    1798:	e1 f0       	breq	.+56     	; 0x17d2 <xQueueGenericCreate+0x48>
	{
		pxNewQueue = ( xQUEUE * ) pvPortMalloc( sizeof( xQUEUE ) );
    179a:	8f e1       	ldi	r24, 0x1F	; 31
    179c:	90 e0       	ldi	r25, 0x00	; 0
    179e:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <pvPortMalloc>
    17a2:	ec 01       	movw	r28, r24
		if( pxNewQueue != NULL )
    17a4:	00 97       	sbiw	r24, 0x00	; 0
    17a6:	a9 f0       	breq	.+42     	; 0x17d2 <xQueueGenericCreate+0x48>
		{
			/* Create the list of pointers to queue items.  The queue is one byte
			longer than asked for to make wrap checking easier/faster. */
			xQueueSizeInBytes = ( size_t ) ( uxQueueLength * uxItemSize ) + ( size_t ) 1;

			pxNewQueue->pcHead = ( signed char * ) pvPortMalloc( xQueueSizeInBytes );
    17a8:	01 9f       	mul	r16, r17
    17aa:	c0 01       	movw	r24, r0
    17ac:	11 24       	eor	r1, r1
    17ae:	01 96       	adiw	r24, 0x01	; 1
    17b0:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <pvPortMalloc>
    17b4:	99 83       	std	Y+1, r25	; 0x01
    17b6:	88 83       	st	Y, r24
			if( pxNewQueue->pcHead != NULL )
    17b8:	00 97       	sbiw	r24, 0x00	; 0
    17ba:	41 f0       	breq	.+16     	; 0x17cc <xQueueGenericCreate+0x42>
			{
				/* Initialise the queue members as described above where the
				queue type is defined. */
				pxNewQueue->uxLength = uxQueueLength;
    17bc:	1b 8f       	std	Y+27, r17	; 0x1b
				pxNewQueue->uxItemSize = uxItemSize;
    17be:	0c 8f       	std	Y+28, r16	; 0x1c
				xQueueGenericReset( pxNewQueue, pdTRUE );
    17c0:	ce 01       	movw	r24, r28
    17c2:	61 e0       	ldi	r22, 0x01	; 1
    17c4:	0e 94 83 0b 	call	0x1706	; 0x1706 <xQueueGenericReset>
					pxNewQueue->pxQueueSetContainer = NULL;
				}
				#endif /* configUSE_QUEUE_SETS */

				traceQUEUE_CREATE( pxNewQueue );
				xReturn = pxNewQueue;
    17c8:	9e 01       	movw	r18, r28
    17ca:	05 c0       	rjmp	.+10     	; 0x17d6 <xQueueGenericCreate+0x4c>
			}
			else
			{
				traceQUEUE_CREATE_FAILED( ucQueueType );
				vPortFree( pxNewQueue );
    17cc:	ce 01       	movw	r24, r28
    17ce:	0e 94 4a 0e 	call	0x1c94	; 0x1c94 <vPortFree>
    17d2:	20 e0       	ldi	r18, 0x00	; 0
    17d4:	30 e0       	ldi	r19, 0x00	; 0
	}

	configASSERT( xReturn );

	return xReturn;
}
    17d6:	c9 01       	movw	r24, r18
    17d8:	df 91       	pop	r29
    17da:	cf 91       	pop	r28
    17dc:	1f 91       	pop	r17
    17de:	0f 91       	pop	r16
    17e0:	08 95       	ret

000017e2 <vListInitialise>:
/*-----------------------------------------------------------
 * PUBLIC LIST API documented in list.h
 *----------------------------------------------------------*/

void vListInitialise( xList *pxList )
{
    17e2:	fc 01       	movw	r30, r24
	/* The list structure contains a list item which is used to mark the
	end of the list.  To initialise the list the list end is inserted
	as the only list entry. */
	pxList->pxIndex = ( xListItem * ) &( pxList->xListEnd );
    17e4:	9c 01       	movw	r18, r24
    17e6:	2d 5f       	subi	r18, 0xFD	; 253
    17e8:	3f 4f       	sbci	r19, 0xFF	; 255
    17ea:	32 83       	std	Z+2, r19	; 0x02
    17ec:	21 83       	std	Z+1, r18	; 0x01

	/* The list end value is the highest possible value in the list to
	ensure it remains at the end of the list. */
	pxList->xListEnd.xItemValue = portMAX_DELAY;
    17ee:	8f ef       	ldi	r24, 0xFF	; 255
    17f0:	9f ef       	ldi	r25, 0xFF	; 255
    17f2:	94 83       	std	Z+4, r25	; 0x04
    17f4:	83 83       	std	Z+3, r24	; 0x03

	/* The list end next and previous pointers point to itself so we know
	when the list is empty. */
	pxList->xListEnd.pxNext = ( xListItem * ) &( pxList->xListEnd );
    17f6:	36 83       	std	Z+6, r19	; 0x06
    17f8:	25 83       	std	Z+5, r18	; 0x05
	pxList->xListEnd.pxPrevious = ( xListItem * ) &( pxList->xListEnd );
    17fa:	30 87       	std	Z+8, r19	; 0x08
    17fc:	27 83       	std	Z+7, r18	; 0x07

	pxList->uxNumberOfItems = ( unsigned portBASE_TYPE ) 0U;
    17fe:	10 82       	st	Z, r1
}
    1800:	08 95       	ret

00001802 <vListInitialiseItem>:
/*-----------------------------------------------------------*/

void vListInitialiseItem( xListItem *pxItem )
{
	/* Make sure the list item is not recorded as being on a list. */
	pxItem->pvContainer = NULL;
    1802:	fc 01       	movw	r30, r24
    1804:	11 86       	std	Z+9, r1	; 0x09
    1806:	10 86       	std	Z+8, r1	; 0x08
}
    1808:	08 95       	ret

0000180a <vListInsertEnd>:
/*-----------------------------------------------------------*/

void vListInsertEnd( xList *pxList, xListItem *pxNewListItem )
{
    180a:	cf 93       	push	r28
    180c:	df 93       	push	r29
    180e:	ac 01       	movw	r20, r24
    1810:	db 01       	movw	r26, r22

	/* Insert a new list item into pxList, but rather than sort the list,
	makes the new list item the last item to be removed by a call to
	pvListGetOwnerOfNextEntry.  This means it has to be the item pointed to by
	the pxIndex member. */
	pxIndex = pxList->pxIndex;
    1812:	ec 01       	movw	r28, r24
    1814:	29 81       	ldd	r18, Y+1	; 0x01
    1816:	3a 81       	ldd	r19, Y+2	; 0x02

	pxNewListItem->pxNext = pxIndex->pxNext;
    1818:	f9 01       	movw	r30, r18
    181a:	82 81       	ldd	r24, Z+2	; 0x02
    181c:	93 81       	ldd	r25, Z+3	; 0x03
    181e:	13 96       	adiw	r26, 0x03	; 3
    1820:	9c 93       	st	X, r25
    1822:	8e 93       	st	-X, r24
    1824:	12 97       	sbiw	r26, 0x02	; 2
	pxNewListItem->pxPrevious = pxList->pxIndex;
    1826:	89 81       	ldd	r24, Y+1	; 0x01
    1828:	9a 81       	ldd	r25, Y+2	; 0x02
    182a:	15 96       	adiw	r26, 0x05	; 5
    182c:	9c 93       	st	X, r25
    182e:	8e 93       	st	-X, r24
    1830:	14 97       	sbiw	r26, 0x04	; 4
	pxIndex->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    1832:	02 80       	ldd	r0, Z+2	; 0x02
    1834:	f3 81       	ldd	r31, Z+3	; 0x03
    1836:	e0 2d       	mov	r30, r0
    1838:	75 83       	std	Z+5, r23	; 0x05
    183a:	64 83       	std	Z+4, r22	; 0x04
	pxIndex->pxNext = ( volatile xListItem * ) pxNewListItem;
    183c:	e9 01       	movw	r28, r18
    183e:	7b 83       	std	Y+3, r23	; 0x03
    1840:	6a 83       	std	Y+2, r22	; 0x02
	pxList->pxIndex = ( volatile xListItem * ) pxNewListItem;
    1842:	fa 01       	movw	r30, r20
    1844:	72 83       	std	Z+2, r23	; 0x02
    1846:	61 83       	std	Z+1, r22	; 0x01

	/* Remember which list the item is in. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    1848:	19 96       	adiw	r26, 0x09	; 9
    184a:	5c 93       	st	X, r21
    184c:	4e 93       	st	-X, r20
    184e:	18 97       	sbiw	r26, 0x08	; 8

	( pxList->uxNumberOfItems )++;
    1850:	80 81       	ld	r24, Z
    1852:	8f 5f       	subi	r24, 0xFF	; 255
    1854:	80 83       	st	Z, r24
}
    1856:	df 91       	pop	r29
    1858:	cf 91       	pop	r28
    185a:	08 95       	ret

0000185c <vListInsert>:
/*-----------------------------------------------------------*/

void vListInsert( xList *pxList, xListItem *pxNewListItem )
{
    185c:	cf 93       	push	r28
    185e:	df 93       	push	r29
    1860:	9c 01       	movw	r18, r24
    1862:	eb 01       	movw	r28, r22
volatile xListItem *pxIterator;
portTickType xValueOfInsertion;

	/* Insert the new list item into the list, sorted in ulListItem order. */
	xValueOfInsertion = pxNewListItem->xItemValue;
    1864:	48 81       	ld	r20, Y
    1866:	59 81       	ldd	r21, Y+1	; 0x01
	are stored in ready lists (all of which have the same ulListItem value)
	get an equal share of the CPU.  However, if the xItemValue is the same as
	the back marker the iteration loop below will not end.  This means we need
	to guard against this by checking the value first and modifying the
	algorithm slightly if necessary. */
	if( xValueOfInsertion == portMAX_DELAY )
    1868:	8f ef       	ldi	r24, 0xFF	; 255
    186a:	4f 3f       	cpi	r20, 0xFF	; 255
    186c:	58 07       	cpc	r21, r24
    186e:	21 f4       	brne	.+8      	; 0x1878 <vListInsert+0x1c>
	{
		pxIterator = pxList->xListEnd.pxPrevious;
    1870:	f9 01       	movw	r30, r18
    1872:	a7 81       	ldd	r26, Z+7	; 0x07
    1874:	b0 85       	ldd	r27, Z+8	; 0x08
    1876:	10 c0       	rjmp	.+32     	; 0x1898 <vListInsert+0x3c>
			   before the scheduler has been started (are interrupts firing
			   before vTaskStartScheduler() has been called?).
		See http://www.freertos.org/FAQHelp.html for more tips.
		**********************************************************************/

		for( pxIterator = ( xListItem * ) &( pxList->xListEnd ); pxIterator->pxNext->xItemValue <= xValueOfInsertion; pxIterator = pxIterator->pxNext )
    1878:	d9 01       	movw	r26, r18
    187a:	13 96       	adiw	r26, 0x03	; 3
    187c:	04 c0       	rjmp	.+8      	; 0x1886 <vListInsert+0x2a>
    187e:	12 96       	adiw	r26, 0x02	; 2
    1880:	0d 90       	ld	r0, X+
    1882:	bc 91       	ld	r27, X
    1884:	a0 2d       	mov	r26, r0
    1886:	12 96       	adiw	r26, 0x02	; 2
    1888:	ed 91       	ld	r30, X+
    188a:	fc 91       	ld	r31, X
    188c:	13 97       	sbiw	r26, 0x03	; 3
    188e:	80 81       	ld	r24, Z
    1890:	91 81       	ldd	r25, Z+1	; 0x01
    1892:	48 17       	cp	r20, r24
    1894:	59 07       	cpc	r21, r25
    1896:	98 f7       	brcc	.-26     	; 0x187e <vListInsert+0x22>
			/* There is nothing to do here, we are just iterating to the
			wanted insertion position. */
		}
	}

	pxNewListItem->pxNext = pxIterator->pxNext;
    1898:	12 96       	adiw	r26, 0x02	; 2
    189a:	ed 91       	ld	r30, X+
    189c:	fc 91       	ld	r31, X
    189e:	13 97       	sbiw	r26, 0x03	; 3
    18a0:	fb 83       	std	Y+3, r31	; 0x03
    18a2:	ea 83       	std	Y+2, r30	; 0x02
	pxNewListItem->pxNext->pxPrevious = ( volatile xListItem * ) pxNewListItem;
    18a4:	d5 83       	std	Z+5, r29	; 0x05
    18a6:	c4 83       	std	Z+4, r28	; 0x04
	pxNewListItem->pxPrevious = pxIterator;
    18a8:	bd 83       	std	Y+5, r27	; 0x05
    18aa:	ac 83       	std	Y+4, r26	; 0x04
	pxIterator->pxNext = ( volatile xListItem * ) pxNewListItem;
    18ac:	13 96       	adiw	r26, 0x03	; 3
    18ae:	dc 93       	st	X, r29
    18b0:	ce 93       	st	-X, r28
    18b2:	12 97       	sbiw	r26, 0x02	; 2

	/* Remember which list the item is in.  This allows fast removal of the
	item later. */
	pxNewListItem->pvContainer = ( void * ) pxList;
    18b4:	39 87       	std	Y+9, r19	; 0x09
    18b6:	28 87       	std	Y+8, r18	; 0x08

	( pxList->uxNumberOfItems )++;
    18b8:	f9 01       	movw	r30, r18
    18ba:	80 81       	ld	r24, Z
    18bc:	8f 5f       	subi	r24, 0xFF	; 255
    18be:	80 83       	st	Z, r24
}
    18c0:	df 91       	pop	r29
    18c2:	cf 91       	pop	r28
    18c4:	08 95       	ret

000018c6 <uxListRemove>:
/*-----------------------------------------------------------*/

unsigned portBASE_TYPE uxListRemove( xListItem *pxItemToRemove )
{
    18c6:	cf 93       	push	r28
    18c8:	df 93       	push	r29
    18ca:	dc 01       	movw	r26, r24
xList * pxList;

	pxItemToRemove->pxNext->pxPrevious = pxItemToRemove->pxPrevious;
    18cc:	12 96       	adiw	r26, 0x02	; 2
    18ce:	ed 91       	ld	r30, X+
    18d0:	fc 91       	ld	r31, X
    18d2:	13 97       	sbiw	r26, 0x03	; 3
    18d4:	14 96       	adiw	r26, 0x04	; 4
    18d6:	8d 91       	ld	r24, X+
    18d8:	9c 91       	ld	r25, X
    18da:	15 97       	sbiw	r26, 0x05	; 5
    18dc:	95 83       	std	Z+5, r25	; 0x05
    18de:	84 83       	std	Z+4, r24	; 0x04
	pxItemToRemove->pxPrevious->pxNext = pxItemToRemove->pxNext;
    18e0:	14 96       	adiw	r26, 0x04	; 4
    18e2:	cd 91       	ld	r28, X+
    18e4:	dc 91       	ld	r29, X
    18e6:	15 97       	sbiw	r26, 0x05	; 5
    18e8:	fb 83       	std	Y+3, r31	; 0x03
    18ea:	ea 83       	std	Y+2, r30	; 0x02

	/* The list item knows which list it is in.  Obtain the list from the list
	item. */
	pxList = ( xList * ) pxItemToRemove->pvContainer;
    18ec:	18 96       	adiw	r26, 0x08	; 8
    18ee:	ed 91       	ld	r30, X+
    18f0:	fc 91       	ld	r31, X
    18f2:	19 97       	sbiw	r26, 0x09	; 9

	/* Make sure the index is left pointing to a valid item. */
	if( pxList->pxIndex == pxItemToRemove )
    18f4:	81 81       	ldd	r24, Z+1	; 0x01
    18f6:	92 81       	ldd	r25, Z+2	; 0x02
    18f8:	8a 17       	cp	r24, r26
    18fa:	9b 07       	cpc	r25, r27
    18fc:	11 f4       	brne	.+4      	; 0x1902 <uxListRemove+0x3c>
	{
		pxList->pxIndex = pxItemToRemove->pxPrevious;
    18fe:	d2 83       	std	Z+2, r29	; 0x02
    1900:	c1 83       	std	Z+1, r28	; 0x01
	}

	pxItemToRemove->pvContainer = NULL;
    1902:	19 96       	adiw	r26, 0x09	; 9
    1904:	1c 92       	st	X, r1
    1906:	1e 92       	st	-X, r1
    1908:	18 97       	sbiw	r26, 0x08	; 8
	( pxList->uxNumberOfItems )--;
    190a:	80 81       	ld	r24, Z
    190c:	81 50       	subi	r24, 0x01	; 1
    190e:	80 83       	st	Z, r24

	return pxList->uxNumberOfItems;
    1910:	80 81       	ld	r24, Z
}
    1912:	df 91       	pop	r29
    1914:	cf 91       	pop	r28
    1916:	08 95       	ret

00001918 <xCoRoutineRemoveFromEventList>:
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
}
/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineRemoveFromEventList( const xList *pxEventList )
{
    1918:	ef 92       	push	r14
    191a:	ff 92       	push	r15
    191c:	0f 93       	push	r16
    191e:	1f 93       	push	r17
    1920:	fc 01       	movw	r30, r24
signed portBASE_TYPE xReturn;

	/* This function is called from within an interrupt.  It can only access
	event lists and the pending ready list.  This function assumes that a
	check has already been made to ensure pxEventList is not empty. */
	pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxEventList );
    1922:	05 80       	ldd	r0, Z+5	; 0x05
    1924:	f6 81       	ldd	r31, Z+6	; 0x06
    1926:	e0 2d       	mov	r30, r0
    1928:	e6 80       	ldd	r14, Z+6	; 0x06
    192a:	f7 80       	ldd	r15, Z+7	; 0x07
	uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    192c:	87 01       	movw	r16, r14
    192e:	04 5f       	subi	r16, 0xF4	; 244
    1930:	1f 4f       	sbci	r17, 0xFF	; 255
    1932:	c8 01       	movw	r24, r16
    1934:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
	vListInsertEnd( ( xList * ) &( xPendingReadyCoRoutineList ), &( pxUnblockedCRCB->xEventListItem ) );
    1938:	83 e4       	ldi	r24, 0x43	; 67
    193a:	91 e0       	ldi	r25, 0x01	; 1
    193c:	b8 01       	movw	r22, r16
    193e:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>
    1942:	20 e0       	ldi	r18, 0x00	; 0
    1944:	e0 91 12 01 	lds	r30, 0x0112
    1948:	f0 91 13 01 	lds	r31, 0x0113
    194c:	d7 01       	movw	r26, r14
    194e:	56 96       	adiw	r26, 0x16	; 22
    1950:	9c 91       	ld	r25, X
    1952:	86 89       	ldd	r24, Z+22	; 0x16
    1954:	98 17       	cp	r25, r24
    1956:	08 f0       	brcs	.+2      	; 0x195a <xCoRoutineRemoveFromEventList+0x42>
    1958:	21 e0       	ldi	r18, 0x01	; 1
	{
		xReturn = pdFALSE;
	}

	return xReturn;
}
    195a:	82 2f       	mov	r24, r18
    195c:	1f 91       	pop	r17
    195e:	0f 91       	pop	r16
    1960:	ff 90       	pop	r15
    1962:	ef 90       	pop	r14
    1964:	08 95       	ret

00001966 <vCoRoutineSchedule>:
	xLastTickCount = xCoRoutineTickCount;
}
/*-----------------------------------------------------------*/

void vCoRoutineSchedule( void )
{
    1966:	ff 92       	push	r15
    1968:	0f 93       	push	r16
    196a:	1f 93       	push	r17
    196c:	cf 93       	push	r28
    196e:	df 93       	push	r29
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
		}
		portENABLE_INTERRUPTS();

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1970:	99 e0       	ldi	r25, 0x09	; 9
    1972:	f9 2e       	mov	r15, r25
    1974:	21 c0       	rjmp	.+66     	; 0x19b8 <vCoRoutineSchedule+0x52>
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
	{
		corCRCB *pxUnblockedCRCB;

		/* The pending ready list can be accessed by an ISR. */
		portDISABLE_INTERRUPTS();
    1976:	f8 94       	cli
		{
			pxUnblockedCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( (&xPendingReadyCoRoutineList) );
    1978:	e0 91 48 01 	lds	r30, 0x0148
    197c:	f0 91 49 01 	lds	r31, 0x0149
    1980:	06 81       	ldd	r16, Z+6	; 0x06
    1982:	17 81       	ldd	r17, Z+7	; 0x07
			uxListRemove( &( pxUnblockedCRCB->xEventListItem ) );
    1984:	c8 01       	movw	r24, r16
    1986:	0c 96       	adiw	r24, 0x0c	; 12
    1988:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
		}
		portENABLE_INTERRUPTS();
    198c:	78 94       	sei

		uxListRemove( &( pxUnblockedCRCB->xGenericListItem ) );
    198e:	e8 01       	movw	r28, r16
    1990:	22 96       	adiw	r28, 0x02	; 2
    1992:	ce 01       	movw	r24, r28
    1994:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
		prvAddCoRoutineToReadyQueue( pxUnblockedCRCB );
    1998:	f8 01       	movw	r30, r16
    199a:	96 89       	ldd	r25, Z+22	; 0x16
    199c:	80 91 14 01 	lds	r24, 0x0114
    19a0:	89 17       	cp	r24, r25
    19a2:	10 f4       	brcc	.+4      	; 0x19a8 <vCoRoutineSchedule+0x42>
    19a4:	90 93 14 01 	sts	0x0114, r25
    19a8:	9f 9d       	mul	r25, r15
    19aa:	c0 01       	movw	r24, r0
    19ac:	11 24       	eor	r1, r1
    19ae:	85 5e       	subi	r24, 0xE5	; 229
    19b0:	9e 4f       	sbci	r25, 0xFE	; 254
    19b2:	be 01       	movw	r22, r28
    19b4:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>
static void prvCheckPendingReadyList( void )
{
	/* Are there any co-routines waiting to get moved to the ready list?  These
	are co-routines that have been readied by an ISR.  The ISR cannot access
	the	ready lists itself. */
	while( listLIST_IS_EMPTY( &xPendingReadyCoRoutineList ) == pdFALSE )
    19b8:	80 91 43 01 	lds	r24, 0x0143
    19bc:	88 23       	and	r24, r24
    19be:	d9 f6       	brne	.-74     	; 0x1976 <vCoRoutineSchedule+0x10>

static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
    19c0:	0e 94 92 03 	call	0x724	; 0x724 <xTaskGetTickCount>
    19c4:	20 91 15 01 	lds	r18, 0x0115
    19c8:	30 91 16 01 	lds	r19, 0x0116
    19cc:	82 1b       	sub	r24, r18
    19ce:	93 0b       	sbc	r25, r19
    19d0:	90 93 18 01 	sts	0x0118, r25
    19d4:	80 93 17 01 	sts	0x0117, r24
					uxListRemove( &( pxCRCB->xEventListItem ) );
				}
			}
			portENABLE_INTERRUPTS();

			prvAddCoRoutineToReadyQueue( pxCRCB );
    19d8:	89 e0       	ldi	r24, 0x09	; 9
    19da:	f8 2e       	mov	r15, r24
    19dc:	53 c0       	rjmp	.+166    	; 0x1a84 <vCoRoutineSchedule+0x11e>
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
	{
		xCoRoutineTickCount++;
    19de:	01 96       	adiw	r24, 0x01	; 1
    19e0:	90 93 1a 01 	sts	0x011A, r25
    19e4:	80 93 19 01 	sts	0x0119, r24
		xPassedTicks--;
    19e8:	21 50       	subi	r18, 0x01	; 1
    19ea:	30 40       	sbci	r19, 0x00	; 0
    19ec:	30 93 18 01 	sts	0x0118, r19
    19f0:	20 93 17 01 	sts	0x0117, r18

		/* If the tick count has overflowed we need to swap the ready lists. */
		if( xCoRoutineTickCount == 0 )
    19f4:	89 2b       	or	r24, r25
    19f6:	09 f0       	breq	.+2      	; 0x19fa <vCoRoutineSchedule+0x94>
    19f8:	3e c0       	rjmp	.+124    	; 0x1a76 <vCoRoutineSchedule+0x110>
		{
			xList * pxTemp;

			/* Tick count has overflowed so we need to swap the delay lists.  If there are
			any items in pxDelayedCoRoutineList here then there is an error! */
			pxTemp = pxDelayedCoRoutineList;
    19fa:	20 91 3f 01 	lds	r18, 0x013F
    19fe:	30 91 40 01 	lds	r19, 0x0140
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
    1a02:	80 91 41 01 	lds	r24, 0x0141
    1a06:	90 91 42 01 	lds	r25, 0x0142
    1a0a:	90 93 40 01 	sts	0x0140, r25
    1a0e:	80 93 3f 01 	sts	0x013F, r24
			pxOverflowDelayedCoRoutineList = pxTemp;
    1a12:	30 93 42 01 	sts	0x0142, r19
    1a16:	20 93 41 01 	sts	0x0141, r18
    1a1a:	2d c0       	rjmp	.+90     	; 0x1a76 <vCoRoutineSchedule+0x110>
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
		{
			pxCRCB = ( corCRCB * ) listGET_OWNER_OF_HEAD_ENTRY( pxDelayedCoRoutineList );
    1a1c:	05 80       	ldd	r0, Z+5	; 0x05
    1a1e:	f6 81       	ldd	r31, Z+6	; 0x06
    1a20:	e0 2d       	mov	r30, r0
    1a22:	c6 81       	ldd	r28, Z+6	; 0x06
    1a24:	d7 81       	ldd	r29, Z+7	; 0x07

			if( xCoRoutineTickCount < listGET_LIST_ITEM_VALUE( &( pxCRCB->xGenericListItem ) ) )
    1a26:	20 91 19 01 	lds	r18, 0x0119
    1a2a:	30 91 1a 01 	lds	r19, 0x011A
    1a2e:	8a 81       	ldd	r24, Y+2	; 0x02
    1a30:	9b 81       	ldd	r25, Y+3	; 0x03
    1a32:	28 17       	cp	r18, r24
    1a34:	39 07       	cpc	r19, r25
    1a36:	30 f1       	brcs	.+76     	; 0x1a84 <vCoRoutineSchedule+0x11e>
			{
				/* Timeout not yet expired. */
				break;
			}

			portDISABLE_INTERRUPTS();
    1a38:	f8 94       	cli
				/* The event could have occurred just before this critical
				section.  If this is the case then the generic list item will
				have been moved to the pending ready list and the following
				line is still valid.  Also the pvContainer parameter will have
				been set to NULL so the following lines are also valid. */
				uxListRemove( &( pxCRCB->xGenericListItem ) );
    1a3a:	8e 01       	movw	r16, r28
    1a3c:	0e 5f       	subi	r16, 0xFE	; 254
    1a3e:	1f 4f       	sbci	r17, 0xFF	; 255
    1a40:	c8 01       	movw	r24, r16
    1a42:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>

				/* Is the co-routine waiting on an event also? */
				if( pxCRCB->xEventListItem.pvContainer )
    1a46:	8c 89       	ldd	r24, Y+20	; 0x14
    1a48:	9d 89       	ldd	r25, Y+21	; 0x15
    1a4a:	89 2b       	or	r24, r25
    1a4c:	21 f0       	breq	.+8      	; 0x1a56 <vCoRoutineSchedule+0xf0>
				{
					uxListRemove( &( pxCRCB->xEventListItem ) );
    1a4e:	ce 01       	movw	r24, r28
    1a50:	0c 96       	adiw	r24, 0x0c	; 12
    1a52:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>
				}
			}
			portENABLE_INTERRUPTS();
    1a56:	78 94       	sei

			prvAddCoRoutineToReadyQueue( pxCRCB );
    1a58:	9e 89       	ldd	r25, Y+22	; 0x16
    1a5a:	80 91 14 01 	lds	r24, 0x0114
    1a5e:	89 17       	cp	r24, r25
    1a60:	10 f4       	brcc	.+4      	; 0x1a66 <vCoRoutineSchedule+0x100>
    1a62:	90 93 14 01 	sts	0x0114, r25
    1a66:	9f 9d       	mul	r25, r15
    1a68:	c0 01       	movw	r24, r0
    1a6a:	11 24       	eor	r1, r1
    1a6c:	85 5e       	subi	r24, 0xE5	; 229
    1a6e:	9e 4f       	sbci	r25, 0xFE	; 254
    1a70:	b8 01       	movw	r22, r16
    1a72:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>
			pxDelayedCoRoutineList = pxOverflowDelayedCoRoutineList;
			pxOverflowDelayedCoRoutineList = pxTemp;
		}

		/* See if this tick has made a timeout expire. */
		while( listLIST_IS_EMPTY( pxDelayedCoRoutineList ) == pdFALSE )
    1a76:	e0 91 3f 01 	lds	r30, 0x013F
    1a7a:	f0 91 40 01 	lds	r31, 0x0140
    1a7e:	80 81       	ld	r24, Z
    1a80:	88 23       	and	r24, r24
    1a82:	61 f6       	brne	.-104    	; 0x1a1c <vCoRoutineSchedule+0xb6>
static void prvCheckDelayedList( void )
{
corCRCB *pxCRCB;

	xPassedTicks = xTaskGetTickCount() - xLastTickCount;
	while( xPassedTicks )
    1a84:	20 91 17 01 	lds	r18, 0x0117
    1a88:	30 91 18 01 	lds	r19, 0x0118
    1a8c:	80 91 19 01 	lds	r24, 0x0119
    1a90:	90 91 1a 01 	lds	r25, 0x011A
    1a94:	21 15       	cp	r18, r1
    1a96:	31 05       	cpc	r19, r1
    1a98:	09 f0       	breq	.+2      	; 0x1a9c <vCoRoutineSchedule+0x136>
    1a9a:	a1 cf       	rjmp	.-190    	; 0x19de <vCoRoutineSchedule+0x78>

			prvAddCoRoutineToReadyQueue( pxCRCB );
		}
	}

	xLastTickCount = xCoRoutineTickCount;
    1a9c:	90 93 16 01 	sts	0x0116, r25
    1aa0:	80 93 15 01 	sts	0x0115, r24
    1aa4:	90 91 14 01 	lds	r25, 0x0114

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1aa8:	29 e0       	ldi	r18, 0x09	; 9
    1aaa:	06 c0       	rjmp	.+12     	; 0x1ab8 <vCoRoutineSchedule+0x152>
	{
		if( uxTopCoRoutineReadyPriority == 0 )
    1aac:	99 23       	and	r25, r25
    1aae:	19 f4       	brne	.+6      	; 0x1ab6 <vCoRoutineSchedule+0x150>
    1ab0:	10 92 14 01 	sts	0x0114, r1
    1ab4:	32 c0       	rjmp	.+100    	; 0x1b1a <vCoRoutineSchedule+0x1b4>
    1ab6:	91 50       	subi	r25, 0x01	; 1

	/* See if any delayed co-routines have timed out. */
	prvCheckDelayedList();

	/* Find the highest priority queue that contains ready co-routines. */
	while( listLIST_IS_EMPTY( &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) ) )
    1ab8:	92 9f       	mul	r25, r18
    1aba:	d0 01       	movw	r26, r0
    1abc:	11 24       	eor	r1, r1
    1abe:	a5 5e       	subi	r26, 0xE5	; 229
    1ac0:	be 4f       	sbci	r27, 0xFE	; 254
    1ac2:	8c 91       	ld	r24, X
    1ac4:	88 23       	and	r24, r24
    1ac6:	91 f3       	breq	.-28     	; 0x1aac <vCoRoutineSchedule+0x146>
    1ac8:	90 93 14 01 	sts	0x0114, r25
		--uxTopCoRoutineReadyPriority;
	}

	/* listGET_OWNER_OF_NEXT_ENTRY walks through the list, so the co-routines
	 of the	same priority get an equal share of the processor time. */
	listGET_OWNER_OF_NEXT_ENTRY( pxCurrentCoRoutine, &( pxReadyCoRoutineLists[ uxTopCoRoutineReadyPriority ] ) );
    1acc:	11 96       	adiw	r26, 0x01	; 1
    1ace:	ed 91       	ld	r30, X+
    1ad0:	fc 91       	ld	r31, X
    1ad2:	12 97       	sbiw	r26, 0x02	; 2
    1ad4:	02 80       	ldd	r0, Z+2	; 0x02
    1ad6:	f3 81       	ldd	r31, Z+3	; 0x03
    1ad8:	e0 2d       	mov	r30, r0
    1ada:	12 96       	adiw	r26, 0x02	; 2
    1adc:	fc 93       	st	X, r31
    1ade:	ee 93       	st	-X, r30
    1ae0:	11 97       	sbiw	r26, 0x01	; 1
    1ae2:	cd 01       	movw	r24, r26
    1ae4:	03 96       	adiw	r24, 0x03	; 3
    1ae6:	e8 17       	cp	r30, r24
    1ae8:	f9 07       	cpc	r31, r25
    1aea:	31 f4       	brne	.+12     	; 0x1af8 <vCoRoutineSchedule+0x192>
    1aec:	82 81       	ldd	r24, Z+2	; 0x02
    1aee:	93 81       	ldd	r25, Z+3	; 0x03
    1af0:	12 96       	adiw	r26, 0x02	; 2
    1af2:	9c 93       	st	X, r25
    1af4:	8e 93       	st	-X, r24
    1af6:	11 97       	sbiw	r26, 0x01	; 1
    1af8:	11 96       	adiw	r26, 0x01	; 1
    1afa:	ed 91       	ld	r30, X+
    1afc:	fc 91       	ld	r31, X
    1afe:	12 97       	sbiw	r26, 0x02	; 2
    1b00:	06 80       	ldd	r0, Z+6	; 0x06
    1b02:	f7 81       	ldd	r31, Z+7	; 0x07
    1b04:	e0 2d       	mov	r30, r0
    1b06:	f0 93 13 01 	sts	0x0113, r31
    1b0a:	e0 93 12 01 	sts	0x0112, r30

	/* Call the co-routine. */
	( pxCurrentCoRoutine->pxCoRoutineFunction )( pxCurrentCoRoutine, pxCurrentCoRoutine->uxIndex );
    1b0e:	20 81       	ld	r18, Z
    1b10:	31 81       	ldd	r19, Z+1	; 0x01
    1b12:	cf 01       	movw	r24, r30
    1b14:	67 89       	ldd	r22, Z+23	; 0x17
    1b16:	f9 01       	movw	r30, r18
    1b18:	09 95       	icall

	return;
}
    1b1a:	df 91       	pop	r29
    1b1c:	cf 91       	pop	r28
    1b1e:	1f 91       	pop	r17
    1b20:	0f 91       	pop	r16
    1b22:	ff 90       	pop	r15
    1b24:	08 95       	ret

00001b26 <vCoRoutineAddToDelayedList>:
	return xReturn;
}
/*-----------------------------------------------------------*/

void vCoRoutineAddToDelayedList( portTickType xTicksToDelay, xList *pxEventList )
{
    1b26:	0f 93       	push	r16
    1b28:	1f 93       	push	r17
    1b2a:	cf 93       	push	r28
    1b2c:	df 93       	push	r29
    1b2e:	eb 01       	movw	r28, r22
portTickType xTimeToWake;

	/* Calculate the time to wake - this may overflow but this is
	not a problem. */
	xTimeToWake = xCoRoutineTickCount + xTicksToDelay;
    1b30:	00 91 19 01 	lds	r16, 0x0119
    1b34:	10 91 1a 01 	lds	r17, 0x011A
    1b38:	08 0f       	add	r16, r24
    1b3a:	19 1f       	adc	r17, r25

	/* We must remove ourselves from the ready list before adding
	ourselves to the blocked list as the same list item is used for
	both lists. */
	uxListRemove( ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1b3c:	80 91 12 01 	lds	r24, 0x0112
    1b40:	90 91 13 01 	lds	r25, 0x0113
    1b44:	02 96       	adiw	r24, 0x02	; 2
    1b46:	0e 94 63 0c 	call	0x18c6	; 0x18c6 <uxListRemove>

	/* The list item will be inserted in wake time order. */
	listSET_LIST_ITEM_VALUE( &( pxCurrentCoRoutine->xGenericListItem ), xTimeToWake );
    1b4a:	e0 91 12 01 	lds	r30, 0x0112
    1b4e:	f0 91 13 01 	lds	r31, 0x0113
    1b52:	13 83       	std	Z+3, r17	; 0x03
    1b54:	02 83       	std	Z+2, r16	; 0x02

	if( xTimeToWake < xCoRoutineTickCount )
    1b56:	80 91 19 01 	lds	r24, 0x0119
    1b5a:	90 91 1a 01 	lds	r25, 0x011A
    1b5e:	bf 01       	movw	r22, r30
    1b60:	6e 5f       	subi	r22, 0xFE	; 254
    1b62:	7f 4f       	sbci	r23, 0xFF	; 255
    1b64:	08 17       	cp	r16, r24
    1b66:	19 07       	cpc	r17, r25
    1b68:	28 f4       	brcc	.+10     	; 0x1b74 <vCoRoutineAddToDelayedList+0x4e>
	{
		/* Wake time has overflowed.  Place this item in the
		overflow list. */
		vListInsert( ( xList * ) pxOverflowDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1b6a:	80 91 41 01 	lds	r24, 0x0141
    1b6e:	90 91 42 01 	lds	r25, 0x0142
    1b72:	04 c0       	rjmp	.+8      	; 0x1b7c <vCoRoutineAddToDelayedList+0x56>
	}
	else
	{
		/* The wake time has not overflowed, so we can use the
		current block list. */
		vListInsert( ( xList * ) pxDelayedCoRoutineList, ( xListItem * ) &( pxCurrentCoRoutine->xGenericListItem ) );
    1b74:	80 91 3f 01 	lds	r24, 0x013F
    1b78:	90 91 40 01 	lds	r25, 0x0140
    1b7c:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInsert>
	}

	if( pxEventList )
    1b80:	20 97       	sbiw	r28, 0x00	; 0
    1b82:	49 f0       	breq	.+18     	; 0x1b96 <vCoRoutineAddToDelayedList+0x70>
	{
		/* Also add the co-routine to an event list.  If this is done then the
		function must be called with interrupts disabled. */
		vListInsert( pxEventList, &( pxCurrentCoRoutine->xEventListItem ) );
    1b84:	60 91 12 01 	lds	r22, 0x0112
    1b88:	70 91 13 01 	lds	r23, 0x0113
    1b8c:	64 5f       	subi	r22, 0xF4	; 244
    1b8e:	7f 4f       	sbci	r23, 0xFF	; 255
    1b90:	ce 01       	movw	r24, r28
    1b92:	0e 94 2e 0c 	call	0x185c	; 0x185c <vListInsert>
	}
}
    1b96:	df 91       	pop	r29
    1b98:	cf 91       	pop	r28
    1b9a:	1f 91       	pop	r17
    1b9c:	0f 91       	pop	r16
    1b9e:	08 95       	ret

00001ba0 <xCoRoutineCreate>:
static void prvCheckDelayedList( void );

/*-----------------------------------------------------------*/

signed portBASE_TYPE xCoRoutineCreate( crCOROUTINE_CODE pxCoRoutineCode, unsigned portBASE_TYPE uxPriority, unsigned portBASE_TYPE uxIndex )
{
    1ba0:	af 92       	push	r10
    1ba2:	bf 92       	push	r11
    1ba4:	cf 92       	push	r12
    1ba6:	df 92       	push	r13
    1ba8:	ef 92       	push	r14
    1baa:	ff 92       	push	r15
    1bac:	0f 93       	push	r16
    1bae:	1f 93       	push	r17
    1bb0:	cf 93       	push	r28
    1bb2:	df 93       	push	r29
    1bb4:	6c 01       	movw	r12, r24
    1bb6:	b6 2e       	mov	r11, r22
    1bb8:	a4 2e       	mov	r10, r20
signed portBASE_TYPE xReturn;
corCRCB *pxCoRoutine;

	/* Allocate the memory that will store the co-routine control block. */
	pxCoRoutine = ( corCRCB * ) pvPortMalloc( sizeof( corCRCB ) );
    1bba:	8a e1       	ldi	r24, 0x1A	; 26
    1bbc:	90 e0       	ldi	r25, 0x00	; 0
    1bbe:	0e 94 5a 0e 	call	0x1cb4	; 0x1cb4 <pvPortMalloc>
    1bc2:	ec 01       	movw	r28, r24
	if( pxCoRoutine )
    1bc4:	00 97       	sbiw	r24, 0x00	; 0
    1bc6:	11 f4       	brne	.+4      	; 0x1bcc <xCoRoutineCreate+0x2c>
    1bc8:	8f ef       	ldi	r24, 0xFF	; 255
    1bca:	59 c0       	rjmp	.+178    	; 0x1c7e <xCoRoutineCreate+0xde>
	{
		/* If pxCurrentCoRoutine is NULL then this is the first co-routine to
		be created and the co-routine data structures need initialising. */
		if( pxCurrentCoRoutine == NULL )
    1bcc:	80 91 12 01 	lds	r24, 0x0112
    1bd0:	90 91 13 01 	lds	r25, 0x0113
    1bd4:	89 2b       	or	r24, r25
    1bd6:	21 f5       	brne	.+72     	; 0x1c20 <xCoRoutineCreate+0x80>
		{
			pxCurrentCoRoutine = pxCoRoutine;
    1bd8:	d0 93 13 01 	sts	0x0113, r29
    1bdc:	c0 93 12 01 	sts	0x0112, r28
{
unsigned portBASE_TYPE uxPriority;

	for( uxPriority = 0; uxPriority < configMAX_CO_ROUTINE_PRIORITIES; uxPriority++ )
	{
		vListInitialise( ( xList * ) &( pxReadyCoRoutineLists[ uxPriority ] ) );
    1be0:	8b e1       	ldi	r24, 0x1B	; 27
    1be2:	91 e0       	ldi	r25, 0x01	; 1
    1be4:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
    1be8:	84 e2       	ldi	r24, 0x24	; 36
    1bea:	91 e0       	ldi	r25, 0x01	; 1
    1bec:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
	}

	vListInitialise( ( xList * ) &xDelayedCoRoutineList1 );
    1bf0:	2d e2       	ldi	r18, 0x2D	; 45
    1bf2:	e2 2e       	mov	r14, r18
    1bf4:	21 e0       	ldi	r18, 0x01	; 1
    1bf6:	f2 2e       	mov	r15, r18
    1bf8:	c7 01       	movw	r24, r14
    1bfa:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
	vListInitialise( ( xList * ) &xDelayedCoRoutineList2 );
    1bfe:	06 e3       	ldi	r16, 0x36	; 54
    1c00:	11 e0       	ldi	r17, 0x01	; 1
    1c02:	c8 01       	movw	r24, r16
    1c04:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>
	vListInitialise( ( xList * ) &xPendingReadyCoRoutineList );
    1c08:	83 e4       	ldi	r24, 0x43	; 67
    1c0a:	91 e0       	ldi	r25, 0x01	; 1
    1c0c:	0e 94 f1 0b 	call	0x17e2	; 0x17e2 <vListInitialise>

	/* Start with pxDelayedCoRoutineList using list1 and the
	pxOverflowDelayedCoRoutineList using list2. */
	pxDelayedCoRoutineList = &xDelayedCoRoutineList1;
    1c10:	f0 92 40 01 	sts	0x0140, r15
    1c14:	e0 92 3f 01 	sts	0x013F, r14
	pxOverflowDelayedCoRoutineList = &xDelayedCoRoutineList2;
    1c18:	10 93 42 01 	sts	0x0142, r17
    1c1c:	00 93 41 01 	sts	0x0141, r16
    1c20:	eb 2c       	mov	r14, r11
    1c22:	bb 20       	and	r11, r11
    1c24:	11 f0       	breq	.+4      	; 0x1c2a <xCoRoutineCreate+0x8a>
    1c26:	ee 24       	eor	r14, r14
    1c28:	e3 94       	inc	r14
		{
			uxPriority = configMAX_CO_ROUTINE_PRIORITIES - 1;
		}

		/* Fill out the co-routine control block from the function parameters. */
		pxCoRoutine->uxState = corINITIAL_STATE;
    1c2a:	19 8e       	std	Y+25, r1	; 0x19
    1c2c:	18 8e       	std	Y+24, r1	; 0x18
		pxCoRoutine->uxPriority = uxPriority;
    1c2e:	ee 8a       	std	Y+22, r14	; 0x16
		pxCoRoutine->uxIndex = uxIndex;
    1c30:	af 8a       	std	Y+23, r10	; 0x17
		pxCoRoutine->pxCoRoutineFunction = pxCoRoutineCode;
    1c32:	fe 01       	movw	r30, r28
    1c34:	c1 92       	st	Z+, r12
    1c36:	d1 92       	st	Z+, r13
    1c38:	8f 01       	movw	r16, r30

		/* Initialise all the other co-routine control block parameters. */
		vListInitialiseItem( &( pxCoRoutine->xGenericListItem ) );
    1c3a:	cf 01       	movw	r24, r30
    1c3c:	0e 94 01 0c 	call	0x1802	; 0x1802 <vListInitialiseItem>
		vListInitialiseItem( &( pxCoRoutine->xEventListItem ) );
    1c40:	ce 01       	movw	r24, r28
    1c42:	0c 96       	adiw	r24, 0x0c	; 12
    1c44:	0e 94 01 0c 	call	0x1802	; 0x1802 <vListInitialiseItem>

		/* Set the co-routine control block as a link back from the xListItem.
		This is so we can get back to the containing CRCB from a generic item
		in a list. */
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xGenericListItem ), pxCoRoutine );
    1c48:	d9 87       	std	Y+9, r29	; 0x09
    1c4a:	c8 87       	std	Y+8, r28	; 0x08
		listSET_LIST_ITEM_OWNER( &( pxCoRoutine->xEventListItem ), pxCoRoutine );
    1c4c:	db 8b       	std	Y+19, r29	; 0x13
    1c4e:	ca 8b       	std	Y+18, r28	; 0x12

		/* Event lists are always in priority order. */
		listSET_LIST_ITEM_VALUE( &( pxCoRoutine->xEventListItem ), configMAX_PRIORITIES - ( portTickType ) uxPriority );
    1c50:	84 e0       	ldi	r24, 0x04	; 4
    1c52:	90 e0       	ldi	r25, 0x00	; 0
    1c54:	8e 19       	sub	r24, r14
    1c56:	91 09       	sbc	r25, r1
    1c58:	9d 87       	std	Y+13, r25	; 0x0d
    1c5a:	8c 87       	std	Y+12, r24	; 0x0c

		/* Now the co-routine has been initialised it can be added to the ready
		list at the correct priority. */
		prvAddCoRoutineToReadyQueue( pxCoRoutine );
    1c5c:	9e 89       	ldd	r25, Y+22	; 0x16
    1c5e:	80 91 14 01 	lds	r24, 0x0114
    1c62:	89 17       	cp	r24, r25
    1c64:	10 f4       	brcc	.+4      	; 0x1c6a <xCoRoutineCreate+0xca>
    1c66:	90 93 14 01 	sts	0x0114, r25
    1c6a:	89 e0       	ldi	r24, 0x09	; 9
    1c6c:	98 9f       	mul	r25, r24
    1c6e:	c0 01       	movw	r24, r0
    1c70:	11 24       	eor	r1, r1
    1c72:	85 5e       	subi	r24, 0xE5	; 229
    1c74:	9e 4f       	sbci	r25, 0xFE	; 254
    1c76:	b8 01       	movw	r22, r16
    1c78:	0e 94 05 0c 	call	0x180a	; 0x180a <vListInsertEnd>
    1c7c:	81 e0       	ldi	r24, 0x01	; 1
	{
		xReturn = errCOULD_NOT_ALLOCATE_REQUIRED_MEMORY;
	}

	return xReturn;
}
    1c7e:	df 91       	pop	r29
    1c80:	cf 91       	pop	r28
    1c82:	1f 91       	pop	r17
    1c84:	0f 91       	pop	r16
    1c86:	ff 90       	pop	r15
    1c88:	ef 90       	pop	r14
    1c8a:	df 90       	pop	r13
    1c8c:	cf 90       	pop	r12
    1c8e:	bf 90       	pop	r11
    1c90:	af 90       	pop	r10
    1c92:	08 95       	ret

00001c94 <vPortFree>:
	http://www.FreeRTOS.org for more information. */
	( void ) pv;

	/* Force an assert as it is invalid to call this function. */
	configASSERT( pv == NULL );
}
    1c94:	08 95       	ret

00001c96 <vPortInitialiseBlocks>:
/*-----------------------------------------------------------*/

void vPortInitialiseBlocks( void )
{
	/* Only required when static memory is not cleared. */
	xNextFreeByte = ( size_t ) 0;
    1c96:	10 92 4d 01 	sts	0x014D, r1
    1c9a:	10 92 4c 01 	sts	0x014C, r1
}
    1c9e:	08 95       	ret

00001ca0 <xPortGetFreeHeapSize>:
/*-----------------------------------------------------------*/

size_t xPortGetFreeHeapSize( void )
{
    1ca0:	2b ed       	ldi	r18, 0xDB	; 219
    1ca2:	35 e0       	ldi	r19, 0x05	; 5
    1ca4:	80 91 4c 01 	lds	r24, 0x014C
    1ca8:	90 91 4d 01 	lds	r25, 0x014D
    1cac:	28 1b       	sub	r18, r24
    1cae:	39 0b       	sbc	r19, r25
	return ( configADJUSTED_HEAP_SIZE - xNextFreeByte );
}
    1cb0:	c9 01       	movw	r24, r18
    1cb2:	08 95       	ret

00001cb4 <pvPortMalloc>:
static size_t xNextFreeByte = ( size_t ) 0;

/*-----------------------------------------------------------*/

void *pvPortMalloc( size_t xWantedSize )
{
    1cb4:	cf 93       	push	r28
    1cb6:	df 93       	push	r29
    1cb8:	ec 01       	movw	r28, r24
			/* Byte alignment required. */
			xWantedSize += ( portBYTE_ALIGNMENT - ( xWantedSize & portBYTE_ALIGNMENT_MASK ) );
		}
	#endif

	vTaskSuspendAll();
    1cba:	0e 94 8c 03 	call	0x718	; 0x718 <vTaskSuspendAll>
	{
		if( pucAlignedHeap == NULL )
    1cbe:	80 91 4e 01 	lds	r24, 0x014E
    1cc2:	90 91 4f 01 	lds	r25, 0x014F
    1cc6:	89 2b       	or	r24, r25
    1cc8:	31 f4       	brne	.+12     	; 0x1cd6 <pvPortMalloc+0x22>
		{
			/* Ensure the heap starts on a correctly aligned boundary. */
			pucAlignedHeap = ( unsigned char * ) ( ( ( portPOINTER_SIZE_TYPE ) &ucHeap[ portBYTE_ALIGNMENT ] ) & ( ( portPOINTER_SIZE_TYPE ) ~portBYTE_ALIGNMENT_MASK ) );
    1cca:	81 e5       	ldi	r24, 0x51	; 81
    1ccc:	91 e0       	ldi	r25, 0x01	; 1
    1cce:	90 93 4f 01 	sts	0x014F, r25
    1cd2:	80 93 4e 01 	sts	0x014E, r24
		}

		/* Check there is enough room left for the allocation. */
		if( ( ( xNextFreeByte + xWantedSize ) < configADJUSTED_HEAP_SIZE ) &&
    1cd6:	20 91 4c 01 	lds	r18, 0x014C
    1cda:	30 91 4d 01 	lds	r19, 0x014D
    1cde:	ce 01       	movw	r24, r28
    1ce0:	82 0f       	add	r24, r18
    1ce2:	93 1f       	adc	r25, r19
    1ce4:	45 e0       	ldi	r20, 0x05	; 5
    1ce6:	8b 3d       	cpi	r24, 0xDB	; 219
    1ce8:	94 07       	cpc	r25, r20
    1cea:	70 f4       	brcc	.+28     	; 0x1d08 <pvPortMalloc+0x54>
    1cec:	28 17       	cp	r18, r24
    1cee:	39 07       	cpc	r19, r25
    1cf0:	58 f4       	brcc	.+22     	; 0x1d08 <pvPortMalloc+0x54>
			( ( xNextFreeByte + xWantedSize ) > xNextFreeByte )	)/* Check for overflow. */
		{
			/* Return the next free byte then increment the index past this
			block. */
			pvReturn = pucAlignedHeap + xNextFreeByte;
    1cf2:	c0 91 4e 01 	lds	r28, 0x014E
    1cf6:	d0 91 4f 01 	lds	r29, 0x014F
    1cfa:	c2 0f       	add	r28, r18
    1cfc:	d3 1f       	adc	r29, r19
			xNextFreeByte += xWantedSize;
    1cfe:	90 93 4d 01 	sts	0x014D, r25
    1d02:	80 93 4c 01 	sts	0x014C, r24
    1d06:	02 c0       	rjmp	.+4      	; 0x1d0c <pvPortMalloc+0x58>
    1d08:	c0 e0       	ldi	r28, 0x00	; 0
    1d0a:	d0 e0       	ldi	r29, 0x00	; 0
		}
	}
	xTaskResumeAll();
    1d0c:	0e 94 68 05 	call	0xad0	; 0xad0 <xTaskResumeAll>
		}
	}
	#endif

	return pvReturn;
}
    1d10:	ce 01       	movw	r24, r28
    1d12:	df 91       	pop	r29
    1d14:	cf 91       	pop	r28
    1d16:	08 95       	ret

00001d18 <pxPortInitialiseStack>:

/* 
 * See header file for description. 
 */
portSTACK_TYPE *pxPortInitialiseStack( portSTACK_TYPE *pxTopOfStack, pdTASK_CODE pxCode, void *pvParameters )
{
    1d18:	fc 01       	movw	r30, r24
unsigned short usAddress;

	/* Place a few bytes of known values on the bottom of the stack. 
	This is just useful for debugging. */

	*pxTopOfStack = 0x11;
    1d1a:	91 e1       	ldi	r25, 0x11	; 17
    1d1c:	90 83       	st	Z, r25
	pxTopOfStack--;
	*pxTopOfStack = 0x22;
    1d1e:	22 e2       	ldi	r18, 0x22	; 34
    1d20:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = 0x33;
    1d22:	83 e3       	ldi	r24, 0x33	; 51
    1d24:	82 93       	st	-Z, r24
	/*lint -e950 -e611 -e923 Lint doesn't like this much - but nothing I can do about it. */

	/* The start of the task code will be popped off the stack last, so place
	it on first. */
	usAddress = ( unsigned short ) pxCode;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1d26:	62 93       	st	-Z, r22
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1d28:	72 93       	st	-Z, r23

	/* Next simulate the stack as if after a call to portSAVE_CONTEXT().  
	portSAVE_CONTEXT places the flags on the stack immediately after r0
	to ensure the interrupts get disabled as soon as possible, and so ensuring
	the stack use is minimal should a context switch interrupt occur. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R0 */
    1d2a:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = portFLAGS_INT_ENABLED;
    1d2c:	80 e8       	ldi	r24, 0x80	; 128
    1d2e:	82 93       	st	-Z, r24
	pxTopOfStack--;


	/* Now the remaining registers.   The compiler expects R1 to be 0. */
	*pxTopOfStack = ( portSTACK_TYPE ) 0x00;	/* R1 */
    1d30:	12 92       	st	-Z, r1
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x02;	/* R2 */
    1d32:	82 e0       	ldi	r24, 0x02	; 2
    1d34:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x03;	/* R3 */
    1d36:	83 e0       	ldi	r24, 0x03	; 3
    1d38:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x04;	/* R4 */
    1d3a:	84 e0       	ldi	r24, 0x04	; 4
    1d3c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x05;	/* R5 */
    1d3e:	85 e0       	ldi	r24, 0x05	; 5
    1d40:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x06;	/* R6 */
    1d42:	86 e0       	ldi	r24, 0x06	; 6
    1d44:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x07;	/* R7 */
    1d46:	87 e0       	ldi	r24, 0x07	; 7
    1d48:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x08;	/* R8 */
    1d4a:	88 e0       	ldi	r24, 0x08	; 8
    1d4c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x09;	/* R9 */
    1d4e:	89 e0       	ldi	r24, 0x09	; 9
    1d50:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x10;	/* R10 */
    1d52:	80 e1       	ldi	r24, 0x10	; 16
    1d54:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x11;	/* R11 */
    1d56:	92 93       	st	-Z, r25
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x12;	/* R12 */
    1d58:	82 e1       	ldi	r24, 0x12	; 18
    1d5a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x13;	/* R13 */
    1d5c:	83 e1       	ldi	r24, 0x13	; 19
    1d5e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x14;	/* R14 */
    1d60:	84 e1       	ldi	r24, 0x14	; 20
    1d62:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x15;	/* R15 */
    1d64:	85 e1       	ldi	r24, 0x15	; 21
    1d66:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x16;	/* R16 */
    1d68:	86 e1       	ldi	r24, 0x16	; 22
    1d6a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x17;	/* R17 */
    1d6c:	87 e1       	ldi	r24, 0x17	; 23
    1d6e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x18;	/* R18 */
    1d70:	88 e1       	ldi	r24, 0x18	; 24
    1d72:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x19;	/* R19 */
    1d74:	89 e1       	ldi	r24, 0x19	; 25
    1d76:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x20;	/* R20 */
    1d78:	80 e2       	ldi	r24, 0x20	; 32
    1d7a:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x21;	/* R21 */
    1d7c:	81 e2       	ldi	r24, 0x21	; 33
    1d7e:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x22;	/* R22 */
    1d80:	22 93       	st	-Z, r18
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x23;	/* R23 */
    1d82:	83 e2       	ldi	r24, 0x23	; 35
    1d84:	82 93       	st	-Z, r24
	pxTopOfStack--;

	/* Place the parameter on the stack in the expected location. */
	usAddress = ( unsigned short ) pvParameters;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1d86:	42 93       	st	-Z, r20
	pxTopOfStack--;

	usAddress >>= 8;
	*pxTopOfStack = ( portSTACK_TYPE ) ( usAddress & ( unsigned short ) 0x00ff );
    1d88:	52 93       	st	-Z, r21
	pxTopOfStack--;

	*pxTopOfStack = ( portSTACK_TYPE ) 0x26;	/* R26 X */
    1d8a:	86 e2       	ldi	r24, 0x26	; 38
    1d8c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x27;	/* R27 */
    1d8e:	87 e2       	ldi	r24, 0x27	; 39
    1d90:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x28;	/* R28 Y */
    1d92:	88 e2       	ldi	r24, 0x28	; 40
    1d94:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x29;	/* R29 */
    1d96:	89 e2       	ldi	r24, 0x29	; 41
    1d98:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x30;	/* R30 Z */
    1d9a:	80 e3       	ldi	r24, 0x30	; 48
    1d9c:	82 93       	st	-Z, r24
	pxTopOfStack--;
	*pxTopOfStack = ( portSTACK_TYPE ) 0x031;	/* R31 */
    1d9e:	81 e3       	ldi	r24, 0x31	; 49
    1da0:	82 93       	st	-Z, r24
    1da2:	31 97       	sbiw	r30, 0x01	; 1
	pxTopOfStack--;

	/*lint +e950 +e611 +e923 */

	return pxTopOfStack;
}
    1da4:	cf 01       	movw	r24, r30
    1da6:	08 95       	ret

00001da8 <xPortStartScheduler>:
	/* Setup compare match value for compare match A.  Interrupts are disabled 
	before this is called so we need not worry here. */
	ucLowByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	ulCompareMatch >>= 8;
	ucHighByte = ( unsigned char ) ( ulCompareMatch & ( unsigned long ) 0xff );
	OCR1AH = ucHighByte;
    1da8:	1b bc       	out	0x2b, r1	; 43
	OCR1AL = ucLowByte;
    1daa:	8c e7       	ldi	r24, 0x7C	; 124
    1dac:	8a bd       	out	0x2a, r24	; 42

	/* Setup clock source and compare match behaviour. */
	ucLowByte = portCLEAR_COUNTER_ON_MATCH | portPRESCALE_64;
	TCCR1B = ucLowByte;
    1dae:	8b e0       	ldi	r24, 0x0B	; 11
    1db0:	8e bd       	out	0x2e, r24	; 46

	/* Enable the interrupt - this is okay as interrupt are currently globally
	disabled. */
	ucLowByte = TIMSK;
    1db2:	89 b7       	in	r24, 0x39	; 57
	ucLowByte |= portCOMPARE_MATCH_A_INTERRUPT_ENABLE;
    1db4:	80 61       	ori	r24, 0x10	; 16
	TIMSK = ucLowByte;
    1db6:	89 bf       	out	0x39, r24	; 57
{
	/* Setup the hardware to generate the tick. */
	prvSetupTimerInterrupt();

	/* Restore the context of the first task that is going to run. */
	portRESTORE_CONTEXT();
    1db8:	a0 91 b8 00 	lds	r26, 0x00B8
    1dbc:	b0 91 b9 00 	lds	r27, 0x00B9
    1dc0:	cd 91       	ld	r28, X+
    1dc2:	cd bf       	out	0x3d, r28	; 61
    1dc4:	dd 91       	ld	r29, X+
    1dc6:	de bf       	out	0x3e, r29	; 62
    1dc8:	ff 91       	pop	r31
    1dca:	ef 91       	pop	r30
    1dcc:	df 91       	pop	r29
    1dce:	cf 91       	pop	r28
    1dd0:	bf 91       	pop	r27
    1dd2:	af 91       	pop	r26
    1dd4:	9f 91       	pop	r25
    1dd6:	8f 91       	pop	r24
    1dd8:	7f 91       	pop	r23
    1dda:	6f 91       	pop	r22
    1ddc:	5f 91       	pop	r21
    1dde:	4f 91       	pop	r20
    1de0:	3f 91       	pop	r19
    1de2:	2f 91       	pop	r18
    1de4:	1f 91       	pop	r17
    1de6:	0f 91       	pop	r16
    1de8:	ff 90       	pop	r15
    1dea:	ef 90       	pop	r14
    1dec:	df 90       	pop	r13
    1dee:	cf 90       	pop	r12
    1df0:	bf 90       	pop	r11
    1df2:	af 90       	pop	r10
    1df4:	9f 90       	pop	r9
    1df6:	8f 90       	pop	r8
    1df8:	7f 90       	pop	r7
    1dfa:	6f 90       	pop	r6
    1dfc:	5f 90       	pop	r5
    1dfe:	4f 90       	pop	r4
    1e00:	3f 90       	pop	r3
    1e02:	2f 90       	pop	r2
    1e04:	1f 90       	pop	r1
    1e06:	0f 90       	pop	r0
    1e08:	0f be       	out	0x3f, r0	; 63
    1e0a:	0f 90       	pop	r0

	/* Simulate a function call end as generated by the compiler.  We will now
	jump to the start of the task the context of which we have just restored. */
	asm volatile ( "ret" );
    1e0c:	08 95       	ret

	/* Should not get here. */
	return pdTRUE;
}
    1e0e:	81 e0       	ldi	r24, 0x01	; 1
    1e10:	08 95       	ret

00001e12 <vPortEndScheduler>:

void vPortEndScheduler( void )
{
	/* It is unlikely that the AVR port will get stopped.  If required simply
	disable the tick interrupt here. */
}
    1e12:	08 95       	ret

00001e14 <vPortYieldFromTick>:
 * call comes from the tick ISR.
 */
void vPortYieldFromTick( void ) __attribute__ ( ( naked ) );
void vPortYieldFromTick( void )
{
	portSAVE_CONTEXT();
    1e14:	0f 92       	push	r0
    1e16:	0f b6       	in	r0, 0x3f	; 63
    1e18:	f8 94       	cli
    1e1a:	0f 92       	push	r0
    1e1c:	1f 92       	push	r1
    1e1e:	11 24       	eor	r1, r1
    1e20:	2f 92       	push	r2
    1e22:	3f 92       	push	r3
    1e24:	4f 92       	push	r4
    1e26:	5f 92       	push	r5
    1e28:	6f 92       	push	r6
    1e2a:	7f 92       	push	r7
    1e2c:	8f 92       	push	r8
    1e2e:	9f 92       	push	r9
    1e30:	af 92       	push	r10
    1e32:	bf 92       	push	r11
    1e34:	cf 92       	push	r12
    1e36:	df 92       	push	r13
    1e38:	ef 92       	push	r14
    1e3a:	ff 92       	push	r15
    1e3c:	0f 93       	push	r16
    1e3e:	1f 93       	push	r17
    1e40:	2f 93       	push	r18
    1e42:	3f 93       	push	r19
    1e44:	4f 93       	push	r20
    1e46:	5f 93       	push	r21
    1e48:	6f 93       	push	r22
    1e4a:	7f 93       	push	r23
    1e4c:	8f 93       	push	r24
    1e4e:	9f 93       	push	r25
    1e50:	af 93       	push	r26
    1e52:	bf 93       	push	r27
    1e54:	cf 93       	push	r28
    1e56:	df 93       	push	r29
    1e58:	ef 93       	push	r30
    1e5a:	ff 93       	push	r31
    1e5c:	a0 91 b8 00 	lds	r26, 0x00B8
    1e60:	b0 91 b9 00 	lds	r27, 0x00B9
    1e64:	0d b6       	in	r0, 0x3d	; 61
    1e66:	0d 92       	st	X+, r0
    1e68:	0e b6       	in	r0, 0x3e	; 62
    1e6a:	0d 92       	st	X+, r0
	vTaskIncrementTick();
    1e6c:	0e 94 70 04 	call	0x8e0	; 0x8e0 <vTaskIncrementTick>
	vTaskSwitchContext();
    1e70:	0e 94 a6 03 	call	0x74c	; 0x74c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1e74:	a0 91 b8 00 	lds	r26, 0x00B8
    1e78:	b0 91 b9 00 	lds	r27, 0x00B9
    1e7c:	cd 91       	ld	r28, X+
    1e7e:	cd bf       	out	0x3d, r28	; 61
    1e80:	dd 91       	ld	r29, X+
    1e82:	de bf       	out	0x3e, r29	; 62
    1e84:	ff 91       	pop	r31
    1e86:	ef 91       	pop	r30
    1e88:	df 91       	pop	r29
    1e8a:	cf 91       	pop	r28
    1e8c:	bf 91       	pop	r27
    1e8e:	af 91       	pop	r26
    1e90:	9f 91       	pop	r25
    1e92:	8f 91       	pop	r24
    1e94:	7f 91       	pop	r23
    1e96:	6f 91       	pop	r22
    1e98:	5f 91       	pop	r21
    1e9a:	4f 91       	pop	r20
    1e9c:	3f 91       	pop	r19
    1e9e:	2f 91       	pop	r18
    1ea0:	1f 91       	pop	r17
    1ea2:	0f 91       	pop	r16
    1ea4:	ff 90       	pop	r15
    1ea6:	ef 90       	pop	r14
    1ea8:	df 90       	pop	r13
    1eaa:	cf 90       	pop	r12
    1eac:	bf 90       	pop	r11
    1eae:	af 90       	pop	r10
    1eb0:	9f 90       	pop	r9
    1eb2:	8f 90       	pop	r8
    1eb4:	7f 90       	pop	r7
    1eb6:	6f 90       	pop	r6
    1eb8:	5f 90       	pop	r5
    1eba:	4f 90       	pop	r4
    1ebc:	3f 90       	pop	r3
    1ebe:	2f 90       	pop	r2
    1ec0:	1f 90       	pop	r1
    1ec2:	0f 90       	pop	r0
    1ec4:	0f be       	out	0x3f, r0	; 63
    1ec6:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1ec8:	08 95       	ret

00001eca <__vector_7>:
	 * count is incremented after the context is saved.
	 */
	void SIG_OUTPUT_COMPARE1A( void ) __attribute__ ( ( signal, naked ) );
	void SIG_OUTPUT_COMPARE1A( void )
	{
		vPortYieldFromTick();
    1eca:	0e 94 0a 0f 	call	0x1e14	; 0x1e14 <vPortYieldFromTick>
		asm volatile ( "reti" );
    1ece:	18 95       	reti

00001ed0 <vPortYield>:
 * can use a naked attribute.
 */
void vPortYield( void ) __attribute__ ( ( naked ) );
void vPortYield( void )
{
	portSAVE_CONTEXT();
    1ed0:	0f 92       	push	r0
    1ed2:	0f b6       	in	r0, 0x3f	; 63
    1ed4:	f8 94       	cli
    1ed6:	0f 92       	push	r0
    1ed8:	1f 92       	push	r1
    1eda:	11 24       	eor	r1, r1
    1edc:	2f 92       	push	r2
    1ede:	3f 92       	push	r3
    1ee0:	4f 92       	push	r4
    1ee2:	5f 92       	push	r5
    1ee4:	6f 92       	push	r6
    1ee6:	7f 92       	push	r7
    1ee8:	8f 92       	push	r8
    1eea:	9f 92       	push	r9
    1eec:	af 92       	push	r10
    1eee:	bf 92       	push	r11
    1ef0:	cf 92       	push	r12
    1ef2:	df 92       	push	r13
    1ef4:	ef 92       	push	r14
    1ef6:	ff 92       	push	r15
    1ef8:	0f 93       	push	r16
    1efa:	1f 93       	push	r17
    1efc:	2f 93       	push	r18
    1efe:	3f 93       	push	r19
    1f00:	4f 93       	push	r20
    1f02:	5f 93       	push	r21
    1f04:	6f 93       	push	r22
    1f06:	7f 93       	push	r23
    1f08:	8f 93       	push	r24
    1f0a:	9f 93       	push	r25
    1f0c:	af 93       	push	r26
    1f0e:	bf 93       	push	r27
    1f10:	cf 93       	push	r28
    1f12:	df 93       	push	r29
    1f14:	ef 93       	push	r30
    1f16:	ff 93       	push	r31
    1f18:	a0 91 b8 00 	lds	r26, 0x00B8
    1f1c:	b0 91 b9 00 	lds	r27, 0x00B9
    1f20:	0d b6       	in	r0, 0x3d	; 61
    1f22:	0d 92       	st	X+, r0
    1f24:	0e b6       	in	r0, 0x3e	; 62
    1f26:	0d 92       	st	X+, r0
	vTaskSwitchContext();
    1f28:	0e 94 a6 03 	call	0x74c	; 0x74c <vTaskSwitchContext>
	portRESTORE_CONTEXT();
    1f2c:	a0 91 b8 00 	lds	r26, 0x00B8
    1f30:	b0 91 b9 00 	lds	r27, 0x00B9
    1f34:	cd 91       	ld	r28, X+
    1f36:	cd bf       	out	0x3d, r28	; 61
    1f38:	dd 91       	ld	r29, X+
    1f3a:	de bf       	out	0x3e, r29	; 62
    1f3c:	ff 91       	pop	r31
    1f3e:	ef 91       	pop	r30
    1f40:	df 91       	pop	r29
    1f42:	cf 91       	pop	r28
    1f44:	bf 91       	pop	r27
    1f46:	af 91       	pop	r26
    1f48:	9f 91       	pop	r25
    1f4a:	8f 91       	pop	r24
    1f4c:	7f 91       	pop	r23
    1f4e:	6f 91       	pop	r22
    1f50:	5f 91       	pop	r21
    1f52:	4f 91       	pop	r20
    1f54:	3f 91       	pop	r19
    1f56:	2f 91       	pop	r18
    1f58:	1f 91       	pop	r17
    1f5a:	0f 91       	pop	r16
    1f5c:	ff 90       	pop	r15
    1f5e:	ef 90       	pop	r14
    1f60:	df 90       	pop	r13
    1f62:	cf 90       	pop	r12
    1f64:	bf 90       	pop	r11
    1f66:	af 90       	pop	r10
    1f68:	9f 90       	pop	r9
    1f6a:	8f 90       	pop	r8
    1f6c:	7f 90       	pop	r7
    1f6e:	6f 90       	pop	r6
    1f70:	5f 90       	pop	r5
    1f72:	4f 90       	pop	r4
    1f74:	3f 90       	pop	r3
    1f76:	2f 90       	pop	r2
    1f78:	1f 90       	pop	r1
    1f7a:	0f 90       	pop	r0
    1f7c:	0f be       	out	0x3f, r0	; 63
    1f7e:	0f 90       	pop	r0

	asm volatile ( "ret" );
    1f80:	08 95       	ret

00001f82 <xAreFlashCoRoutinesStillRunning>:
portBASE_TYPE xAreFlashCoRoutinesStillRunning( void )
{
	/* Return pdPASS or pdFAIL depending on whether an error has been detected
	or not. */
	return xCoRoutineFlashStatus;
}
    1f82:	80 91 7c 00 	lds	r24, 0x007C
    1f86:	08 95       	ret

00001f88 <vStartFlashCoRoutines>:

/*
 * See the header file for details.
 */
void vStartFlashCoRoutines( unsigned portBASE_TYPE uxNumberToCreate )
{
    1f88:	0f 93       	push	r16
    1f8a:	1f 93       	push	r17
    1f8c:	08 2f       	mov	r16, r24
    1f8e:	89 30       	cpi	r24, 0x09	; 9
    1f90:	08 f0       	brcs	.+2      	; 0x1f94 <vStartFlashCoRoutines+0xc>
    1f92:	08 e0       	ldi	r16, 0x08	; 8
	{
		uxNumberToCreate = crfMAX_FLASH_TASKS;
	}

	/* Create the queue used to pass data between the co-routines. */
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( unsigned portBASE_TYPE ) );
    1f94:	81 e0       	ldi	r24, 0x01	; 1
    1f96:	61 e0       	ldi	r22, 0x01	; 1
    1f98:	40 e0       	ldi	r20, 0x00	; 0
    1f9a:	0e 94 c5 0b 	call	0x178a	; 0x178a <xQueueGenericCreate>
    1f9e:	90 93 2d 07 	sts	0x072D, r25
    1fa2:	80 93 2c 07 	sts	0x072C, r24

	if( xFlashQueue )
    1fa6:	89 2b       	or	r24, r25
    1fa8:	89 f0       	breq	.+34     	; 0x1fcc <vStartFlashCoRoutines+0x44>
    1faa:	10 e0       	ldi	r17, 0x00	; 0
    1fac:	07 c0       	rjmp	.+14     	; 0x1fbc <vStartFlashCoRoutines+0x34>
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
    1fae:	80 e3       	ldi	r24, 0x30	; 48
    1fb0:	90 e1       	ldi	r25, 0x10	; 16
    1fb2:	60 e0       	ldi	r22, 0x00	; 0
    1fb4:	41 2f       	mov	r20, r17
    1fb6:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <xCoRoutineCreate>
	xFlashQueue = xQueueCreate( crfQUEUE_LENGTH, sizeof( unsigned portBASE_TYPE ) );

	if( xFlashQueue )
	{
		/* Create uxNumberToCreate 'fixed delay' co-routines. */
		for( uxIndex = 0; uxIndex < uxNumberToCreate; uxIndex++ )
    1fba:	1f 5f       	subi	r17, 0xFF	; 255
    1fbc:	10 17       	cp	r17, r16
    1fbe:	b8 f3       	brcs	.-18     	; 0x1fae <vStartFlashCoRoutines+0x26>
		{
			xCoRoutineCreate( prvFixedDelayCoRoutine, crfFIXED_DELAY_PRIORITY, uxIndex );
		}

		/* Create the 'flash' co-routine. */
		xCoRoutineCreate( prvFlashCoRoutine, crfFLASH_PRIORITY, crfFLASH_INDEX );
    1fc0:	89 ee       	ldi	r24, 0xE9	; 233
    1fc2:	9f e0       	ldi	r25, 0x0F	; 15
    1fc4:	61 e0       	ldi	r22, 0x01	; 1
    1fc6:	40 e0       	ldi	r20, 0x00	; 0
    1fc8:	0e 94 d0 0d 	call	0x1ba0	; 0x1ba0 <xCoRoutineCreate>
	}
}
    1fcc:	1f 91       	pop	r17
    1fce:	0f 91       	pop	r16
    1fd0:	08 95       	ret

00001fd2 <prvFlashCoRoutine>:
	crEND();
}
/*-----------------------------------------------------------*/

static void prvFlashCoRoutine( xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex )
{
    1fd2:	0f 93       	push	r16
    1fd4:	1f 93       	push	r17
    1fd6:	df 93       	push	r29
    1fd8:	cf 93       	push	r28
    1fda:	0f 92       	push	r0
    1fdc:	cd b7       	in	r28, 0x3d	; 61
    1fde:	de b7       	in	r29, 0x3e	; 62
static as we do not need it to maintain their state between blocks. */
signed portBASE_TYPE xResult;
unsigned portBASE_TYPE uxLEDToFlash;

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    1fe0:	8c 01       	movw	r16, r24
    1fe2:	fc 01       	movw	r30, r24
    1fe4:	80 8d       	ldd	r24, Z+24	; 0x18
    1fe6:	91 8d       	ldd	r25, Z+25	; 0x19
    1fe8:	f1 e0       	ldi	r31, 0x01	; 1
    1fea:	8c 3c       	cpi	r24, 0xCC	; 204
    1fec:	9f 07       	cpc	r25, r31
    1fee:	b1 f0       	breq	.+44     	; 0x201c <prvFlashCoRoutine+0x4a>
    1ff0:	21 e0       	ldi	r18, 0x01	; 1
    1ff2:	8d 3c       	cpi	r24, 0xCD	; 205
    1ff4:	92 07       	cpc	r25, r18
    1ff6:	51 f1       	breq	.+84     	; 0x204c <prvFlashCoRoutine+0x7a>
    1ff8:	89 2b       	or	r24, r25
    1ffa:	61 f5       	brne	.+88     	; 0x2054 <prvFlashCoRoutine+0x82>
	( void ) uxIndex;
	
	for( ;; )
	{
		/* Block to wait for the number of the LED to flash. */
		crQUEUE_RECEIVE( xHandle, xFlashQueue, &uxLEDToFlash, portMAX_DELAY, &xResult );		
    1ffc:	80 91 2c 07 	lds	r24, 0x072C
    2000:	90 91 2d 07 	lds	r25, 0x072D
    2004:	be 01       	movw	r22, r28
    2006:	6f 5f       	subi	r22, 0xFF	; 255
    2008:	7f 4f       	sbci	r23, 0xFF	; 255
    200a:	4f ef       	ldi	r20, 0xFF	; 255
    200c:	5f ef       	ldi	r21, 0xFF	; 255
    200e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <xQueueCRReceive>
    2012:	8c 3f       	cpi	r24, 0xFC	; 252
    2014:	71 f4       	brne	.+28     	; 0x2032 <prvFlashCoRoutine+0x60>
    2016:	8c ec       	ldi	r24, 0xCC	; 204
    2018:	91 e0       	ldi	r25, 0x01	; 1
    201a:	0f c0       	rjmp	.+30     	; 0x203a <prvFlashCoRoutine+0x68>
    201c:	80 91 2c 07 	lds	r24, 0x072C
    2020:	90 91 2d 07 	lds	r25, 0x072D
    2024:	be 01       	movw	r22, r28
    2026:	6f 5f       	subi	r22, 0xFF	; 255
    2028:	7f 4f       	sbci	r23, 0xFF	; 255
    202a:	40 e0       	ldi	r20, 0x00	; 0
    202c:	50 e0       	ldi	r21, 0x00	; 0
    202e:	0e 94 db 08 	call	0x11b6	; 0x11b6 <xQueueCRReceive>
    2032:	8b 3f       	cpi	r24, 0xFB	; 251
    2034:	31 f4       	brne	.+12     	; 0x2042 <prvFlashCoRoutine+0x70>
    2036:	8d ec       	ldi	r24, 0xCD	; 205
    2038:	91 e0       	ldi	r25, 0x01	; 1
    203a:	f8 01       	movw	r30, r16
    203c:	91 8f       	std	Z+25, r25	; 0x19
    203e:	80 8f       	std	Z+24, r24	; 0x18
    2040:	09 c0       	rjmp	.+18     	; 0x2054 <prvFlashCoRoutine+0x82>

		if( xResult != pdPASS )
    2042:	81 30       	cpi	r24, 0x01	; 1
    2044:	19 f0       	breq	.+6      	; 0x204c <prvFlashCoRoutine+0x7a>
		{
			/* We would not expect to wake unless we received something. */
			xCoRoutineFlashStatus = pdFAIL;
    2046:	10 92 7c 00 	sts	0x007C, r1
    204a:	d8 cf       	rjmp	.-80     	; 0x1ffc <prvFlashCoRoutine+0x2a>
		}
		else
		{
			/* We received the number of an LED to flash - flash it! */
			vParTestToggleLED( uxLEDToFlash );
    204c:	89 81       	ldd	r24, Y+1	; 0x01
    204e:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <vParTestToggleLED>
    2052:	d4 cf       	rjmp	.-88     	; 0x1ffc <prvFlashCoRoutine+0x2a>
		}
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    2054:	0f 90       	pop	r0
    2056:	cf 91       	pop	r28
    2058:	df 91       	pop	r29
    205a:	1f 91       	pop	r17
    205c:	0f 91       	pop	r16
    205e:	08 95       	ret

00002060 <prvFixedDelayCoRoutine>:
	}
}
/*-----------------------------------------------------------*/

static void prvFixedDelayCoRoutine( xCoRoutineHandle xHandle, unsigned portBASE_TYPE uxIndex )
{
    2060:	0f 93       	push	r16
    2062:	1f 93       	push	r17
    2064:	df 93       	push	r29
    2066:	cf 93       	push	r28
    2068:	0f 92       	push	r0
    206a:	cd b7       	in	r28, 0x3d	; 61
    206c:	de b7       	in	r29, 0x3e	; 62
    206e:	69 83       	std	Y+1, r22	; 0x01
																400 / portTICK_RATE_MS,
																450 / portTICK_RATE_MS,
																500  / portTICK_RATE_MS };

	/* Co-routines MUST start with a call to crSTART. */
	crSTART( xHandle );
    2070:	8c 01       	movw	r16, r24
    2072:	fc 01       	movw	r30, r24
    2074:	80 8d       	ldd	r24, Z+24	; 0x18
    2076:	91 8d       	ldd	r25, Z+25	; 0x19
    2078:	f1 e0       	ldi	r31, 0x01	; 1
    207a:	8c 38       	cpi	r24, 0x8C	; 140
    207c:	9f 07       	cpc	r25, r31
    207e:	f1 f0       	breq	.+60     	; 0x20bc <prvFixedDelayCoRoutine+0x5c>
    2080:	21 e0       	ldi	r18, 0x01	; 1
    2082:	8d 38       	cpi	r24, 0x8D	; 141
    2084:	92 07       	cpc	r25, r18
    2086:	18 f4       	brcc	.+6      	; 0x208e <prvFixedDelayCoRoutine+0x2e>
    2088:	89 2b       	or	r24, r25
    208a:	41 f0       	breq	.+16     	; 0x209c <prvFixedDelayCoRoutine+0x3c>
    208c:	3e c0       	rjmp	.+124    	; 0x210a <prvFixedDelayCoRoutine+0xaa>
    208e:	e1 e0       	ldi	r30, 0x01	; 1
    2090:	8d 38       	cpi	r24, 0x8D	; 141
    2092:	9e 07       	cpc	r25, r30
    2094:	39 f1       	breq	.+78     	; 0x20e4 <prvFixedDelayCoRoutine+0x84>
    2096:	80 5a       	subi	r24, 0xA0	; 160
    2098:	91 40       	sbci	r25, 0x01	; 1
    209a:	b9 f5       	brne	.+110    	; 0x210a <prvFixedDelayCoRoutine+0xaa>

	for( ;; )
	{
		/* Post our uxIndex value onto the queue.  This is used as the LED to
		flash. */
		crQUEUE_SEND( xHandle, xFlashQueue, ( void * ) &uxIndex, crfPOSTING_BLOCK_TIME, &xResult );
    209c:	80 91 2c 07 	lds	r24, 0x072C
    20a0:	90 91 2d 07 	lds	r25, 0x072D
    20a4:	be 01       	movw	r22, r28
    20a6:	6f 5f       	subi	r22, 0xFF	; 255
    20a8:	7f 4f       	sbci	r23, 0xFF	; 255
    20aa:	40 e0       	ldi	r20, 0x00	; 0
    20ac:	50 e0       	ldi	r21, 0x00	; 0
    20ae:	0e 94 20 09 	call	0x1240	; 0x1240 <xQueueCRSend>
    20b2:	8c 3f       	cpi	r24, 0xFC	; 252
    20b4:	71 f4       	brne	.+28     	; 0x20d2 <prvFixedDelayCoRoutine+0x72>
    20b6:	8c e8       	ldi	r24, 0x8C	; 140
    20b8:	91 e0       	ldi	r25, 0x01	; 1
    20ba:	24 c0       	rjmp	.+72     	; 0x2104 <prvFixedDelayCoRoutine+0xa4>
    20bc:	80 91 2c 07 	lds	r24, 0x072C
    20c0:	90 91 2d 07 	lds	r25, 0x072D
    20c4:	be 01       	movw	r22, r28
    20c6:	6f 5f       	subi	r22, 0xFF	; 255
    20c8:	7f 4f       	sbci	r23, 0xFF	; 255
    20ca:	40 e0       	ldi	r20, 0x00	; 0
    20cc:	50 e0       	ldi	r21, 0x00	; 0
    20ce:	0e 94 20 09 	call	0x1240	; 0x1240 <xQueueCRSend>
    20d2:	8b 3f       	cpi	r24, 0xFB	; 251
    20d4:	19 f4       	brne	.+6      	; 0x20dc <prvFixedDelayCoRoutine+0x7c>
    20d6:	8d e8       	ldi	r24, 0x8D	; 141
    20d8:	91 e0       	ldi	r25, 0x01	; 1
    20da:	14 c0       	rjmp	.+40     	; 0x2104 <prvFixedDelayCoRoutine+0xa4>

		if( xResult != pdPASS )
    20dc:	81 30       	cpi	r24, 0x01	; 1
    20de:	11 f0       	breq	.+4      	; 0x20e4 <prvFixedDelayCoRoutine+0x84>
		{
			/* For the reasons stated at the top of the file we should always
			find that we can post to the queue.  If we could not then an error
			has occurred. */
			xCoRoutineFlashStatus = pdFAIL;
    20e0:	10 92 7c 00 	sts	0x007C, r1
		}

		crDELAY( xHandle, xFlashRates[ uxIndex ] );
    20e4:	e9 81       	ldd	r30, Y+1	; 0x01
    20e6:	f0 e0       	ldi	r31, 0x00	; 0
    20e8:	ee 0f       	add	r30, r30
    20ea:	ff 1f       	adc	r31, r31
    20ec:	e3 58       	subi	r30, 0x83	; 131
    20ee:	ff 4f       	sbci	r31, 0xFF	; 255
    20f0:	80 81       	ld	r24, Z
    20f2:	91 81       	ldd	r25, Z+1	; 0x01
    20f4:	00 97       	sbiw	r24, 0x00	; 0
    20f6:	21 f0       	breq	.+8      	; 0x2100 <prvFixedDelayCoRoutine+0xa0>
    20f8:	60 e0       	ldi	r22, 0x00	; 0
    20fa:	70 e0       	ldi	r23, 0x00	; 0
    20fc:	0e 94 93 0d 	call	0x1b26	; 0x1b26 <vCoRoutineAddToDelayedList>
    2100:	80 ea       	ldi	r24, 0xA0	; 160
    2102:	91 e0       	ldi	r25, 0x01	; 1
    2104:	f8 01       	movw	r30, r16
    2106:	91 8f       	std	Z+25, r25	; 0x19
    2108:	80 8f       	std	Z+24, r24	; 0x18
	}

	/* Co-routines MUST end with a call to crEND. */
	crEND();
}
    210a:	0f 90       	pop	r0
    210c:	cf 91       	pop	r28
    210e:	df 91       	pop	r29
    2110:	1f 91       	pop	r17
    2112:	0f 91       	pop	r16
    2114:	08 95       	ret

00002116 <vCompeteingIntMathTask>:
	}
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vCompeteingIntMathTask, pvParameters )
{
    2116:	9f 92       	push	r9
    2118:	af 92       	push	r10
    211a:	bf 92       	push	r11
    211c:	cf 92       	push	r12
    211e:	df 92       	push	r13
    2120:	ef 92       	push	r14
    2122:	ff 92       	push	r15
    2124:	0f 93       	push	r16
    2126:	1f 93       	push	r17
    2128:	df 93       	push	r29
    212a:	cf 93       	push	r28
    212c:	00 d0       	rcall	.+0      	; 0x212e <vCompeteingIntMathTask+0x18>
    212e:	00 d0       	rcall	.+0      	; 0x2130 <vCompeteingIntMathTask+0x1a>
    2130:	cd b7       	in	r28, 0x3d	; 61
    2132:	de b7       	in	r29, 0x3e	; 62
volatile signed portBASE_TYPE *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
    2134:	8c 01       	movw	r16, r24
    2136:	ee 24       	eor	r14, r14
    2138:	ff 24       	eor	r15, r15
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    213a:	9b e7       	ldi	r25, 0x7B	; 123
    213c:	a9 2e       	mov	r10, r25
    213e:	b1 2c       	mov	r11, r1
    2140:	c1 2c       	mov	r12, r1
    2142:	d1 2c       	mov	r13, r1
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
				*pxTaskHasExecuted = pdTRUE;
    2144:	99 24       	eor	r9, r9
    2146:	93 94       	inc	r9
    2148:	03 c0       	rjmp	.+6      	; 0x2150 <vCompeteingIntMathTask+0x3a>
volatile signed portBASE_TYPE *pxTaskHasExecuted;

	/* Set a pointer to the variable we are going to set to true each
	iteration.  This is also a good test of the parameter passing mechanism
	within each port. */
	pxTaskHasExecuted = ( volatile signed portBASE_TYPE * ) pvParameters;
    214a:	81 e0       	ldi	r24, 0x01	; 1
    214c:	e8 2e       	mov	r14, r24
    214e:	f1 2c       	mov	r15, r1
	/* Keep performing a calculation and checking the result against a constant. */
	for( ;; )
	{
		/* Perform the calculation.  This will store partial value in
		registers, resulting in a good test of the context switch mechanism. */
		lValue = intgCONST1;
    2150:	a9 82       	std	Y+1, r10	; 0x01
    2152:	ba 82       	std	Y+2, r11	; 0x02
    2154:	cb 82       	std	Y+3, r12	; 0x03
    2156:	dc 82       	std	Y+4, r13	; 0x04
		lValue += intgCONST2;
    2158:	89 81       	ldd	r24, Y+1	; 0x01
    215a:	9a 81       	ldd	r25, Y+2	; 0x02
    215c:	ab 81       	ldd	r26, Y+3	; 0x03
    215e:	bc 81       	ldd	r27, Y+4	; 0x04
    2160:	89 5b       	subi	r24, 0xB9	; 185
    2162:	9b 46       	sbci	r25, 0x6B	; 107
    2164:	ac 4f       	sbci	r26, 0xFC	; 252
    2166:	bf 4f       	sbci	r27, 0xFF	; 255
    2168:	89 83       	std	Y+1, r24	; 0x01
    216a:	9a 83       	std	Y+2, r25	; 0x02
    216c:	ab 83       	std	Y+3, r26	; 0x03
    216e:	bc 83       	std	Y+4, r27	; 0x04
			taskYIELD();
		}
		#endif

		/* Finish off the calculation. */
		lValue *= intgCONST3;
    2170:	69 81       	ldd	r22, Y+1	; 0x01
    2172:	7a 81       	ldd	r23, Y+2	; 0x02
    2174:	8b 81       	ldd	r24, Y+3	; 0x03
    2176:	9c 81       	ldd	r25, Y+4	; 0x04
    2178:	2d ef       	ldi	r18, 0xFD	; 253
    217a:	3f ef       	ldi	r19, 0xFF	; 255
    217c:	4f ef       	ldi	r20, 0xFF	; 255
    217e:	5f ef       	ldi	r21, 0xFF	; 255
    2180:	0e 94 88 12 	call	0x2510	; 0x2510 <__mulsi3>
    2184:	69 83       	std	Y+1, r22	; 0x01
    2186:	7a 83       	std	Y+2, r23	; 0x02
    2188:	8b 83       	std	Y+3, r24	; 0x03
    218a:	9c 83       	std	Y+4, r25	; 0x04
		lValue /= intgCONST4;
    218c:	69 81       	ldd	r22, Y+1	; 0x01
    218e:	7a 81       	ldd	r23, Y+2	; 0x02
    2190:	8b 81       	ldd	r24, Y+3	; 0x03
    2192:	9c 81       	ldd	r25, Y+4	; 0x04
    2194:	27 e0       	ldi	r18, 0x07	; 7
    2196:	30 e0       	ldi	r19, 0x00	; 0
    2198:	40 e0       	ldi	r20, 0x00	; 0
    219a:	50 e0       	ldi	r21, 0x00	; 0
    219c:	0e 94 dd 12 	call	0x25ba	; 0x25ba <__divmodsi4>
    21a0:	c9 01       	movw	r24, r18
    21a2:	da 01       	movw	r26, r20
    21a4:	89 83       	std	Y+1, r24	; 0x01
    21a6:	9a 83       	std	Y+2, r25	; 0x02
    21a8:	ab 83       	std	Y+3, r26	; 0x03
    21aa:	bc 83       	std	Y+4, r27	; 0x04

		/* If the calculation is found to be incorrect we stop setting the 
		TaskHasExecuted variable so the check task can see an error has 
		occurred. */
		if( lValue != intgEXPECTED_ANSWER ) /*lint !e774 volatile used to prevent this being optimised out. */
    21ac:	89 81       	ldd	r24, Y+1	; 0x01
    21ae:	9a 81       	ldd	r25, Y+2	; 0x02
    21b0:	ab 81       	ldd	r26, Y+3	; 0x03
    21b2:	bc 81       	ldd	r27, Y+4	; 0x04
    21b4:	8b 51       	subi	r24, 0x1B	; 27
    21b6:	97 47       	sbci	r25, 0x77	; 119
    21b8:	ae 4f       	sbci	r26, 0xFE	; 254
    21ba:	bf 4f       	sbci	r27, 0xFF	; 255
    21bc:	31 f6       	brne	.-116    	; 0x214a <vCompeteingIntMathTask+0x34>
		{
			sError = pdTRUE;
		}

		if( sError == pdFALSE )
    21be:	e1 14       	cp	r14, r1
    21c0:	f1 04       	cpc	r15, r1
    21c2:	09 f0       	breq	.+2      	; 0x21c6 <vCompeteingIntMathTask+0xb0>
    21c4:	c2 cf       	rjmp	.-124    	; 0x214a <vCompeteingIntMathTask+0x34>
		{
			/* We have not encountered any errors, so set the flag that show
			we are still executing.  This will be periodically cleared by
			the check task. */
			portENTER_CRITICAL();
    21c6:	0f b6       	in	r0, 0x3f	; 63
    21c8:	f8 94       	cli
    21ca:	0f 92       	push	r0
				*pxTaskHasExecuted = pdTRUE;
    21cc:	f8 01       	movw	r30, r16
    21ce:	90 82       	st	Z, r9
			portEXIT_CRITICAL();
    21d0:	0f 90       	pop	r0
    21d2:	0f be       	out	0x3f, r0	; 63
    21d4:	bd cf       	rjmp	.-134    	; 0x2150 <vCompeteingIntMathTask+0x3a>

000021d6 <xAreIntegerMathsTaskStillRunning>:

	/* Check the maths tasks are still running by ensuring their check variables 
	are still being set to true. */
	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		if( xTaskCheck[ sTask ] == pdFALSE )
    21d6:	80 91 2e 07 	lds	r24, 0x072E
			xReturn = pdFALSE;
		}

		/* Reset the check variable so we can tell if it has been set by
		the next time around. */
		xTaskCheck[ sTask ] = pdFALSE;
    21da:	10 92 2e 07 	sts	0x072E, r1
    21de:	81 11       	cpse	r24, r1
    21e0:	81 e0       	ldi	r24, 0x01	; 1
	}

	return xReturn;
}
    21e2:	08 95       	ret

000021e4 <vStartIntegerMathTasks>:
static volatile signed portBASE_TYPE xTaskCheck[ intgNUMBER_OF_TASKS ] = { ( signed portBASE_TYPE ) pdFALSE };

/*-----------------------------------------------------------*/

void vStartIntegerMathTasks( unsigned portBASE_TYPE uxPriority )
{
    21e4:	af 92       	push	r10
    21e6:	bf 92       	push	r11
    21e8:	cf 92       	push	r12
    21ea:	df 92       	push	r13
    21ec:	ef 92       	push	r14
    21ee:	ff 92       	push	r15
    21f0:	0f 93       	push	r16
    21f2:	08 2f       	mov	r16, r24
short sTask;

	for( sTask = 0; sTask < intgNUMBER_OF_TASKS; sTask++ )
	{
		xTaskCreate( vCompeteingIntMathTask, ( signed char * ) "IntMath", intgSTACK_SIZE, ( void * ) &( xTaskCheck[ sTask ] ), uxPriority, ( xTaskHandle * ) NULL );
    21f4:	8b e8       	ldi	r24, 0x8B	; 139
    21f6:	90 e1       	ldi	r25, 0x10	; 16
    21f8:	6d e8       	ldi	r22, 0x8D	; 141
    21fa:	70 e0       	ldi	r23, 0x00	; 0
    21fc:	45 e5       	ldi	r20, 0x55	; 85
    21fe:	50 e0       	ldi	r21, 0x00	; 0
    2200:	2e e2       	ldi	r18, 0x2E	; 46
    2202:	37 e0       	ldi	r19, 0x07	; 7
    2204:	ee 24       	eor	r14, r14
    2206:	ff 24       	eor	r15, r15
    2208:	cc 24       	eor	r12, r12
    220a:	dd 24       	eor	r13, r13
    220c:	aa 24       	eor	r10, r10
    220e:	bb 24       	eor	r11, r11
    2210:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>
	}
}
    2214:	0f 91       	pop	r16
    2216:	ff 90       	pop	r15
    2218:	ef 90       	pop	r14
    221a:	df 90       	pop	r13
    221c:	cf 90       	pop	r12
    221e:	bf 90       	pop	r11
    2220:	af 90       	pop	r10
    2222:	08 95       	ret

00002224 <xArePollingQueuesStillRunning>:

	/* Check both the consumer and producer poll count to check they have both
	been changed since out last trip round.  We do not need a critical section
	around the check variables as this is called from a higher priority than
	the other tasks that access the same variables. */
	if( ( xPollingConsumerCount == pollqINITIAL_VALUE ) ||
    2224:	80 91 2f 07 	lds	r24, 0x072F
    2228:	88 23       	and	r24, r24
    222a:	21 f0       	breq	.+8      	; 0x2234 <xArePollingQueuesStillRunning+0x10>
    222c:	80 91 30 07 	lds	r24, 0x0730
    2230:	81 11       	cpse	r24, r1
    2232:	81 e0       	ldi	r24, 0x01	; 1
		xReturn = pdTRUE;
	}

	/* Set the check variables back down so we know if they have been
	incremented the next time around. */
	xPollingConsumerCount = pollqINITIAL_VALUE;
    2234:	10 92 2f 07 	sts	0x072F, r1
	xPollingProducerCount = pollqINITIAL_VALUE;
    2238:	10 92 30 07 	sts	0x0730, r1

	return xReturn;
}
    223c:	08 95       	ret

0000223e <vStartPolledQueueTasks>:
static volatile signed portBASE_TYPE xPollingConsumerCount = pollqINITIAL_VALUE, xPollingProducerCount = pollqINITIAL_VALUE;

/*-----------------------------------------------------------*/

void vStartPolledQueueTasks( unsigned portBASE_TYPE uxPriority )
{
    223e:	8f 92       	push	r8
    2240:	9f 92       	push	r9
    2242:	af 92       	push	r10
    2244:	bf 92       	push	r11
    2246:	cf 92       	push	r12
    2248:	df 92       	push	r13
    224a:	ef 92       	push	r14
    224c:	ff 92       	push	r15
    224e:	0f 93       	push	r16
    2250:	1f 93       	push	r17
    2252:	18 2f       	mov	r17, r24
static xQueueHandle xPolledQueue;

	/* Create the queue used by the producer and consumer. */
	xPolledQueue = xQueueCreate( pollqQUEUE_SIZE, ( unsigned portBASE_TYPE ) sizeof( unsigned short ) );
    2254:	8a e0       	ldi	r24, 0x0A	; 10
    2256:	62 e0       	ldi	r22, 0x02	; 2
    2258:	40 e0       	ldi	r20, 0x00	; 0
    225a:	0e 94 c5 0b 	call	0x178a	; 0x178a <xQueueGenericCreate>
    225e:	90 93 32 07 	sts	0x0732, r25
    2262:	80 93 31 07 	sts	0x0731, r24
	by the pre-processor if configQUEUE_REGISTRY_SIZE is not defined or is 
	defined to be less than 1. */
	vQueueAddToRegistry( xPolledQueue, ( signed char * ) "Poll_Test_Queue" );

	/* Spawn the producer and consumer. */
	xTaskCreate( vPolledQueueConsumer, ( signed char * ) "QConsNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
    2266:	81 e3       	ldi	r24, 0x31	; 49
    2268:	88 2e       	mov	r8, r24
    226a:	87 e0       	ldi	r24, 0x07	; 7
    226c:	98 2e       	mov	r9, r24
    226e:	87 e9       	ldi	r24, 0x97	; 151
    2270:	91 e1       	ldi	r25, 0x11	; 17
    2272:	65 e9       	ldi	r22, 0x95	; 149
    2274:	70 e0       	ldi	r23, 0x00	; 0
    2276:	45 e5       	ldi	r20, 0x55	; 85
    2278:	50 e0       	ldi	r21, 0x00	; 0
    227a:	94 01       	movw	r18, r8
    227c:	01 2f       	mov	r16, r17
    227e:	ee 24       	eor	r14, r14
    2280:	ff 24       	eor	r15, r15
    2282:	cc 24       	eor	r12, r12
    2284:	dd 24       	eor	r13, r13
    2286:	aa 24       	eor	r10, r10
    2288:	bb 24       	eor	r11, r11
    228a:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>
	xTaskCreate( vPolledQueueProducer, ( signed char * ) "QProdNB", pollqSTACK_SIZE, ( void * ) &xPolledQueue, uxPriority, ( xTaskHandle * ) NULL );
    228e:	8b e5       	ldi	r24, 0x5B	; 91
    2290:	91 e1       	ldi	r25, 0x11	; 17
    2292:	6d e9       	ldi	r22, 0x9D	; 157
    2294:	70 e0       	ldi	r23, 0x00	; 0
    2296:	45 e5       	ldi	r20, 0x55	; 85
    2298:	50 e0       	ldi	r21, 0x00	; 0
    229a:	94 01       	movw	r18, r8
    229c:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>
}
    22a0:	1f 91       	pop	r17
    22a2:	0f 91       	pop	r16
    22a4:	ff 90       	pop	r15
    22a6:	ef 90       	pop	r14
    22a8:	df 90       	pop	r13
    22aa:	cf 90       	pop	r12
    22ac:	bf 90       	pop	r11
    22ae:	af 90       	pop	r10
    22b0:	9f 90       	pop	r9
    22b2:	8f 90       	pop	r8
    22b4:	08 95       	ret

000022b6 <vPolledQueueProducer>:
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueProducer, pvParameters )
{
    22b6:	cf 92       	push	r12
    22b8:	df 92       	push	r13
    22ba:	ef 92       	push	r14
    22bc:	ff 92       	push	r15
    22be:	0f 93       	push	r16
    22c0:	1f 93       	push	r17
    22c2:	df 93       	push	r29
    22c4:	cf 93       	push	r28
    22c6:	00 d0       	rcall	.+0      	; 0x22c8 <vPolledQueueProducer+0x12>
    22c8:	cd b7       	in	r28, 0x3d	; 61
    22ca:	de b7       	in	r29, 0x3e	; 62
    22cc:	7c 01       	movw	r14, r24
unsigned short usValue = ( unsigned short ) 0;
    22ce:	1a 82       	std	Y+2, r1	; 0x02
    22d0:	19 82       	std	Y+1, r1	; 0x01
    22d2:	00 e0       	ldi	r16, 0x00	; 0
    22d4:	10 e0       	ldi	r17, 0x00	; 0
	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
		{
			/* Send an incrementing number on the queue without blocking. */
			if( xQueueSend( *( ( xQueueHandle * ) pvParameters ), ( void * ) &usValue, pollqNO_DELAY ) != pdPASS )
    22d6:	6e 01       	movw	r12, r28
    22d8:	08 94       	sec
    22da:	c1 1c       	adc	r12, r1
    22dc:	d1 1c       	adc	r13, r1
    22de:	1f c0       	rjmp	.+62     	; 0x231e <vPolledQueueProducer+0x68>
    22e0:	f7 01       	movw	r30, r14
    22e2:	80 81       	ld	r24, Z
    22e4:	91 81       	ldd	r25, Z+1	; 0x01
    22e6:	b6 01       	movw	r22, r12
    22e8:	40 e0       	ldi	r20, 0x00	; 0
    22ea:	50 e0       	ldi	r21, 0x00	; 0
    22ec:	20 e0       	ldi	r18, 0x00	; 0
    22ee:	0e 94 df 0a 	call	0x15be	; 0x15be <xQueueGenericSend>
    22f2:	81 30       	cpi	r24, 0x01	; 1
    22f4:	11 f0       	breq	.+4      	; 0x22fa <vPolledQueueProducer+0x44>
    22f6:	01 e0       	ldi	r16, 0x01	; 1
    22f8:	11 c0       	rjmp	.+34     	; 0x231c <vPolledQueueProducer+0x66>
				has been an error. */
				xError = pdTRUE;
			}
			else
			{
				if( xError == pdFALSE )
    22fa:	00 23       	and	r16, r16
    22fc:	51 f4       	brne	.+20     	; 0x2312 <vPolledQueueProducer+0x5c>
				{
					/* If an error has ever been recorded we stop incrementing the
					check variable. */
					portENTER_CRITICAL();
    22fe:	0f b6       	in	r0, 0x3f	; 63
    2300:	f8 94       	cli
    2302:	0f 92       	push	r0
						xPollingProducerCount++;
    2304:	80 91 30 07 	lds	r24, 0x0730
    2308:	8f 5f       	subi	r24, 0xFF	; 255
    230a:	80 93 30 07 	sts	0x0730, r24
					portEXIT_CRITICAL();
    230e:	0f 90       	pop	r0
    2310:	0f be       	out	0x3f, r0	; 63
				}

				/* Update the value we are going to post next time around. */
				usValue++;
    2312:	89 81       	ldd	r24, Y+1	; 0x01
    2314:	9a 81       	ldd	r25, Y+2	; 0x02
    2316:	01 96       	adiw	r24, 0x01	; 1
    2318:	9a 83       	std	Y+2, r25	; 0x02
    231a:	89 83       	std	Y+1, r24	; 0x01
unsigned short usValue = ( unsigned short ) 0;
signed portBASE_TYPE xError = pdFALSE, xLoop;

	for( ;; )
	{		
		for( xLoop = 0; xLoop < pollqVALUES_TO_PRODUCE; xLoop++ )
    231c:	1f 5f       	subi	r17, 0xFF	; 255
    231e:	13 30       	cpi	r17, 0x03	; 3
    2320:	fc f2       	brlt	.-66     	; 0x22e0 <vPolledQueueProducer+0x2a>
			}
		}

		/* Wait before we start posting again to ensure the consumer runs and
		empties the queue. */
		vTaskDelay( pollqPRODUCER_DELAY );
    2322:	88 ec       	ldi	r24, 0xC8	; 200
    2324:	90 e0       	ldi	r25, 0x00	; 0
    2326:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vTaskDelay>
    232a:	10 e0       	ldi	r17, 0x00	; 0
    232c:	d9 cf       	rjmp	.-78     	; 0x22e0 <vPolledQueueProducer+0x2a>

0000232e <vPolledQueueConsumer>:
	}
}  /*lint !e818 Function prototype must conform to API. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vPolledQueueConsumer, pvParameters )
{
    232e:	9f 92       	push	r9
    2330:	af 92       	push	r10
    2332:	bf 92       	push	r11
    2334:	cf 92       	push	r12
    2336:	df 92       	push	r13
    2338:	ef 92       	push	r14
    233a:	ff 92       	push	r15
    233c:	0f 93       	push	r16
    233e:	1f 93       	push	r17
    2340:	df 93       	push	r29
    2342:	cf 93       	push	r28
    2344:	00 d0       	rcall	.+0      	; 0x2346 <vPolledQueueConsumer+0x18>
    2346:	cd b7       	in	r28, 0x3d	; 61
    2348:	de b7       	in	r29, 0x3e	; 62
    234a:	98 2e       	mov	r9, r24
    234c:	c9 2e       	mov	r12, r25
    234e:	ee 24       	eor	r14, r14
    2350:	ff 24       	eor	r15, r15
    2352:	dd 24       	eor	r13, r13
	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
		{
			if( xQueueReceive( *( ( xQueueHandle * ) pvParameters ), &usData, pollqNO_DELAY ) == pdPASS )
    2354:	5e 01       	movw	r10, r28
    2356:	08 94       	sec
    2358:	a1 1c       	adc	r10, r1
    235a:	b1 1c       	adc	r11, r1
    235c:	23 c0       	rjmp	.+70     	; 0x23a4 <vPolledQueueConsumer+0x76>
    235e:	f8 01       	movw	r30, r16
    2360:	80 81       	ld	r24, Z
    2362:	91 81       	ldd	r25, Z+1	; 0x01
    2364:	b5 01       	movw	r22, r10
    2366:	40 e0       	ldi	r20, 0x00	; 0
    2368:	50 e0       	ldi	r21, 0x00	; 0
    236a:	20 e0       	ldi	r18, 0x00	; 0
    236c:	0e 94 13 0a 	call	0x1426	; 0x1426 <xQueueGenericReceive>
    2370:	81 30       	cpi	r24, 0x01	; 1
    2372:	c1 f4       	brne	.+48     	; 0x23a4 <vPolledQueueConsumer+0x76>
			{
				if( usData != usExpectedValue )
    2374:	29 81       	ldd	r18, Y+1	; 0x01
    2376:	3a 81       	ldd	r19, Y+2	; 0x02
    2378:	2e 15       	cp	r18, r14
    237a:	3f 05       	cpc	r19, r15
    237c:	19 f0       	breq	.+6      	; 0x2384 <vPolledQueueConsumer+0x56>
    237e:	dd 24       	eor	r13, r13
    2380:	d3 94       	inc	r13
    2382:	0c c0       	rjmp	.+24     	; 0x239c <vPolledQueueConsumer+0x6e>
					value should again be correct. */
					usExpectedValue = usData;
				}
				else
				{
					if( xError == pdFALSE )
    2384:	dd 20       	and	r13, r13
    2386:	51 f4       	brne	.+20     	; 0x239c <vPolledQueueConsumer+0x6e>
					{
						/* Only increment the check variable if no errors have
						occurred. */
						portENTER_CRITICAL();
    2388:	0f b6       	in	r0, 0x3f	; 63
    238a:	f8 94       	cli
    238c:	0f 92       	push	r0
							xPollingConsumerCount++;
    238e:	80 91 2f 07 	lds	r24, 0x072F
    2392:	8f 5f       	subi	r24, 0xFF	; 255
    2394:	80 93 2f 07 	sts	0x072F, r24
						portEXIT_CRITICAL();
    2398:	0f 90       	pop	r0
    239a:	0f be       	out	0x3f, r0	; 63
					}
				}

				/* Next time round we would expect the number to be one higher. */
				usExpectedValue++;
    239c:	79 01       	movw	r14, r18
    239e:	08 94       	sec
    23a0:	e1 1c       	adc	r14, r1
    23a2:	f1 1c       	adc	r15, r1
signed portBASE_TYPE xError = pdFALSE;

	for( ;; )
	{		
		/* Loop until the queue is empty. */
		while( uxQueueMessagesWaiting( *( ( xQueueHandle * ) pvParameters ) ) )
    23a4:	09 2d       	mov	r16, r9
    23a6:	1c 2d       	mov	r17, r12
    23a8:	f8 01       	movw	r30, r16
    23aa:	80 81       	ld	r24, Z
    23ac:	91 81       	ldd	r25, Z+1	; 0x01
    23ae:	0e 94 24 08 	call	0x1048	; 0x1048 <uxQueueMessagesWaiting>
    23b2:	88 23       	and	r24, r24
    23b4:	a1 f6       	brne	.-88     	; 0x235e <vPolledQueueConsumer+0x30>
			}
		}

		/* Now the queue is empty we block, allowing the producer to place more
		items in the queue. */
		vTaskDelay( pollqCONSUMER_DELAY );
    23b6:	84 eb       	ldi	r24, 0xB4	; 180
    23b8:	90 e0       	ldi	r25, 0x00	; 0
    23ba:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vTaskDelay>
    23be:	f2 cf       	rjmp	.-28     	; 0x23a4 <vPolledQueueConsumer+0x76>

000023c0 <xAreComTestTasksStillRunning>:
portBASE_TYPE xReturn;

	/* If the count of successful reception loops has not changed than at
	some time an error occurred (i.e. a character was received out of sequence)
	and we will return false. */
	if( uxRxLoops == comINITIAL_RX_COUNT_VALUE )
    23c0:	80 91 33 07 	lds	r24, 0x0733
		xReturn = pdTRUE;
	}

	/* Reset the count of successful Rx loops.  When this function is called
	again we expect this to have been incremented. */
	uxRxLoops = comINITIAL_RX_COUNT_VALUE;
    23c4:	10 92 33 07 	sts	0x0733, r1
    23c8:	81 11       	cpse	r24, r1
    23ca:	81 e0       	ldi	r24, 0x01	; 1

	return xReturn;
}
    23cc:	08 95       	ret

000023ce <vAltStartComTestTasks>:
static volatile unsigned portBASE_TYPE uxRxLoops = comINITIAL_RX_COUNT_VALUE;

/*-----------------------------------------------------------*/

void vAltStartComTestTasks( unsigned portBASE_TYPE uxPriority, unsigned long ulBaudRate, unsigned portBASE_TYPE uxLED )
{
    23ce:	af 92       	push	r10
    23d0:	bf 92       	push	r11
    23d2:	cf 92       	push	r12
    23d4:	df 92       	push	r13
    23d6:	ef 92       	push	r14
    23d8:	ff 92       	push	r15
    23da:	0f 93       	push	r16
    23dc:	1f 93       	push	r17
    23de:	18 2f       	mov	r17, r24
	/* Initialise the com port then spawn the Rx and Tx tasks. */
	uxBaseLED = uxLED;
    23e0:	20 93 34 07 	sts	0x0734, r18
	xSerialPortInitMinimal( ulBaudRate, comBUFFER_LEN );
    23e4:	cb 01       	movw	r24, r22
    23e6:	ba 01       	movw	r22, r20
    23e8:	48 e1       	ldi	r20, 0x18	; 24
    23ea:	0e 94 d2 01 	call	0x3a4	; 0x3a4 <xSerialPortInitMinimal>

	/* The Tx task is spawned with a lower priority than the Rx task. */
	xTaskCreate( vComTxTask, ( signed char * ) "COMTx", comSTACK_SIZE, NULL, uxPriority - 1, ( xTaskHandle * ) NULL );
    23ee:	01 2f       	mov	r16, r17
    23f0:	01 50       	subi	r16, 0x01	; 1
    23f2:	80 e6       	ldi	r24, 0x60	; 96
    23f4:	92 e1       	ldi	r25, 0x12	; 18
    23f6:	65 ea       	ldi	r22, 0xA5	; 165
    23f8:	70 e0       	ldi	r23, 0x00	; 0
    23fa:	45 e5       	ldi	r20, 0x55	; 85
    23fc:	50 e0       	ldi	r21, 0x00	; 0
    23fe:	20 e0       	ldi	r18, 0x00	; 0
    2400:	30 e0       	ldi	r19, 0x00	; 0
    2402:	ee 24       	eor	r14, r14
    2404:	ff 24       	eor	r15, r15
    2406:	cc 24       	eor	r12, r12
    2408:	dd 24       	eor	r13, r13
    240a:	aa 24       	eor	r10, r10
    240c:	bb 24       	eor	r11, r11
    240e:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>
	xTaskCreate( vComRxTask, ( signed char * ) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
    2412:	8d e1       	ldi	r24, 0x1D	; 29
    2414:	92 e1       	ldi	r25, 0x12	; 18
    2416:	6b ea       	ldi	r22, 0xAB	; 171
    2418:	70 e0       	ldi	r23, 0x00	; 0
    241a:	45 e5       	ldi	r20, 0x55	; 85
    241c:	50 e0       	ldi	r21, 0x00	; 0
    241e:	20 e0       	ldi	r18, 0x00	; 0
    2420:	30 e0       	ldi	r19, 0x00	; 0
    2422:	01 2f       	mov	r16, r17
    2424:	0e 94 d5 06 	call	0xdaa	; 0xdaa <xTaskGenericCreate>
}
    2428:	1f 91       	pop	r17
    242a:	0f 91       	pop	r16
    242c:	ff 90       	pop	r15
    242e:	ef 90       	pop	r14
    2430:	df 90       	pop	r13
    2432:	cf 90       	pop	r12
    2434:	bf 90       	pop	r11
    2436:	af 90       	pop	r10
    2438:	08 95       	ret

0000243a <vComRxTask>:
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    243a:	ef 92       	push	r14
    243c:	ff 92       	push	r15
    243e:	0f 93       	push	r16
    2440:	1f 93       	push	r17
    2442:	df 93       	push	r29
    2444:	cf 93       	push	r28
    2446:	0f 92       	push	r0
    2448:	cd b7       	in	r28, 0x3d	; 61
    244a:	de b7       	in	r29, 0x3e	; 62
    244c:	00 e0       	ldi	r16, 0x00	; 0
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    244e:	7e 01       	movw	r14, r28
    2450:	08 94       	sec
    2452:	e1 1c       	adc	r14, r1
    2454:	f1 1c       	adc	r15, r1
	}
} /*lint !e715 !e818 pvParameters is required for a task function even if it is not referenced. */
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComRxTask, pvParameters )
{
    2456:	11 e4       	ldi	r17, 0x41	; 65
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
		{
			/* Block on the queue that contains received bytes until a byte is
			available. */
			if( xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME ) )
    2458:	80 e0       	ldi	r24, 0x00	; 0
    245a:	90 e0       	ldi	r25, 0x00	; 0
    245c:	b7 01       	movw	r22, r14
    245e:	4f ef       	ldi	r20, 0xFF	; 255
    2460:	5f ef       	ldi	r21, 0xFF	; 255
    2462:	0e 94 c8 01 	call	0x390	; 0x390 <xSerialGetChar>
    2466:	88 23       	and	r24, r24
    2468:	51 f0       	breq	.+20     	; 0x247e <vComRxTask+0x44>
			{
				/* Was this the byte we were expecting?  If so, toggle the LED,
				otherwise we are out on sync and should break out of the loop
				until the expected character sequence is about to restart. */
				if( cByteRxed == cExpectedByte )
    246a:	89 81       	ldd	r24, Y+1	; 0x01
    246c:	81 17       	cp	r24, r17
    246e:	11 f0       	breq	.+4      	; 0x2474 <vComRxTask+0x3a>
    2470:	11 e0       	ldi	r17, 0x01	; 1
    2472:	09 c0       	rjmp	.+18     	; 0x2486 <vComRxTask+0x4c>
				{
					vParTestToggleLED( uxBaseLED + comRX_LED_OFFSET );
    2474:	80 91 34 07 	lds	r24, 0x0734
    2478:	8f 5f       	subi	r24, 0xFF	; 255
    247a:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <vParTestToggleLED>

	for( ;; )
	{
		/* We expect to receive the characters from comFIRST_BYTE to
		comLAST_BYTE in an incrementing order.  Loop to receive each byte. */
		for( cExpectedByte = comFIRST_BYTE; cExpectedByte <= comLAST_BYTE; cExpectedByte++ )
    247e:	1f 5f       	subi	r17, 0xFF	; 255
    2480:	19 35       	cpi	r17, 0x59	; 89
    2482:	51 f7       	brne	.-44     	; 0x2458 <vComRxTask+0x1e>
    2484:	10 e0       	ldi	r17, 0x00	; 0
				}
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comRX_LED_OFFSET, pdFALSE );
    2486:	80 91 34 07 	lds	r24, 0x0734
    248a:	8f 5f       	subi	r24, 0xFF	; 255
    248c:	60 e0       	ldi	r22, 0x00	; 0
    248e:	0e 94 05 01 	call	0x20a	; 0x20a <vParTestSetLED>

		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
    2492:	11 30       	cpi	r17, 0x01	; 1
    2494:	69 f4       	brne	.+26     	; 0x24b0 <vComRxTask+0x76>
    2496:	07 c0       	rjmp	.+14     	; 0x24a6 <vComRxTask+0x6c>
		{
			while( cByteRxed != comLAST_BYTE )
			{
				/* Block until the next char is available. */
				xSerialGetChar( xPort, &cByteRxed, comRX_BLOCK_TIME );
    2498:	80 e0       	ldi	r24, 0x00	; 0
    249a:	90 e0       	ldi	r25, 0x00	; 0
    249c:	b7 01       	movw	r22, r14
    249e:	4f ef       	ldi	r20, 0xFF	; 255
    24a0:	5f ef       	ldi	r21, 0xFF	; 255
    24a2:	0e 94 c8 01 	call	0x390	; 0x390 <xSerialGetChar>
		/* Did we break out of the loop because the characters were received in
		an unexpected order?  If so wait here until the character sequence is
		about to restart. */
		if( xResyncRequired == pdTRUE )
		{
			while( cByteRxed != comLAST_BYTE )
    24a6:	89 81       	ldd	r24, Y+1	; 0x01
    24a8:	88 35       	cpi	r24, 0x58	; 88
    24aa:	b1 f7       	brne	.-20     	; 0x2498 <vComRxTask+0x5e>

			/* Note that an error occurred which caused us to have to resync.
			We use this to stop incrementing the loop counter so
			sAreComTestTasksStillRunning() will return false - indicating an
			error. */
			xErrorOccurred++;
    24ac:	0f 5f       	subi	r16, 0xFF	; 255
    24ae:	d3 cf       	rjmp	.-90     	; 0x2456 <vComRxTask+0x1c>
			/* We have now resynced with the Tx task and can continue. */
			xResyncRequired = pdFALSE;
		}
		else
		{
			if( xErrorOccurred < comTOTAL_PERMISSIBLE_ERRORS )
    24b0:	02 30       	cpi	r16, 0x02	; 2
    24b2:	8c f6       	brge	.-94     	; 0x2456 <vComRxTask+0x1c>
				occurring (i.e. an unexpected character being received) will
				prevent this counter being incremented for the rest of the
				execution.   Don't worry about mutual exclusion on this
				variable - it doesn't really matter as we just want it
				to change. */
				uxRxLoops++;
    24b4:	80 91 33 07 	lds	r24, 0x0733
    24b8:	8f 5f       	subi	r24, 0xFF	; 255
    24ba:	80 93 33 07 	sts	0x0733, r24
    24be:	cb cf       	rjmp	.-106    	; 0x2456 <vComRxTask+0x1c>

000024c0 <vComTxTask>:
	xTaskCreate( vComRxTask, ( signed char * ) "COMRx", comSTACK_SIZE, NULL, uxPriority, ( xTaskHandle * ) NULL );
}
/*-----------------------------------------------------------*/

static portTASK_FUNCTION( vComTxTask, pvParameters )
{
    24c0:	1f 93       	push	r17
    24c2:	11 e4       	ldi	r17, 0x41	; 65
    24c4:	0e c0       	rjmp	.+28     	; 0x24e2 <vComTxTask+0x22>
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
		{
			if( xSerialPutChar( xPort, cByteToSend, comNO_BLOCK ) == pdPASS )
    24c6:	80 e0       	ldi	r24, 0x00	; 0
    24c8:	90 e0       	ldi	r25, 0x00	; 0
    24ca:	61 2f       	mov	r22, r17
    24cc:	40 e0       	ldi	r20, 0x00	; 0
    24ce:	50 e0       	ldi	r21, 0x00	; 0
    24d0:	0e 94 ae 01 	call	0x35c	; 0x35c <xSerialPutChar>
    24d4:	81 30       	cpi	r24, 0x01	; 1
    24d6:	21 f4       	brne	.+8      	; 0x24e0 <vComTxTask+0x20>
			{
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
    24d8:	80 91 34 07 	lds	r24, 0x0734
    24dc:	0e 94 e2 00 	call	0x1c4	; 0x1c4 <vParTestToggleLED>

	for( ;; )
	{
		/* Simply transmit a sequence of characters from comFIRST_BYTE to
		comLAST_BYTE. */
		for( cByteToSend = comFIRST_BYTE; cByteToSend <= comLAST_BYTE; cByteToSend++ )
    24e0:	1f 5f       	subi	r17, 0xFF	; 255
    24e2:	19 35       	cpi	r17, 0x59	; 89
    24e4:	84 f3       	brlt	.-32     	; 0x24c6 <vComTxTask+0x6>
				vParTestToggleLED( uxBaseLED + comTX_LED_OFFSET );
			}
		}

		/* Turn the LED off while we are not doing anything. */
		vParTestSetLED( uxBaseLED + comTX_LED_OFFSET, pdFALSE );
    24e6:	80 91 34 07 	lds	r24, 0x0734
    24ea:	60 e0       	ldi	r22, 0x00	; 0
    24ec:	0e 94 05 01 	call	0x20a	; 0x20a <vParTestSetLED>

		/* We have posted all the characters in the string - wait before
		re-sending.  Wait a pseudo-random time as this will provide a better
		test. */
		xTimeToWait = xTaskGetTickCount() + comOFFSET_TIME;
    24f0:	0e 94 92 03 	call	0x724	; 0x724 <xTaskGetTickCount>

		/* Make sure we don't wait too long... */
		xTimeToWait %= comTX_MAX_BLOCK_TIME;
    24f4:	03 96       	adiw	r24, 0x03	; 3
    24f6:	66 e9       	ldi	r22, 0x96	; 150
    24f8:	70 e0       	ldi	r23, 0x00	; 0
    24fa:	0e 94 a7 12 	call	0x254e	; 0x254e <__udivmodhi4>

		/* ...but we do want to wait. */
		if( xTimeToWait < comTX_MIN_BLOCK_TIME )
    24fe:	82 33       	cpi	r24, 0x32	; 50
    2500:	91 05       	cpc	r25, r1
    2502:	10 f4       	brcc	.+4      	; 0x2508 <vComTxTask+0x48>
    2504:	82 e3       	ldi	r24, 0x32	; 50
    2506:	90 e0       	ldi	r25, 0x00	; 0
		{
			xTimeToWait = comTX_MIN_BLOCK_TIME;
		}

		vTaskDelay( xTimeToWait );
    2508:	0e 94 e3 05 	call	0xbc6	; 0xbc6 <vTaskDelay>
    250c:	11 e4       	ldi	r17, 0x41	; 65
    250e:	db cf       	rjmp	.-74     	; 0x24c6 <vComTxTask+0x6>

00002510 <__mulsi3>:
    2510:	62 9f       	mul	r22, r18
    2512:	d0 01       	movw	r26, r0
    2514:	73 9f       	mul	r23, r19
    2516:	f0 01       	movw	r30, r0
    2518:	82 9f       	mul	r24, r18
    251a:	e0 0d       	add	r30, r0
    251c:	f1 1d       	adc	r31, r1
    251e:	64 9f       	mul	r22, r20
    2520:	e0 0d       	add	r30, r0
    2522:	f1 1d       	adc	r31, r1
    2524:	92 9f       	mul	r25, r18
    2526:	f0 0d       	add	r31, r0
    2528:	83 9f       	mul	r24, r19
    252a:	f0 0d       	add	r31, r0
    252c:	74 9f       	mul	r23, r20
    252e:	f0 0d       	add	r31, r0
    2530:	65 9f       	mul	r22, r21
    2532:	f0 0d       	add	r31, r0
    2534:	99 27       	eor	r25, r25
    2536:	72 9f       	mul	r23, r18
    2538:	b0 0d       	add	r27, r0
    253a:	e1 1d       	adc	r30, r1
    253c:	f9 1f       	adc	r31, r25
    253e:	63 9f       	mul	r22, r19
    2540:	b0 0d       	add	r27, r0
    2542:	e1 1d       	adc	r30, r1
    2544:	f9 1f       	adc	r31, r25
    2546:	bd 01       	movw	r22, r26
    2548:	cf 01       	movw	r24, r30
    254a:	11 24       	eor	r1, r1
    254c:	08 95       	ret

0000254e <__udivmodhi4>:
    254e:	aa 1b       	sub	r26, r26
    2550:	bb 1b       	sub	r27, r27
    2552:	51 e1       	ldi	r21, 0x11	; 17
    2554:	07 c0       	rjmp	.+14     	; 0x2564 <__udivmodhi4_ep>

00002556 <__udivmodhi4_loop>:
    2556:	aa 1f       	adc	r26, r26
    2558:	bb 1f       	adc	r27, r27
    255a:	a6 17       	cp	r26, r22
    255c:	b7 07       	cpc	r27, r23
    255e:	10 f0       	brcs	.+4      	; 0x2564 <__udivmodhi4_ep>
    2560:	a6 1b       	sub	r26, r22
    2562:	b7 0b       	sbc	r27, r23

00002564 <__udivmodhi4_ep>:
    2564:	88 1f       	adc	r24, r24
    2566:	99 1f       	adc	r25, r25
    2568:	5a 95       	dec	r21
    256a:	a9 f7       	brne	.-22     	; 0x2556 <__udivmodhi4_loop>
    256c:	80 95       	com	r24
    256e:	90 95       	com	r25
    2570:	bc 01       	movw	r22, r24
    2572:	cd 01       	movw	r24, r26
    2574:	08 95       	ret

00002576 <__udivmodsi4>:
    2576:	a1 e2       	ldi	r26, 0x21	; 33
    2578:	1a 2e       	mov	r1, r26
    257a:	aa 1b       	sub	r26, r26
    257c:	bb 1b       	sub	r27, r27
    257e:	fd 01       	movw	r30, r26
    2580:	0d c0       	rjmp	.+26     	; 0x259c <__udivmodsi4_ep>

00002582 <__udivmodsi4_loop>:
    2582:	aa 1f       	adc	r26, r26
    2584:	bb 1f       	adc	r27, r27
    2586:	ee 1f       	adc	r30, r30
    2588:	ff 1f       	adc	r31, r31
    258a:	a2 17       	cp	r26, r18
    258c:	b3 07       	cpc	r27, r19
    258e:	e4 07       	cpc	r30, r20
    2590:	f5 07       	cpc	r31, r21
    2592:	20 f0       	brcs	.+8      	; 0x259c <__udivmodsi4_ep>
    2594:	a2 1b       	sub	r26, r18
    2596:	b3 0b       	sbc	r27, r19
    2598:	e4 0b       	sbc	r30, r20
    259a:	f5 0b       	sbc	r31, r21

0000259c <__udivmodsi4_ep>:
    259c:	66 1f       	adc	r22, r22
    259e:	77 1f       	adc	r23, r23
    25a0:	88 1f       	adc	r24, r24
    25a2:	99 1f       	adc	r25, r25
    25a4:	1a 94       	dec	r1
    25a6:	69 f7       	brne	.-38     	; 0x2582 <__udivmodsi4_loop>
    25a8:	60 95       	com	r22
    25aa:	70 95       	com	r23
    25ac:	80 95       	com	r24
    25ae:	90 95       	com	r25
    25b0:	9b 01       	movw	r18, r22
    25b2:	ac 01       	movw	r20, r24
    25b4:	bd 01       	movw	r22, r26
    25b6:	cf 01       	movw	r24, r30
    25b8:	08 95       	ret

000025ba <__divmodsi4>:
    25ba:	97 fb       	bst	r25, 7
    25bc:	09 2e       	mov	r0, r25
    25be:	05 26       	eor	r0, r21
    25c0:	0e d0       	rcall	.+28     	; 0x25de <__divmodsi4_neg1>
    25c2:	57 fd       	sbrc	r21, 7
    25c4:	04 d0       	rcall	.+8      	; 0x25ce <__divmodsi4_neg2>
    25c6:	d7 df       	rcall	.-82     	; 0x2576 <__udivmodsi4>
    25c8:	0a d0       	rcall	.+20     	; 0x25de <__divmodsi4_neg1>
    25ca:	00 1c       	adc	r0, r0
    25cc:	38 f4       	brcc	.+14     	; 0x25dc <__divmodsi4_exit>

000025ce <__divmodsi4_neg2>:
    25ce:	50 95       	com	r21
    25d0:	40 95       	com	r20
    25d2:	30 95       	com	r19
    25d4:	21 95       	neg	r18
    25d6:	3f 4f       	sbci	r19, 0xFF	; 255
    25d8:	4f 4f       	sbci	r20, 0xFF	; 255
    25da:	5f 4f       	sbci	r21, 0xFF	; 255

000025dc <__divmodsi4_exit>:
    25dc:	08 95       	ret

000025de <__divmodsi4_neg1>:
    25de:	f6 f7       	brtc	.-4      	; 0x25dc <__divmodsi4_exit>
    25e0:	90 95       	com	r25
    25e2:	80 95       	com	r24
    25e4:	70 95       	com	r23
    25e6:	61 95       	neg	r22
    25e8:	7f 4f       	sbci	r23, 0xFF	; 255
    25ea:	8f 4f       	sbci	r24, 0xFF	; 255
    25ec:	9f 4f       	sbci	r25, 0xFF	; 255
    25ee:	08 95       	ret

000025f0 <memcpy>:
    25f0:	fb 01       	movw	r30, r22
    25f2:	dc 01       	movw	r26, r24
    25f4:	02 c0       	rjmp	.+4      	; 0x25fa <memcpy+0xa>
    25f6:	01 90       	ld	r0, Z+
    25f8:	0d 92       	st	X+, r0
    25fa:	41 50       	subi	r20, 0x01	; 1
    25fc:	50 40       	sbci	r21, 0x00	; 0
    25fe:	d8 f7       	brcc	.-10     	; 0x25f6 <memcpy+0x6>
    2600:	08 95       	ret

00002602 <memset>:
    2602:	dc 01       	movw	r26, r24
    2604:	01 c0       	rjmp	.+2      	; 0x2608 <memset+0x6>
    2606:	6d 93       	st	X+, r22
    2608:	41 50       	subi	r20, 0x01	; 1
    260a:	50 40       	sbci	r21, 0x00	; 0
    260c:	e0 f7       	brcc	.-8      	; 0x2606 <memset+0x4>
    260e:	08 95       	ret

00002610 <strncpy>:
    2610:	fb 01       	movw	r30, r22
    2612:	dc 01       	movw	r26, r24
    2614:	41 50       	subi	r20, 0x01	; 1
    2616:	50 40       	sbci	r21, 0x00	; 0
    2618:	48 f0       	brcs	.+18     	; 0x262c <strncpy+0x1c>
    261a:	01 90       	ld	r0, Z+
    261c:	0d 92       	st	X+, r0
    261e:	00 20       	and	r0, r0
    2620:	c9 f7       	brne	.-14     	; 0x2614 <strncpy+0x4>
    2622:	01 c0       	rjmp	.+2      	; 0x2626 <strncpy+0x16>
    2624:	1d 92       	st	X+, r1
    2626:	41 50       	subi	r20, 0x01	; 1
    2628:	50 40       	sbci	r21, 0x00	; 0
    262a:	e0 f7       	brcc	.-8      	; 0x2624 <strncpy+0x14>
    262c:	08 95       	ret

0000262e <__eerd_block_m323>:
    262e:	dc 01       	movw	r26, r24
    2630:	cb 01       	movw	r24, r22

00002632 <__eerd_blraw_m323>:
    2632:	fc 01       	movw	r30, r24
    2634:	e1 99       	sbic	0x1c, 1	; 28
    2636:	fe cf       	rjmp	.-4      	; 0x2634 <__eerd_blraw_m323+0x2>
    2638:	06 c0       	rjmp	.+12     	; 0x2646 <__eerd_blraw_m323+0x14>
    263a:	ff bb       	out	0x1f, r31	; 31
    263c:	ee bb       	out	0x1e, r30	; 30
    263e:	e0 9a       	sbi	0x1c, 0	; 28
    2640:	31 96       	adiw	r30, 0x01	; 1
    2642:	0d b2       	in	r0, 0x1d	; 29
    2644:	0d 92       	st	X+, r0
    2646:	41 50       	subi	r20, 0x01	; 1
    2648:	50 40       	sbci	r21, 0x00	; 0
    264a:	b8 f7       	brcc	.-18     	; 0x263a <__eerd_blraw_m323+0x8>
    264c:	08 95       	ret

0000264e <__eewr_byte_m323>:
    264e:	26 2f       	mov	r18, r22

00002650 <__eewr_r18_m323>:
    2650:	e1 99       	sbic	0x1c, 1	; 28
    2652:	fe cf       	rjmp	.-4      	; 0x2650 <__eewr_r18_m323>
    2654:	9f bb       	out	0x1f, r25	; 31
    2656:	8e bb       	out	0x1e, r24	; 30
    2658:	2d bb       	out	0x1d, r18	; 29
    265a:	0f b6       	in	r0, 0x3f	; 63
    265c:	f8 94       	cli
    265e:	e2 9a       	sbi	0x1c, 2	; 28
    2660:	e1 9a       	sbi	0x1c, 1	; 28
    2662:	0f be       	out	0x3f, r0	; 63
    2664:	01 96       	adiw	r24, 0x01	; 1
    2666:	08 95       	ret

00002668 <_exit>:
    2668:	f8 94       	cli

0000266a <__stop_program>:
    266a:	ff cf       	rjmp	.-2      	; 0x266a <__stop_program>
